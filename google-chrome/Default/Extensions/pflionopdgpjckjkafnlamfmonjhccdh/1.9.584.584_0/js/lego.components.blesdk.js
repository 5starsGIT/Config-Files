/*! lego.components.blesdk v2.4.2-236 2018-08-30 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["LEGO_BLE_SDK"] = factory();
	else
		root["LEGO_BLE_SDK"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(122);


/***/ }),
/* 1 */
/***/ (function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(125);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }
	
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.LDSDKLoggerLevel = undefined;
	
	var _stringify = __webpack_require__(19);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _typeof2 = __webpack_require__(49);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by frj on 22/02/16.
	 */
	
	/**
	 * The supported logger levels
	 * @property {number} ERROR - Error level
	 * @property {number} WARN - Warning level
	 * @property {number} INFO - Info level
	 * @property {number} DEBUG - Debug level
	 * @property {number} TRACE - Trace level
	 *
	 */
	var LDSDKLoggerLevel = exports.LDSDKLoggerLevel = {
	    ERROR: 4,
	    WARN: 3,
	    INFO: 2,
	    DEBUG: 1,
	    TRACE: 0,
	    /**
	     * @ignore
	     */
	    DISABLED: 99
	};
	
	var LDSDKLogger = function () {
	    function LDSDKLogger() {
	        (0, _classCallCheck3.default)(this, LDSDKLogger);
	    }
	
	    (0, _createClass3.default)(LDSDKLogger, null, [{
	        key: 'setLogger',
	
	
	        /**
	         * Set the logger to log to
	         * @param {{trace: function, debug: function, info: function, warn: function, error: function}} logger - The logger object the LDSDKLogger will forward the calls to - it should have the functions specified - otherwise nothing happens when using the api.
	         */
	        value: function setLogger(logger) {
	            LDSDKLogger.logger = logger;
	        }
	
	        /**
	         * Set the logger level. Messages logged at a level below this value will not be logged.
	         * @param {number} level - See {@link LDSDKLoggerLevel} for valid values
	         */
	
	    }, {
	        key: 'setLevel',
	        value: function setLevel(level) {
	            LDSDKLogger.level = level;
	        }
	
	        /**
	         * Disable the logger (by setting a level that no messages are logged at) - the logger instance within the LDSDKLogger is also cleared.
	         * To restart logging later on, the logger must be set using setLogger.
	         * @param {number} [level = 4] If called without a level parameter the default is 4 (ERROR) level.
	         */
	
	    }, {
	        key: 'disable',
	        value: function disable() {
	            if (LDSDKLogger.isLoggerSet()) {
	                if (LDSDKLogger.logger.log) {
	                    LDSDKLogger.logger.log('Disabled BLE SDK logger');
	                }
	            }
	            LDSDKLogger.setLevel(LDSDKLoggerLevel.DISABLED);
	            LDSDKLogger.logger = null;
	        }
	
	        /**
	         * Enable logging at the specified level and set a logger
	         * @param {number} [level = 4] If called without a level parameter the default is 4 (ERROR) level. See {@link LDSDKLoggerLevel} for valid level values.
	         * @param {object} [logger = console] If called without a logger parameter the default is to use the console.
	         */
	
	    }, {
	        key: 'enable',
	        value: function enable() {
	            var level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : LDSDKLoggerLevel.ERROR;
	            var logger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : console;
	
	            LDSDKLogger.setLevel(level);
	            LDSDKLogger.setLogger(logger);
	            if (LDSDKLogger.isLoggerSet()) {
	                if (LDSDKLogger.logger.log) {
	                    LDSDKLogger.logger.log('Enabled BLE SDK logger - level: ' + level);
	                }
	            }
	            return LDSDKLogger.level;
	        }
	
	        /**
	         * Check if a logger has been set. If no logger set, nothing will be logged.
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'isLoggerSet',
	        value: function isLoggerSet() {
	            return LDSDKLogger.logger && LDSDKLogger.logger !== null;
	        }
	
	        /**
	         * Check if TRACE level is enabled
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'isTraceEnabled',
	        value: function isTraceEnabled() {
	            return LDSDKLogger.isLoggerSet() && LDSDKLogger.level <= LDSDKLoggerLevel.TRACE;
	        }
	
	        /**
	         * Check if DEBUG level is enabled
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'isDebugEnabled',
	        value: function isDebugEnabled() {
	            return LDSDKLogger.isLoggerSet() && LDSDKLogger.level <= LDSDKLoggerLevel.DEBUG;
	        }
	
	        /**
	         * Check if INFO level is enabled
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'isInfoEnabled',
	        value: function isInfoEnabled() {
	            return LDSDKLogger.isLoggerSet() && LDSDKLogger.level <= LDSDKLoggerLevel.INFO;
	        }
	
	        /**
	         * Check if WARN level is enabled
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'isWarnEnabled',
	        value: function isWarnEnabled() {
	            return LDSDKLogger.isLoggerSet() && LDSDKLogger.level <= LDSDKLoggerLevel.WARN;
	        }
	
	        /**
	         * Check if ERROR level is enabled
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'isErrorEnabled',
	        value: function isErrorEnabled() {
	            return LDSDKLogger.isLoggerSet() && LDSDKLogger.level <= LDSDKLoggerLevel.ERROR;
	        }
	
	        /**
	         * Check if the level is enabled. Level should be in the 0-4 range. Where 0 = TRACE and 4 = ERROR. See {@link LDSDKLoggerLevel} for valid values
	         * @param {number} level
	         */
	
	    }, {
	        key: 'isLevelEnabled',
	        value: function isLevelEnabled(level) {
	            return LDSDKLogger.isLoggerSet() && level >= LDSDKLogger.level && level <= LDSDKLogger.maxLevel;
	        }
	
	        /**
	         * @ignore
	         * Return a string representation of the time
	         * @return {string}
	         */
	
	    }, {
	        key: 'getTime',
	        value: function getTime() {
	            var date = new Date();
	            var hours = LDSDKLogger.getFixedLengthString(date.getHours());
	            var minutes = LDSDKLogger.getFixedLengthString(date.getMinutes());
	            var seconds = LDSDKLogger.getFixedLengthString(date.getSeconds());
	            var millis = LDSDKLogger.getFixedLengthString(date.getMilliseconds(), 3);
	            // return `${hours}:${minutes}:${seconds}.${millis} :: `;
	            return hours + ':' + minutes + ':' + seconds + '.' + millis + ' :: LDSDK :: ';
	        }
	
	        /**
	         * @ignore
	         * @param val
	         * @param length
	         * @return {*}
	         */
	
	    }, {
	        key: 'getFixedLengthString',
	        value: function getFixedLengthString(val) {
	            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
	
	            if ((val + '').length > length) return val;
	            return ('0'.repeat(length) + val).slice(-1 * length);
	        }
	
	        /**
	         * Log a message at the error level - if the ERROR level is not enabled the call is ignored.
	         * @param {object|Array} args - The arguments to concatenate into a message
	         */
	
	    }, {
	        key: 'error',
	        value: function error() {
	            var level = 4;
	            if (!LDSDKLogger.isLoggerSet() || LDSDKLogger.level > level || LDSDKLogger.maxLevel < level) {
	                return;
	            }
	            var caller = LDSDKLogger.getTime();
	
	            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	                args[_key] = arguments[_key];
	            }
	
	            LDSDKLogger.logger.error(caller + 'ERROR :: ' + LDSDKLogger.concatArgs(args));
	        }
	
	        /**
	         * Log a message at the warn level - if the WARN level is not enabled the call is ignored.
	         * @param {object|Array} args - The arguments to concatenate into a message
	         */
	
	    }, {
	        key: 'warn',
	        value: function warn() {
	            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	                args[_key2] = arguments[_key2];
	            }
	
	            var level = 3;
	            if (!LDSDKLogger.isLoggerSet() || LDSDKLogger.level > level || LDSDKLogger.maxLevel < level) {
	                return;
	            }
	            var caller = LDSDKLogger.getTime();
	            if (LDSDKLogger.logger.warn) {
	                LDSDKLogger.logger.warn(caller + 'WARN :: ' + LDSDKLogger.concatArgs(args));
	            } else LDSDKLogger.error(arguments);
	        }
	
	        /**
	         * Log a message at the info level - if the INFO level is not enabled the call is ignored.
	         * @param {object|Array} args - The arguments to concatenate into a message
	         */
	
	    }, {
	        key: 'info',
	        value: function info() {
	            for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	                args[_key3] = arguments[_key3];
	            }
	
	            var level = 2;
	            if (!LDSDKLogger.isLoggerSet() || LDSDKLogger.level > level || LDSDKLogger.maxLevel < level) {
	                return;
	            }
	            var caller = LDSDKLogger.getTime();
	            if (LDSDKLogger.logger.info) {
	                LDSDKLogger.logger.info(caller + 'INFO :: ' + LDSDKLogger.concatArgs(args));
	            } else LDSDKLogger.log(arguments);
	        }
	
	        /**
	         * Log a message at the level specified - if the level is not enabled the call is ignored.
	         * @param {number} level - The level to log the message at. See {@link LDSDKLoggerLevel} for valid values.
	         * @param {object|Array} args - The arguments to concatenate into a message
	         */
	
	    }, {
	        key: 'logAtLevel',
	        value: function logAtLevel(level) {
	            for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
	                args[_key4 - 1] = arguments[_key4];
	            }
	
	            if (!LDSDKLogger.isLoggerSet() || LDSDKLogger.level > level || LDSDKLogger.maxLevel < level) {
	                return;
	            }
	            var caller = LDSDKLogger.getTime();
	            if (LDSDKLogger.logger.warn) {
	                LDSDKLogger.logger.warn(caller + 'INFO :: ' + LDSDKLogger.concatArgs(args));
	            } else LDSDKLogger.log(arguments);
	        }
	
	        /**
	         * Log a message at the debug level - if DEBUG level is not enabled the call is ignored.
	         * @param {object|Array} args - The arguments to concatenate into a message
	         */
	
	    }, {
	        key: 'debug',
	        value: function debug() {
	            for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	                args[_key5] = arguments[_key5];
	            }
	
	            var level = 1;
	            if (!LDSDKLogger.isLoggerSet() || LDSDKLogger.level > level || LDSDKLogger.maxLevel < level) {
	                return;
	            }
	            var caller = LDSDKLogger.getTime();
	            if (LDSDKLogger.logger.debug) {
	                LDSDKLogger.logger.debug(caller + 'DEBUG :: ' + LDSDKLogger.concatArgs(args));
	            } else {
	                // console.log('no debug method: ', args);
	                LDSDKLogger.log(caller, arguments);
	            }
	        }
	
	        /**
	         * Log a message at the trace level - if TRACE level is not enabled the call is ignored.
	         * @param {object|Array} args - The arguments to concatenate into a message
	         */
	
	    }, {
	        key: 'trace',
	        value: function trace() {
	            for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
	                args[_key6] = arguments[_key6];
	            }
	
	            var level = 0;
	            if (!LDSDKLogger.isLoggerSet() || LDSDKLogger.level > level || LDSDKLogger.maxLevel < level) {
	                return;
	            }
	            var caller = LDSDKLogger.getTime();
	            if (LDSDKLogger.logger.debug) {
	                LDSDKLogger.logger.debug(caller + 'TRACE :: ' + LDSDKLogger.concatArgs(args));
	            } else {
	                // console.log('no trace method: ', args);
	                LDSDKLogger.log(caller, arguments);
	            }
	        }
	
	        /**
	         * Log a message
	         * @param caller - The caller to use as message prefix - if not set the time is used as prefix for the message
	         * @param {object|Array} args - The arguments to log
	         */
	
	    }, {
	        key: 'log',
	        value: function log() {
	            for (var _len7 = arguments.length, args = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
	                args[_key7 - 1] = arguments[_key7];
	            }
	
	            var caller = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	
	            if (!LDSDKLogger.isLoggerSet()) {
	                return;
	            }
	            if (caller === null) {
	                caller = LDSDKLogger.getTime();
	            }
	            if (LDSDKLogger.logger.log) {
	                LDSDKLogger.logger.log(caller + 'LOG :: ' + LDSDKLogger.concatArgs(arguments, 1));
	            }
	        }
	
	        /**
	         * @ignore
	         * Get a message to print by the logger
	         *
	         * @param {object|Array} args - The arguments to log
	         * @param {number} [offset = 0] - The number of arguments to skip - by default no arguments are skipped
	         * @param {string} [separator = ' '] The separator to use between the args - by default a space is used
	         * @return {string}
	         */
	
	    }, {
	        key: 'concatArgs',
	        value: function concatArgs(args) {
	            var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	            var separator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ' ';
	
	
	            var message = '';
	            for (var i = offset; i < args.length; i++) {
	                if (i > offset) {
	                    message += separator;
	                }
	                var type = (0, _typeof3.default)(args[i]);
	                if (args[i] !== null) {
	                    if (type === 'object') {
	                        (function () {
	                            var o = {};
	                            o.o = args[i];
	                            var cache = [];
	                            if (args[i].hasOwnProperty('toString') && typeof args[i].toString === 'function') {
	                                message += args[i].toString();
	                            } else {
	                                // message += JSON.stringify(args[i]);
	                                message += (0, _stringify2.default)(o, function (key, value) {
	                                    if ((typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) === 'object' && value !== null) {
	                                        if (cache.indexOf(value) !== -1) {
	                                            // Circular reference found, ignore key
	                                            return;
	                                        }
	                                        // Store value in our collection
	                                        cache.push(value);
	                                    }
	                                    return value;
	                                }, '\t');
	                            }
	                            cache = null;
	                        })();
	                    } else {
	                        message += args[i];
	                    }
	                } else {
	                    message += 'null';
	                }
	            }
	
	            return message;
	        }
	    }]);
	    return LDSDKLogger;
	}();
	
	LDSDKLogger.logger = null;
	LDSDKLogger.level = LDSDKLoggerLevel.ERROR;
	LDSDKLogger.maxLevel = LDSDKLoggerLevel.ERROR;
	LDSDKLogger.includeCaller = true;
	exports.default = LDSDKLogger;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(139), __esModule: true };

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _setPrototypeOf = __webpack_require__(128);
	
	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);
	
	var _create = __webpack_require__(124);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _typeof2 = __webpack_require__(49);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
	  }
	
	  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
	};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _typeof2 = __webpack_require__(49);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	
	  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(74)('wks')
	  , uid        = __webpack_require__(57)
	  , Symbol     = __webpack_require__(10).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(135), __esModule: true };

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _DeviceServiceDefinition = __webpack_require__(47);
	
	var _DeviceServiceDefinition2 = _interopRequireDefault(_DeviceServiceDefinition);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by frj on 20/02/16.
	 * @ignore Internal use only
	 */
	var UuidHelper = function () {
	    function UuidHelper() {
	        (0, _classCallCheck3.default)(this, UuidHelper);
	    }
	
	    (0, _createClass3.default)(UuidHelper, null, [{
	        key: 'getLegoUuid',
	        value: function getLegoUuid(shorthandUuid) {
	            var legoGattPostfix = '-1212-efde-1523-785feabcd123';
	            return (('00000000' + shorthandUuid).substring(shorthandUuid.length) + legoGattPostfix).toLowerCase();
	        }
	    }, {
	        key: 'getSpecUuid',
	        value: function getSpecUuid(shorthandUuid) {
	            var specGattPostfix = '-0000-1000-8000-00805f9b34fb';
	            return (('00000000' + shorthandUuid).substring(shorthandUuid.length) + specGattPostfix).toLowerCase();
	        }
	    }, {
	        key: 'isLEGODevice',
	        value: function isLEGODevice(wrappedDevice) {
	            return wrappedDevice.getUuids() && wrappedDevice.getUuids().indexOf(_DeviceServiceDefinition2.default.getInstance().getServiceUUID()) >= 0;
	        }
	    }, {
	        key: 'getUuid',
	        value: function getUuid() {
	            var characteristicOrService = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	            if (characteristicOrService && characteristicOrService !== null && characteristicOrService.hasOwnProperty('uuid')) {
	                return characteristicOrService.uuid;
	            }
	            if (_LDSDKLogger2.default.isTraceEnabled()) {
	                _LDSDKLogger2.default.trace('Param to get uuid field from was not set');
	            }
	            return null;
	        }
	    }]);
	    return UuidHelper;
	}();
	
	exports.default = UuidHelper;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(142), __esModule: true };

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _promise = __webpack_require__(12);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (fn) {
	  return function () {
	    var gen = fn.apply(this, arguments);
	    return new _promise2.default(function (resolve, reject) {
	      function step(key, arg) {
	        try {
	          var info = gen[key](arg);
	          var value = info.value;
	        } catch (error) {
	          reject(error);
	          return;
	        }
	
	        if (info.done) {
	          resolve(value);
	        } else {
	          return _promise2.default.resolve(value).then(function (value) {
	            step("next", value);
	          }, function (err) {
	            step("throw", err);
	          });
	        }
	      }
	
	      return step("next");
	    });
	  };
	};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(185);


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(34)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(10)
	  , core      = __webpack_require__(4)
	  , ctx       = __webpack_require__(29)
	  , hide      = __webpack_require__(24)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(20)
	  , IE8_DOM_DEFINE = __webpack_require__(100)
	  , toPrimitive    = __webpack_require__(78)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(15) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _InputFormat = __webpack_require__(22);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	var _LDSDKError = __webpack_require__(44);
	
	var LDSDKError = _interopRequireWildcard(_LDSDKError);
	
	var _LegoServiceCallbackHelper = __webpack_require__(121);
	
	var _LegoServiceCallbackHelper2 = _interopRequireDefault(_LegoServiceCallbackHelper);
	
	var _ArrayHelper = __webpack_require__(115);
	
	var _ArrayHelper2 = _interopRequireDefault(_ArrayHelper);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Base class for the different LegoService implementations
	 * @abstract - Don't instantiate this class directly - use one of the inheriting classes.
	 */
	var LegoService = function () {
	    (0, _createClass3.default)(LegoService, [{
	        key: 'inputFormat',
	
	
	        /**
	         * @private
	         * @param {InputFormat} newInputFormat - The inputformat to set for the service. Setting inputformat will automatically update the dataFormat also.
	         */
	
	
	        /**
	         * @private
	         * @type {InputFormat|null}
	         */
	
	
	        /**
	         * @private
	         * @type {LegoServiceCallbackHelper}
	         */
	        set: function set(newInputFormat) {
	            this._inputFormat = newInputFormat;
	            this._dataFormat = this.dataFormatForInputFormat(newInputFormat);
	        }
	
	        /**
	         * @private
	         * @type {InputFormat}
	         */
	
	
	        /**
	         *
	         * @type {DataFormat|null}
	         * @private
	         */
	
	
	        /**
	         * @private
	         * @type {string|null}
	         */
	        ,
	        get: function get() {
	            return this._inputFormat;
	        }
	    }, {
	        key: 'valueData',
	        set: function set(valueData) {
	            this._valueData = valueData;
	            this._cachedNumberFromValueData = null;
	        },
	        get: function get() {
	            return this._valueData;
	        }
	
	        /**
	         * @abstract
	         * @param {ConnectInfo} connectInfo - The connectinfo for the service
	         * @param {BluetoothIO} io - The bluetoothIO instance being used by the service
	         */
	
	    }]);
	
	    function LegoService(connectInfo, io) {
	        (0, _classCallCheck3.default)(this, LegoService);
	        this.callbackHelper = new _LegoServiceCallbackHelper2.default();
	        this.ioCallbackListenerId = null;
	        this._inputFormat = null;
	        this._dataFormat = null;
	
	        if (io === undefined || io === null) {
	            throw new Error('IO must be set');
	        }
	        /**
	         * @private
	         * @type {number}
	         */
	        this.FIRST_INTERNAL_HUB_INDEX = 50;
	
	        /**
	         * @private
	         * @type {ConnectInfo}
	         */
	        this.connectInfo = connectInfo;
	
	        /**
	         * @private
	         * @type {BluetoothIO}
	         */
	        this.io = io;
	
	        /**
	         * @private
	         * @type {string}
	         */
	        this.ioCallbackListenerId = this.io.registerCallbackListener(this);
	        /**
	         * @private
	         * @type {LegoBluetoothDeviceImpl}
	         */
	        this.device = null;
	
	        /**
	         * @private
	         * @type {ArrayBuffer}
	         */
	        this.valueData = null;
	
	        /**
	         * @private
	         * @type {Array<DataFormat>}
	         */
	        this.validDataFormats = [];
	    }
	
	    /**
	     * @private
	     * @param {ConnectInfo} connectInfo - The connectinfo for the service
	     * @param {BluetoothIO} io - The bluetoothIO instance being used by the service
	     * @return {LegoService}
	     */
	
	
	    (0, _createClass3.default)(LegoService, [{
	        key: 'setDevice',
	
	
	        /**
	         * @private
	         * Set the device that the service is connected to
	         * @param {LegoBluetoothDeviceImpl} legoDevice
	         */
	        value: function setDevice(legoDevice) {
	            this.device = legoDevice;
	        }
	
	        /**
	         * Get the Lego device the sensor is connected to
	         * @return {LegoBluetoothDeviceImpl}
	         */
	
	    }, {
	        key: 'getDevice',
	        value: function getDevice() {
	            return this.device;
	        }
	
	        /**
	         * Get the ConnectInfo for the service
	         * @return {ConnectInfo|*}
	         */
	
	    }, {
	        key: 'getConnectInfo',
	        value: function getConnectInfo() {
	            return this.connectInfo;
	        }
	
	        /**
	         * @private
	         * Get the Bluetooth IO - should not be used for anything by clients
	         * @return {BluetoothIO|*}
	         */
	
	    }, {
	        key: 'getIo',
	        value: function getIo() {
	            return this.io;
	        }
	
	        /**
	         * Check if a service is internal or an external
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'isInternalService',
	        value: function isInternalService() {
	            return this.connectInfo.getHubIndex() >= this.FIRST_INTERNAL_HUB_INDEX;
	        }
	
	        /**
	         * Get the Connect Info for the service
	         * @param {BluetoothIO} io
	         * @return {ConnectInfo}
	         */
	
	    }, {
	        key: 'didRequestConnectInfo',
	        value: function didRequestConnectInfo(io) {
	            return this.connectInfo;
	        }
	
	        /**
	         * @private
	         * Verify if the data is valid for the service using the inputformat that has been set
	         * @param {DataBuffer} dataBuffer
	         */
	
	    }, {
	        key: 'verifyData',
	        value: function verifyData() {
	            var dataBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	
	            /**
	             *  No data is always ok
	             *  No InputDataFormats defined - means that all received data is accepted
	             */
	            if (dataBuffer !== null && this.validDataFormats !== undefined && this.validDataFormats.length !== 0) {
	                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                    _LDSDKLogger2.default.debug(this.getServiceName() + ' verifyData ' + new Int8Array(dataBuffer));
	                }
	                /**
	                 * If one or more InputDataFormats are defined, we look at the latest received InputFormat from the device
	                 * For a received value to be accepted, there:
	                 * 1. Must exists a DataFormat that matches the latest received InputFormat from device
	                 * 2. The received valueData length must match this DataFormat */
	                var dataFormat = this.dataFormatForInputFormat(this.inputFormat);
	                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                    _LDSDKLogger2.default.debug(this.getServiceName() + ' dataFormat ' + (dataFormat !== null ? dataFormat.toString() : 'null'));
	                }
	                if (dataFormat === null) {
	                    var msg = this.getServiceName() + ' Did not find a valid input data format.\nThe input format' + ' received from device' + ' is:' + this.inputFormat.toString() + '\nSupported formats: ' + this.validDataFormats.toString();
	                    _LDSDKLogger2.default.error(msg);
	                    throw new Error(msg, LDSDKError.ErrorCode.INTERNAL_ERROR);
	                }
	                this.verifyDataForDataFormat(dataBuffer, dataFormat);
	            }
	        }
	
	        /**
	         * @private
	         * Verify the data for a specific data format
	         * @param {DataBuffer} dataBuffer
	         * @param {DataFormat} dataFormat
	         */
	
	    }, {
	        key: 'verifyDataForDataFormat',
	        value: function verifyDataForDataFormat(dataBuffer, dataFormat) {
	            if (!(dataBuffer.byteLength === dataFormat.getDataSetSize() * dataFormat.getDataSetCount())) {
	                var msg = 'Value for service ' + this.getServiceName() + ' in mode ' + dataFormat.getModeName() + ' unit ' + dataFormat.getUnit() + ' is expected to have' + ' ' + dataFormat.getDataSetCount() + ' data sets each' + ' with size ' + dataFormat.getDataSetSize() + ' bytes, but did receive package with' + ' length ' + dataBuffer.byteLength;
	                if (_LDSDKLogger2.default.isErrorEnabled()) {
	                    _LDSDKLogger2.default.error(msg);
	                }
	                throw new Error(msg, LDSDKError.ErrorCode.INTERNAL_ERROR);
	            }
	        }
	
	        /**
	         * @private
	         * Get the DataFormat for the given InputFormat or null if no dataformat matching the input format is found
	         * @param {InputFormat} inputFormat
	         * @return {DataFormat|null}
	         */
	
	    }, {
	        key: 'dataFormatForInputFormat',
	        value: function dataFormatForInputFormat() {
	            var inputFormat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	
	            if (inputFormat !== null) {
	                for (var i = 0; i < this.validDataFormats.length; i++) {
	                    var dataFormat = this.validDataFormats[i];
	                    if (dataFormat.getMode() === inputFormat.getMode() && dataFormat.getUnit() === inputFormat.getUnit()) {
	                        if (typeof inputFormat.getNumberOfBytes() !== 'undefined' && dataFormat.getDataSetSize() * dataFormat.getDataSetCount() !== inputFormat.getNumberOfBytes()) {
	                            _LDSDKLogger2.default.error(this.getServiceName() + ' in mode ' + dataFormat.getModeName() + ' (' + dataFormat.getUnit() + '): expected data' + ' length is ' + dataFormat.getDataSetCount() + ' data sets of ' + dataFormat.getDataSetSize() + ' bytes' + ' input format received from device says ' + inputFormat.getNumberOfBytes() + ' number of bytes');
	                            return null;
	                        }
	                        if (_LDSDKLogger2.default.isTraceEnabled()) {
	                            _LDSDKLogger2.default.debug(this.getServiceName() + ' got ' + dataFormat.toString() + ' for ' + inputFormat.toString());
	                        }
	                        return dataFormat;
	                    }
	                }
	            }
	            return null;
	        }
	
	        // Abstract functions that classes inheriting from LegoService should override
	
	        /**
	         * @abstract
	         * Get the service name for the service
	         * @return {string}
	         */
	
	    }, {
	        key: 'getServiceName',
	        value: function getServiceName() {
	            return 'Undefined';
	        }
	
	        /**
	         * Get the default input format stored for the service
	         * @return {null|InputFormat}
	         */
	
	    }, {
	        key: 'getDefaultInputFormat',
	        value: function getDefaultInputFormat() {
	            return null;
	        }
	
	        /**
	         * Return the active input format stored for the service
	         * @return {null|InputFormat} Returns null if no input format has been set, otherwise the active input format is returned
	         */
	
	    }, {
	        key: 'getInputFormat',
	        value: function getInputFormat() {
	            return this.inputFormat;
	        }
	
	        /**
	         * Update the active input format for the service
	         * @param {InputFormat} newFormat - the new input format to set
	         */
	
	    }, {
	        key: 'updateInputFormat',
	        value: function updateInputFormat(newFormat) {
	            if (newFormat && newFormat !== null && (newFormat.getConnectId() !== this.getConnectInfo().getConnectId() || newFormat.getType() !== this.getConnectInfo().getTypeEnum())) {
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('Ignoring updateInputFormat call with inputFormat:', newFormat, 'It does not match' + ' the connectId or type of this service. "' + this.getServiceName() + '" ConnectId: ' + this.getConnectInfo().getConnectId() + ', Type: ' + this.getConnectInfo().getTypeEnum());
	                }
	                return;
	            } else {
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('updateInputFormat :: ' + this.toString() + ' :: newFormat: ' + newFormat.toString());
	                }
	            }
	            this.io.writeInputFormat(newFormat, this.connectInfo.getConnectId());
	        }
	
	        /**
	         * Get the mode for the current input format. If no input format has been set the default input format (if such a format exists for the service) is used.
	         *
	         * If neither an input format is set and no default input format is available for the service, 0 is returned.
	         * @return {number}
	         */
	
	    }, {
	        key: 'getInputFormatMode',
	        value: function getInputFormatMode() {
	            if (this.getInputFormat() !== null) {
	                return this.getInputFormat().getMode();
	            } else if (this.getDefaultInputFormat() !== null) {
	                return this.getDefaultInputFormat().getMode();
	            }
	            if (_LDSDKLogger2.default.isErrorEnabled()) {
	                _LDSDKLogger2.default.error(this.getServiceName() + ' No input format set, returning mode 0');
	            }
	            return 0;
	        }
	
	        /**
	         * Update the current input format with a new mode
	         * @param {number} newMode
	         */
	
	    }, {
	        key: 'updateCurrentInputFormatWithNewMode',
	        value: function updateCurrentInputFormatWithNewMode(newMode) {
	            if (this.getInputFormat() !== null) {
	                this.updateInputFormat(this.getInputFormat().inputFormatBySettingMode(newMode));
	            } else if (this.getDefaultInputFormat() !== null) {
	                this.updateInputFormat(this.getDefaultInputFormat().inputFormatBySettingMode(newMode));
	            } else {
	                if (_LDSDKLogger2.default.isErrorEnabled()) {
	                    _LDSDKLogger2.default.error(this.getServiceName() + ' Tried to update input format with new mode, but no current inputFormat or defaultInputFormat is' + ' set');
	                }
	            }
	        }
	
	        /**
	         * Get the array of valid data formats for the service. The array can have length 0 if no data formats has been set for the service.
	         * @see {@link addValidDataFormat}
	         * @return {Array<DataFormat>}
	         */
	
	    }, {
	        key: 'getValidDataFormats',
	        value: function getValidDataFormats() {
	            return this.validDataFormats;
	        }
	
	        /**
	         * Add a valid data format for the service.
	         * @param {DataFormat} dataFormat
	         */
	
	    }, {
	        key: 'addValidDataFormat',
	        value: function addValidDataFormat(dataFormat) {
	
	            // assert dataFormat != null : 'DataFormat cannot be null';
	
	            if (this.validDataFormats === null || this.validDataFormats === undefined) {
	                this.validDataFormats = [];
	            }
	            this.validDataFormats.push(dataFormat);
	        }
	
	        /**
	         * Remove a data format from the array of valid data formats
	         * @param {DataFormat} dataFormat
	         */
	
	    }, {
	        key: 'removeValidDataFormat',
	        value: function removeValidDataFormat(dataFormat) {
	            // assert dataFormat != null : 'DateFormat cannot be null';
	
	            if (this.validDataFormats === null || this.validDataFormats === undefined) {
	                return;
	            }
	            var indexOf = this.validDataFormats.indexOf(dataFormat);
	            if (indexOf >= 0) {
	                this.validDataFormats.splice(indexOf, 1);
	            }
	        }
	
	        /**
	         * Get the value data for the service as a typed array or null if no valueData has been set.
	         * @return {ArrayBuffer<number>|null}
	         */
	
	    }, {
	        key: 'getValueData',
	        value: function getValueData() {
	            return !this.valueData || this.valueData === null ? null : this.valueData.slice();
	        }
	
	        /**
	         * Get the numeric value for the value data or null if the number could not be parsed from the the value data
	         * @param {ArrayBuffer<number>} data
	         * @return {number|null}
	         */
	
	    }, {
	        key: 'getNumberFromValueData',
	        value: function getNumberFromValueData() {
	            var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	
	            var dataset = data;
	            if (data === null) {
	                // getNumberFrom this.valueData - check if we have a cached number and use that
	                if (this._cachedNumberFromValueData !== null) {
	                    return this._cachedNumberFromValueData;
	                }
	                dataset = this.valueData;
	            }
	            var valuesAsNumbers = this.getNumbersFromValueDataSet(dataset);
	            if (valuesAsNumbers === null) {
	                return null;
	            }
	
	            if (valuesAsNumbers.length !== 1) {
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('Cannot get value from service ' + this.getServiceName() + ' as as a number, the active data' + ' format is ' + this.dataFormatForInputFormat(this.inputFormat));
	                }
	                return null;
	            }
	
	            if (data === null) {
	                // Value is calculated for this.valueData - we can cache it until this.valueData is updated
	                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                    _LDSDKLogger2.default.debug('Calculated new getNumberFromValueData for this.valueData - caching value: ' + valuesAsNumbers[0]);
	                }
	                this._cachedNumberFromValueData = valuesAsNumbers[0];
	            }
	
	            return valuesAsNumbers[0];
	        }
	
	        /**
	         * Get an array of numbers from the value data set or null if no numbers could be parsed
	         * @param {ArrayBuffer} [dataSet=null]
	         * @return {Array<number>|null}
	         */
	
	    }, {
	        key: 'getNumbersFromValueDataSet',
	        value: function getNumbersFromValueDataSet() {
	            var dataSet = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	
	
	            if (dataSet === null) {
	                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                    _LDSDKLogger2.default.info(this.getServiceName() + ' getNumbersFromValueDataSet - dataSet is null - returning null');
	                }
	
	                return null;
	            }
	            var dataFormat = this._dataFormat;
	            if (dataFormat === null) {
	                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                    _LDSDKLogger2.default.info(this.getServiceName() + ' getNumbersFromValueDataSet - dataFormat is null -' + ' inputFormat: ' + this.inputFormat + ' - returning null');
	                }
	                return null;
	            }
	
	            try {
	                this.verifyDataForDataFormat(dataSet, dataFormat);
	                var results = [];
	                for (var i = 0; i < dataFormat.getDataSetCount(); ++i) {
	                    var currentIndex = i * dataFormat.getDataSetSize();
	                    var dataSetBytes = dataSet.slice(currentIndex, currentIndex + dataFormat.getDataSetSize());
	
	                    if (dataFormat.getUnit() === _InputFormat.InputFormatUnit.RAW || dataFormat.getUnit() === _InputFormat.InputFormatUnit.PERCENTAGE) {
	                        results.push(this.getIntegerFromData(dataSetBytes));
	                    } else {
	                        results.push(this.getFloatFromData(dataSetBytes));
	                    }
	                }
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug(this.getServiceName() + ' getNumbersFromValueDataSet returning ' + results.length + ' values: ' + results);
	                }
	                return results;
	            } catch (ldsdkError) {
	                _LDSDKLogger2.default.error(this.getServiceName() + ' - getNumbersFromValueDataSet failed: ' + ldsdkError);
	                return null;
	            }
	        }
	
	        /**
	         * Get a float numeric value from the typed array buffer
	         * @param {ArrayBuffer} dataBuffer
	         * @return {number}
	         */
	
	    }, {
	        key: 'getFloatFromData',
	        value: function getFloatFromData(dataBuffer) {
	            if (!dataBuffer || dataBuffer === null) {
	                return 0.0;
	            }
	            var data = new DataView(dataBuffer);
	            if (data.byteLength > 4) {
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('getFloatFromData Buffer is too big - expected 4 bytes - got ' + dataBuffer.byteLength + ' - cannot be' + ' parsed as float32 - raw values: ' + new Int8Array(data.buffer));
	                }
	                return 0;
	            } else if (data.byteLength % 4 !== 0) {
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('getFloatFromData Buffer has wrong size - ' + dataBuffer.byteLength + ' - cannot be' + ' parsed as float32' + ' (maybe you are using the wrong dataformat?) - falling back to parsing value as int');
	                }
	                return this.getIntegerFromData(dataBuffer);
	            }
	            return data.getFloat32(0, true);
	        }
	
	        /**
	         * Get an integer numeric value from the typed array buffer
	         * @param {ArrayBuffer} dataBuffer
	         * @return {number}
	         */
	
	    }, {
	        key: 'getIntegerFromData',
	        value: function getIntegerFromData(dataBuffer) {
	            if (!dataBuffer || dataBuffer === null) {
	                return 0;
	            }
	
	            var data = new DataView(dataBuffer);
	
	            if (data.byteLength === 1) {
	                return data.getInt8(0);
	            } else if (data.byteLength === 2) {
	                return data.getInt16(0, true);
	            } else if (data.byteLength === 4) {
	                return data.getInt32(0, true);
	            } else {
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('Cannot parse service value ' + new Int8Array(data.buffer) + ' as signed int, data with' + ' size ' + data.byteLength + ' too big');
	                }
	                return 0;
	            }
	        }
	
	        /**
	         * Helper method - get the integer value of the current valueData
	         * @return {number}
	         */
	
	    }, {
	        key: 'getValueAsInteger',
	        value: function getValueAsInteger() {
	            return this.getIntegerFromData(this.valueData);
	        }
	
	        /**
	         * Helper method - get the float value of the current valueData
	         * @return {number}
	         */
	
	    }, {
	        key: 'getValueAsFloat',
	        value: function getValueAsFloat() {
	            return this.getFloatFromData(this.valueData);
	        }
	
	        /**
	         * Send a read value request for this service to the hub.
	         *
	         * The response will be sent using the registered callback handler.
	         *
	         * @see {@link LegoServiceCallbackHelper#registerCallbackListener}
	         */
	
	    }, {
	        key: 'sendReadValueRequest',
	        value: function sendReadValueRequest() {
	            this.io.readValueForConnectId(this.connectInfo.getConnectId());
	        }
	
	        /**
	         * Send a reset state request for this service to the hub
	         */
	
	    }, {
	        key: 'sendResetStateRequest',
	        value: function sendResetStateRequest() {
	            this.io.resetStateForConnectId(this.connectInfo.getConnectId());
	        }
	
	        /**
	         * @ignore
	         * Write data to this service on the hub
	         * @param {TypedArray} data
	         */
	
	    }, {
	        key: 'writeData',
	        value: function writeData(data) {
	            this.io.writeData(data, this.inputFormat.getConnectId());
	        }
	
	        /**
	         * @ignore
	         *
	         * @param {BluetoothIO} io
	         * @param {InputFormat} inputFormat
	         */
	
	    }, {
	        key: 'didReceiveInputFormat',
	        value: function didReceiveInputFormat(io, inputFormat) {
	            if (this.inputFormat === null || !this.inputFormat.equals(inputFormat)) {
	                this.handleUpdatedInputFormat(inputFormat);
	            }
	        }
	
	        /**
	         * @ignore
	         *
	         * Handle the updated input format - ignores that format if it is does not match this service type or its connect id
	         * @param {InputFormat} inputFormat
	         */
	
	    }, {
	        key: 'handleUpdatedInputFormat',
	        value: function handleUpdatedInputFormat(inputFormat) {
	            if (inputFormat && inputFormat !== null && (inputFormat.getType() !== this.getConnectInfo().getTypeEnum() || inputFormat.getConnectId() !== this.getConnectInfo().getConnectId())) {
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('Ignoring updateInputFormat call with inputFormat:', inputFormat, 'It does not match' + ' the connectId or type of this service. "' + this.getServiceName() + '" ConnectId: ' + this.getConnectInfo().getConnectId() + ', Type: ' + this.getConnectInfo().getTypeEnum());
	                }
	                return;
	            }
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('handleUpdatedInputFormat - performDidUpdateInputFormatCallback - sendReadValueRequest');
	            }
	            var oldFormat = this.inputFormat;
	            this.inputFormat = inputFormat;
	
	            this.callbackHelper.performDidUpdateInputFormatCallback(this, oldFormat, this.inputFormat);
	
	            // After having received a new input format, we want the newest update value according to that format
	            this.sendReadValueRequest();
	        }
	
	        /**
	         * @ignore
	         *
	         * @param {BluetoothIO} io
	         * @param {ArrayBuffer} valueData
	         */
	
	    }, {
	        key: 'didReceiveValueData',
	        value: function didReceiveValueData(io, valueData) {
	            var inputFormat = this.getInputFormat();
	            if (inputFormat && inputFormat !== null && inputFormat.get) if (_LDSDKLogger2.default.isTraceEnabled()) {
	                _LDSDKLogger2.default.trace(this.getServiceName() + ' didReceiveValueData called with args. ValueData: ' + new Int8Array(valueData) + ', this.inputFormat: ' + (this.inputFormat !== null ? this.inputFormat.toString() : 'null'));
	            }
	            if (this.inputFormat !== null && valueData !== null && !_ArrayHelper2.default.isArrayBuffersEqual(this.valueData, valueData)) {
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('didReceiveValueData for ' + this.getServiceName() + ' received updated valueData: ' + this.getArrayBufferString(valueData) + ', old valueData: ' + this.getArrayBufferString(this.valueData));
	                }
	                this.handleUpdatedValueData(valueData);
	            }
	        }
	
	        /**
	         * @ignore
	         *
	         */
	
	    }, {
	        key: 'getArrayBufferString',
	        value: function getArrayBufferString() {
	            var buffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	
	            return buffer && buffer !== null ? '[' + new Int8Array(buffer).toString() + ']' : 'null';
	        }
	
	        /**
	         * Handle the updated value received from the service.
	         * @param {ArrayBuffer} valueData
	         */
	
	    }, {
	        key: 'handleUpdatedValueData',
	        value: function handleUpdatedValueData() {
	            var valueData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	
	            try {
	                this.verifyData(valueData); // Throws Error if unable to verify data
	            } catch (e) {
	                _LDSDKLogger2.default.error(this.getServiceName() + ' handleUpdatedValueData - verify failed: ' + e);
	            }
	            var oldData = this.valueData;
	            try {
	                this.valueData = valueData.slice();
	            } catch (e) {
	                _LDSDKLogger2.default.error(this.getServiceName() + ' handleUpdatedValueData - valueData.slice failed: ' + e);
	            }
	            this.callbackHelper.performDidUpdateValueDataCallback(this, oldData, this.valueData);
	        }
	
	        /**
	         * Registers a listener that will receive callbacks about service values
	         * @param {object} listener - An object with functions that can be called to signal value updates, inputformat
	         * changes etc.
	         * @return {string} Returns the Id of the registered listener. This id is needed if you want to unregister for
	         * service calls
	         */
	
	    }, {
	        key: 'registerCallbackListener',
	        value: function registerCallbackListener(listener) {
	            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                _LDSDKLogger2.default.info('Registering callback listener for service: ' + this.getServiceName() + ' on device: ' + this.getDevice());
	            }
	            return this.callbackHelper.registerCallbackListener(listener);
	        }
	
	        /**
	         * Unregisters a listener so no further callbacks about service values will be sent
	         * @param {string} listenerId
	         * @return {boolean} Indicating whether a listener was unregistered
	         */
	
	    }, {
	        key: 'unregisterCallbackListener',
	        value: function unregisterCallbackListener(listenerId) {
	            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                _LDSDKLogger2.default.info('Unregistering callback listener for service: ' + this.getServiceName() + ' on device:' + ' ' + this.getDevice());
	            }
	            return this.callbackHelper.unregisterCallbackListener(listenerId);
	        }
	
	        /**
	         * Check if it is the same service - by checking the connectInfo
	         * @param {LegoService} o - A service instance to compare to the current instance
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'equals',
	        value: function equals(o) {
	            if (this === o) return true;
	            if (o === null || this.constructor.name !== o.constructor.name) {
	                return false;
	            }
	
	            if (this.connectInfo !== null ? !this.connectInfo.equals(o.connectInfo) : o.connectInfo !== null) {
	                return false;
	            }
	
	            return true;
	        }
	
	        /**
	         * Get a string with details about the service - can be used for logging
	         * @return {string}
	         */
	
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return this.constructor.name + '[ ' + this.getServiceName() + ', ' + this.getConnectInfo().toString() + ', ' + (this.getInputFormat() !== null ? this.getInputFormat().toString() : 'InputFormat: null') + ', callbackHelper listeners: ' + this.callbackHelper.callbackListeners.size + ' ]';
	        }
	
	        /**
	         * Get a simple service representation
	         *
	         * @return {{deviceId: string, isInternalService: boolean, serviceName: string, serviceData: ({}|*), numberValue: number, updateInputFormat: simpleService.updateInputFormat, handleUpdatedInputFormat: simpleService.handleUpdatedInputFormat}}
	         */
	
	    }, {
	        key: 'getSimpleService',
	        value: function getSimpleService() {
	            var self = this;
	            var simpleService = {
	                deviceId: this.getDevice().getDeviceId(),
	                isInternalService: this.isInternalService(),
	                serviceName: this.getServiceName(),
	                serviceData: this.getSimpleServiceData(),
	                numberValue: this.getNumberFromValueData(),
	                updateInputFormat: function updateInputFormat(newFormat) {
	                    self.updateInputFormat(newFormat);
	                },
	                handleUpdatedInputFormat: function handleUpdatedInputFormat(inputFormat) {
	                    self.handleUpdatedInputFormat(inputFormat);
	                }
	            };
	            var defaultInputFormat = this.getDefaultInputFormat();
	            if (defaultInputFormat && defaultInputFormat !== null) {
	                simpleService['defaultInputFormat'] = this.getDefaultInputFormat().getSimpleInputFormat();
	            }
	
	            var inputFormat = this.getInputFormat();
	            if (inputFormat && inputFormat !== null) {
	                simpleService['inputFormat'] = this.getInputFormat().getSimpleInputFormat();
	            }
	
	            var connectInfo = this.getConnectInfo();
	            if (connectInfo && connectInfo !== null) {
	                simpleService['connectInfo'] = connectInfo.getSimpleConnectInfo();
	            }
	            return simpleService;
	        }
	
	        /**
	         * Get the simple service data - this function should be overridden by the service implementations that have
	         * data to return.
	         * @return {object}
	         */
	
	    }, {
	        key: 'getSimpleServiceData',
	        value: function getSimpleServiceData() {
	            return {};
	        }
	    }], [{
	        key: 'createService',
	        value: function createService(connectInfo, io) {
	            return new LegoService(connectInfo, io);
	        }
	    }]);
	    return LegoService;
	}(); /**
	      * Created by frj on 15/02/16.
	      */
	
	// 'use strict';
	
	exports.default = LegoService;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(134), __esModule: true };

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(25);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _typeof2 = __webpack_require__(49);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @ignore Internal use only
	 */
	var StringUtils = function () {
	    function StringUtils() {
	        (0, _classCallCheck3.default)(this, StringUtils);
	    }
	
	    (0, _createClass3.default)(StringUtils, null, [{
	        key: 'toUtf8Bytes',
	        value: function toUtf8Bytes(str) {
	            var utf8 = [];
	            for (var i = 0; i < str.length; i++) {
	                var charcode = str.charCodeAt(i);
	                if (charcode < 0x80) utf8.push(charcode);else if (charcode < 0x800) {
	                    utf8.push(0xc0 | charcode >> 6, 0x80 | charcode & 0x3f);
	                } else if (charcode < 0xd800 || charcode >= 0xe000) {
	                    utf8.push(0xe0 | charcode >> 12, 0x80 | charcode >> 6 & 0x3f, 0x80 | charcode & 0x3f);
	                }
	                // surrogate pair
	                else {
	                        i++;
	                        // UTF-16 encodes 0x10000-0x10FFFF by
	                        // subtracting 0x10000 and splitting the
	                        // 20 bits of 0x0-0xFFFFF into two halves
	                        charcode = 0x10000 + ((charcode & 0x3ff) << 10 | str.charCodeAt(i) & 0x3ff);
	                        utf8.push(0xf0 | charcode >> 18, 0x80 | charcode >> 12 & 0x3f, 0x80 | charcode >> 6 & 0x3f, 0x80 | charcode & 0x3f);
	                    }
	            }
	            return utf8;
	        }
	    }, {
	        key: 'toUtf8BytesOld',
	        value: function toUtf8BytesOld(str) {
	            var utf8 = unescape(encodeURIComponent(str));
	
	            var arr = [];
	            for (var i = 0; i < utf8.length; i++) {
	                arr.push(utf8.charCodeAt(i));
	            }
	            return arr;
	        }
	    }, {
	        key: 'decodeUtf8',
	        value: function decodeUtf8(arrayBuffer) {
	            var result = '';
	            var i = 0;
	            var c = 0;
	            // const c1 = 0;
	            var c2 = 0;
	
	            var data = new Uint8Array(arrayBuffer);
	
	            // Skip BOM if it is there
	            if (data.length >= 3 && data[0] === 0xef && data[1] === 0xbb && data[2] === 0xbf) {
	                i = 3;
	            }
	
	            while (i < data.length) {
	                c = data[i];
	
	                if (c < 128) {
	                    result += String.fromCharCode(c);
	                    i++;
	                } else if (c > 191 && c < 224) {
	                    if (i + 1 >= data.length) {
	                        throw 'UTF-8 Decode failed. Two byte character was truncated.';
	                    }
	                    c2 = data[i + 1];
	                    result += String.fromCharCode((c & 31) << 6 | c2 & 63);
	                    i += 2;
	                } else {
	                    if (i + 2 >= data.length) {
	                        throw 'UTF-8 Decode failed. Multi byte character was truncated.';
	                    }
	                    c2 = data[i + 1];
	                    c3 = data[i + 2];
	                    result += String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
	                    i += 3;
	                }
	            }
	            return result;
	        }
	    }, {
	        key: 'asBoolean',
	        value: function asBoolean(param) {
	            if (typeof param === 'boolean') {
	                return param;
	            } else if (typeof param === 'string') {
	                return param.toLowerCase() === 'true';
	            } else {
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('Param is not parseable as a boolean. Param type: ' + (typeof param === 'undefined' ? 'undefined' : (0, _typeof3.default)(param)) + ' param' + ' value: ', param, ' returning false');
	                }
	                return false;
	            }
	        }
	
	        /**
	         * Get a loggable string representation of a characteristic
	         * @param {NativeCharacteristic} characteristic
	         * @param {ArrayBuffer|null} [value=null]
	         * @return {string}
	         */
	
	    }, {
	        key: 'getCharacteristicString',
	        value: function getCharacteristicString(characteristic) {
	            var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
	            var valueString = '';
	            if (characteristic && characteristic !== null) {
	                if (characteristic.value === null || characteristic.value === undefined) {
	                    if (value !== null) {
	                        valueString = ', Value: ' + new Int8Array(value);
	                    }
	                } else {
	                    valueString = ', Value: ' + new Int8Array(characteristic.value);
	                }
	            } else {
	                if (value !== null) {
	                    valueString = ' (null characteristic) Value: ' + new Int8Array(value);
	                }
	            }
	            return 'Characteristic[ ' + this.getInstanceString(characteristic) + valueString + ' ]';
	        }
	
	        /**
	         * Get a loggable string representation of a characteristic or service
	         * @param {NativeCharacteristic|NativeService} characteristicOrService
	         * @return {string}
	         */
	
	    }, {
	        key: 'getInstanceString',
	        value: function getInstanceString(characteristicOrService) {
	            var uuidStr = '',
	                instanceIdStr = '';
	            if (characteristicOrService !== undefined && characteristicOrService !== null) {
	                if (characteristicOrService.uuid) {
	                    uuidStr = 'uuid: ' + characteristicOrService.uuid;
	                }
	                if (characteristicOrService.instanceId) {
	                    instanceIdStr = 'instanceId: ' + characteristicOrService.instanceId;
	                }
	            }
	
	            if (uuidStr !== '' && instanceIdStr !== '') {
	                return uuidStr + ', ' + instanceIdStr;
	            } else if (uuidStr !== '' && instanceIdStr === '') {
	                return '' + uuidStr;
	            } else if (uuidStr === '' && instanceIdStr !== '') {
	                return '' + instanceIdStr;
	            }
	
	            return '';
	        }
	
	        /**
	         *
	         * @param {LegoBluetoothDeviceImpl} device
	         * @return {string}
	         */
	
	    }, {
	        key: 'getDeviceString',
	        value: function getDeviceString(device) {
	            return device.getName() + ' [' + device.getAddress() + ']';
	        }
	    }]);
	    return StringUtils;
	}(); /**
	      * Created by frj on 19/02/16.
	      */
	
	exports.default = StringUtils;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.InputFormatUnit = undefined;
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	var _ConnectInfo = __webpack_require__(43);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by frj on 11/02/16.
	 */
	
	/**
	 *
	 * @type {object} InputFormatUnit
	 * @property {number} RAW
	 * @property {number} PERCENTAGE
	 * @property {number} SI
	 * @property {number} UNKNOWN
	 */
	var InputFormatUnit = exports.InputFormatUnit = {
	    RAW: 0,
	
	    PERCENTAGE: 1,
	
	    SI: 2,
	
	    UNKNOWN: 3,
	
	    /**
	     * Helper for getting the enum  - if the value is not one of the supported values - UNKNOWN is
	     * returned
	     * @param {number} val
	     * @return {number}
	     */
	    fromInteger: function fromInteger(val) {
	        switch (parseInt(val)) {
	            case 0:
	                return this.RAW;
	            case 1:
	                return this.PERCENTAGE;
	            case 2:
	                return this.SI;
	            case 3:
	                return this.UNKNOWN;
	            default:
	                {
	                    throw new Error('Unknown InputFormatUnit value \'' + val + '\'');
	                }
	        }
	    }
	};
	
	var InputFormat = function () {
	
	    /**
	     *
	     * @param {number} connectId
	     * @param {number} typeId
	     * @param {number} mode
	     * @param {number} deltaInterval
	     * @param {number} unit
	     * @param {bool} notificationsEnabled
	     * @param {ArrayBuffer} dataBuffer
	     */
	    function InputFormat() {
	        var connectId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	        var typeId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	        var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	        var deltaInterval = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	        var unit = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
	        var notificationsEnabled = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
	        var dataBuffer = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
	        (0, _classCallCheck3.default)(this, InputFormat);
	
	        this.FORMAT_DATA_SIZE = 8;
	        if (dataBuffer === null) {
	            this.connectId = connectId;
	            this.typeId = typeId;
	            this.mode = mode;
	            this.deltaInterval = deltaInterval;
	            this.unit = unit;
	            this.notificationsEnabled = notificationsEnabled;
	        } else {
	            var data = new DataView(dataBuffer);
	
	            this.revision = data.getUint8(0);
	            this.connectId = data.getUint8(1);
	            this.typeId = data.getUint8(2);
	            this.mode = data.getUint8(3);
	            this.deltaInterval = data.getUint32(4, true); // true === parse as little endian
	            this.unit = data.getUint8(8);
	            this.notificationsEnabled = data.getUint8(9) === 1;
	            this.numberOfBytes = data.getUint8(10);
	        }
	        if (_LDSDKLogger2.default.isTraceEnabled()) {
	            _LDSDKLogger2.default.trace('InputFormat instance created: ' + this.toString());
	        }
	    }
	
	    /**
	     *
	     * @param {ArrayBuffer} dataBuffer
	     * @return {InputFormat}
	     */
	
	
	    (0, _createClass3.default)(InputFormat, [{
	        key: 'inputFormatBySettingMode',
	
	
	        /**
	         * Creates a copy of this input format with a new mode
	         *
	         * @param {number} mode The new mode
	         *
	         * @return {InputFormat}
	         */
	        value: function inputFormatBySettingMode(mode) {
	            return new InputFormat(this.connectId, this.typeId, mode, this.deltaInterval, this.unit, this.notificationsEnabled);
	        }
	
	        /**
	         * Creates a copy of this input format with a new mode and unit
	         *
	         * @param {number} mode The new mode
	         * @param {InputFormatUnit} inputFormatUnit The new unit
	         *
	         * @return {InputFormat}
	         */
	
	    }, {
	        key: 'inputFormatBySettingModeAndUnit',
	        value: function inputFormatBySettingModeAndUnit(mode, inputFormatUnit) {
	            return new InputFormat(this.connectId, this.typeId, mode, this.deltaInterval, inputFormatUnit, this.notificationsEnabled);
	        }
	
	        /**
	         * Creates a copy of this input format with a new delta interval
	         *
	         * @param {number} deltaInterval The new delta interval
	         *
	         * @return {InputFormat}
	         */
	
	    }, {
	        key: 'inputFormatBySettingDeltaInterval',
	        value: function inputFormatBySettingDeltaInterval(deltaInterval) {
	            return new InputFormat(this.connectId, this.typeId, this.mode, deltaInterval, this.unit, this.notificationsEnabled);
	        }
	
	        /**
	         * Creates a copy of this input format with a new value for notifications enabled
	         *
	         * @param {bool} notificationsEnabled true if the sensor should send updates when the value changes, otherwise false
	         */
	
	    }, {
	        key: 'inputFormatBySettingNotificationsEnabled',
	        value: function inputFormatBySettingNotificationsEnabled(notificationsEnabled) {
	            return new InputFormat(this.connectId, this.typeId, this.mode, this.deltaInterval, this.unit, notificationsEnabled);
	        }
	
	        /**
	         *
	         * @return {number}
	         */
	
	    }, {
	        key: 'getRevision',
	        value: function getRevision() {
	            return this.revision;
	        }
	
	        /**
	         *
	         * @return {number}
	         */
	
	    }, {
	        key: 'getConnectId',
	        value: function getConnectId() {
	            return this.connectId;
	        }
	
	        /**
	         * Get the IOType for the service
	         * @return {number} - See {@link IOType} for the values that can be returned
	         */
	
	    }, {
	        key: 'getType',
	        value: function getType() {
	            return _ConnectInfo.IOType.fromInteger(this.typeId);
	        }
	
	        /**
	         * The input format mode
	         * @return {number}
	         */
	
	    }, {
	        key: 'getMode',
	        value: function getMode() {
	            return this.mode;
	        }
	
	        /**
	         * Get the delta interval for the input format
	         * @return {number}
	         */
	
	    }, {
	        key: 'getDeltaInterval',
	        value: function getDeltaInterval() {
	            return this.deltaInterval;
	        }
	
	        /**
	         * Get the unit set for the input format.
	         * @return {InputFormatUnit}
	         */
	
	    }, {
	        key: 'getUnit',
	        value: function getUnit() {
	            return InputFormatUnit.fromInteger(this.unit);
	        }
	
	        /**
	         *
	         * @return {boolean|*|bool}
	         */
	
	    }, {
	        key: 'isNotificationsEnabled',
	        value: function isNotificationsEnabled() {
	            return this.notificationsEnabled;
	        }
	
	        /**
	         *
	         * @return {number}
	         */
	
	    }, {
	        key: 'getNumberOfBytes',
	        value: function getNumberOfBytes() {
	            return this.numberOfBytes;
	        }
	
	        /**
	         *
	         * @return {ArrayBuffer}
	         */
	
	    }, {
	        key: 'writeFormatData',
	        value: function writeFormatData() {
	            var writeData = new DataView(new ArrayBuffer(this.FORMAT_DATA_SIZE));
	            writeData.setUint8(0, this.typeId);
	            writeData.setUint8(1, this.mode);
	            writeData.setUint32(2, this.deltaInterval, true); // true -> little endian
	            writeData.setUint8(6, this.unit);
	            writeData.setUint8(7, this.notificationsEnabled ? 1 : 0);
	
	            return writeData.buffer;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return 'InputFormat{' + 'revision=' + this.revision + ', connectId=' + this.connectId + ', typeId=' + this.typeId + ', mode=' + this.mode + ', deltaInterval=' + this.deltaInterval + ', unit=' + this.unit + ', notificationsEnabled=' + this.notificationsEnabled + ', numberOfBytes=' + this.numberOfBytes + '}';
	        }
	    }, {
	        key: 'equals',
	        value: function equals(other) {
	            if (this === other) return true;
	            if (other === null || other === undefined || other.constructor.name !== this.constructor.name) return false;
	
	            if (this.connectId !== other.connectId) return false;
	            if (this.deltaInterval !== other.deltaInterval) return false;
	            if (this.mode !== other.mode) return false;
	            if (this.notificationsEnabled !== other.notificationsEnabled) return false;
	            if (this.numberOfBytes !== other.numberOfBytes) return false;
	            if (this.revision !== other.revision) return false;
	            if (this.typeId !== other.typeId) return false;
	            if (this.unit !== other.unit) return false;
	
	            return true;
	        }
	
	        /**
	         * Create an InputFormat from the simple input format returned from the api.
	         *
	         * This can be used when updating the input format to e.g. the default input format returned.
	         * @param {obj} simpleInputFormat
	         * @return {InputFormat}
	         */
	
	    }, {
	        key: 'getSimpleInputFormat',
	
	
	        /**
	         * Get simple representation of the input format for use in the callback handlers.
	         * @return {{revision: number, connectId: number, typeId: IOType, mode: number, deltaInterval: number, unit: InputFormatUnit, notificationsEnabled: boolean}}
	         */
	        value: function getSimpleInputFormat() {
	            return {
	                revision: this.getRevision(),
	                connectId: this.getConnectId(),
	                typeId: this.getType(),
	                mode: this.getMode(),
	                deltaInterval: this.getDeltaInterval(),
	                unit: this.getUnit(),
	                notificationsEnabled: this.isNotificationsEnabled()
	            };
	        }
	    }], [{
	        key: 'inputFormatFromBuffer',
	        value: function inputFormatFromBuffer(dataBuffer) {
	            if (dataBuffer === null || dataBuffer === undefined) {
	                _LDSDKLogger2.default.error('Cannot instantiate InputFormat with null data');
	                return null;
	            }
	
	            // First byte is for the revision number, the rest of the bytes should be one or more input format sub-packages.
	            if (dataBuffer.byteLength !== InputFormat.INPUT_FORMAT_PACKAGE_SIZE) {
	                _LDSDKLogger2.default.error('Cannot create InputFormat from package with size ' + dataBuffer.byteLength + ', expected size to' + ' be ' + InputFormat.INPUT_FORMAT_PACKAGE_SIZE + ' - Buffer received: ' + new Int8Array(dataBuffer));
	                return null;
	            }
	
	            return new InputFormat(null, null, null, null, null, null, dataBuffer);
	        }
	
	        /**
	         * Create a new instance of an InputFormat.
	         *
	         * @param connectId            The connectId of the service, see {@link LegoService#connectInfo}
	         * @param type                 The type of the IO, see {@link LegoService#connectInfo}
	         * @param mode                 The mode of the IO (Inputs/Senors may support a number of different modes)
	         * @param deltaInterval        The delta interval
	         * @param unit                 The unit the sensor should return values in
	         * @param notificationsEnabled true if the device should send updates when the value changes, otherwise false
	         *
	         * @return {InputFormat}
	         */
	
	    }, {
	        key: 'inputFormat',
	        value: function inputFormat(connectId, type, mode, deltaInterval, unit, notificationsEnabled) {
	            return new InputFormat(connectId, type, mode, deltaInterval, unit, notificationsEnabled);
	        }
	    }, {
	        key: 'fromSimpleInputFormat',
	        value: function fromSimpleInputFormat(simpleInputFormat) {
	            return InputFormat.inputFormat(simpleInputFormat.connectId, simpleInputFormat.typeId, simpleInputFormat.mode, simpleInputFormat.deltaInterval, simpleInputFormat.unit, simpleInputFormat.notificationsEnabled);
	        }
	    }]);
	    return InputFormat;
	}();
	
	InputFormat.INPUT_FORMAT_PACKAGE_SIZE = 11;
	InputFormat.FORMAT_DATA_SIZE = 8;
	exports.default = InputFormat;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _getPrototypeOf = __webpack_require__(5);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _getOwnPropertyDescriptor = __webpack_require__(126);
	
	var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function get(object, property, receiver) {
	  if (object === null) object = Function.prototype;
	  var desc = (0, _getOwnPropertyDescriptor2.default)(object, property);
	
	  if (desc === undefined) {
	    var parent = (0, _getPrototypeOf2.default)(object);
	
	    if (parent === null) {
	      return undefined;
	    } else {
	      return get(parent, property, receiver);
	    }
	  } else if ("value" in desc) {
	    return desc.value;
	  } else {
	    var getter = desc.get;
	
	    if (getter === undefined) {
	      return undefined;
	    }
	
	    return getter.call(receiver);
	  }
	};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(17)
	  , createDesc = __webpack_require__(56);
	module.exports = __webpack_require__(15) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ }),
/* 25 */
/***/ (function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(101)
	  , defined = __webpack_require__(51);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.DeviceCallbackHelper = exports.DeviceFunctionEnum = exports.DeviceCategoryEnum = exports.StateEnum = undefined;
	
	var _getIterator2 = __webpack_require__(33);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _stringify = __webpack_require__(19);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _promise = __webpack_require__(12);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _map = __webpack_require__(9);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	var _DeviceInfo = __webpack_require__(60);
	
	var _DeviceInfo2 = _interopRequireDefault(_DeviceInfo);
	
	var _IdHelper = __webpack_require__(28);
	
	var _IdHelper2 = _interopRequireDefault(_IdHelper);
	
	var _LegoServiceFactory = __webpack_require__(63);
	
	var _LegoServiceFactory2 = _interopRequireDefault(_LegoServiceFactory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @type {object} StateEnum represents the connected state of a device
	 * @property {number} DisconnectedAdvertising - The Device is disconnected and no connection attempt is in progress
	 * @property {number} DisconnectedNotAdvertising - The Device is disconnected and no longer advertising - the device
	 * also returns to this state after a successful connection has been closed
	 * @property {number} Connecting - A connection attempt is in progress
	 * @property {number} Interrogating - Connected and interrogating Device for required services
	 * @property {number} InterrogationFinished - Connected and interrogation complete - device is ready for use
	 */
	var StateEnum = exports.StateEnum = {
	    /**
	     * The Device is disconnected and no connection attempt is in progress
	     * @constructor
	     */
	    DisconnectedAdvertising: 1,
	
	    /**
	     * The Device is disconnected and no longer advertising - the device also returns to this state after a
	     * successful connection has been closed
	     */
	    DisconnectedNotAdvertising: 2,
	
	    /**
	     * A connection attempt is in progress
	     */
	    Connecting: 3,
	
	    /**
	     * Connected and interrogating Device for required services
	     */
	    Interrogating: 4,
	
	    /**
	     * Connected and interrogation complete - device is ready for use
	     */
	    InterrogationFinished: 5
	};
	
	/**
	 * @type {object} DeviceCategoryEnum specifies the category of this device
	 * @property {number} DeviceCategoryWeDo - WeDo device
	 * @property {number} DeviceCategoryDuplo - Duplo device
	 * @property {number} DeviceCategorySystem - System device
	 * @property {number} DeviceCategoryTechnic - Technic device
	 * @property {number} DeviceCategoryMindStorms - Mindstorms device
	 * @property {number} DeviceCategoryUnknown - Unknown device
	 */
	var DeviceCategoryEnum = exports.DeviceCategoryEnum = {
	    /**
	     * WeDo
	     */
	    DeviceCategoryWeDo: 0,
	
	    /**
	     * Duplo
	     */
	    DeviceCategoryDuplo: 1,
	
	    /**
	     * System
	     */
	    DeviceCategorySystem: 2,
	
	    /**
	     * Technic
	     */
	    DeviceCategoryTechnic: 3,
	
	    /**
	     * MINDSTORMS
	     */
	    DeviceCategoryMindStorms: 4,
	
	    /**
	     * Unknown
	     */
	    DeviceCategoryUnknown: 5,
	
	    /**
	     * Helper for getting the enum  - if the value is not one of the supported values - DeviceCategoryUnknown is
	     * returned
	     * @param {number} value
	     * @return {number}
	     */
	    fromInteger: function fromInteger(value) {
	        switch (parseInt(value)) {
	            case 0:
	                return this.DeviceCategoryWeDo;
	            case 1:
	                return this.DeviceCategoryDuplo;
	            case 2:
	                return this.DeviceCategorySystem;
	            case 3:
	                return this.DeviceCategoryTechnic;
	            case 4:
	                return this.DeviceCategoryMindStorms;
	            case 5:
	            default:
	                return this.DeviceCategoryUnknown;
	        }
	    }
	};
	
	/**
	 * @type {object} The Function a Device will support.
	 * @property {number} DeviceFunctionCentralMode - Central Mode
	 * @property {number} DeviceFunctionPeripheralMode - Peripheral Mode
	 * @property {number} DeviceFunctionIOPorts - Device IO Ports mode
	 * @property {number} DeviceFunctionActsAsRemoteController - Device acts as a remocte controller
	 * @property {number} DeviceFunctionUnknown - Unknown
	 */
	var DeviceFunctionEnum = exports.DeviceFunctionEnum = {
	    /**
	     * Central Mode
	     */
	    DeviceFunctionCentralMode: 0,
	
	    /**
	     * Peripheral Mode
	     */
	    DeviceFunctionPeripheralMode: 1,
	
	    /**
	     * Device IO Ports mode
	     */
	    DeviceFunctionIOPorts: 2,
	
	    /**
	     * Device acts as a remocte controller
	     */
	    DeviceFunctionActsAsRemoteController: 3,
	
	    /**
	     * Unknown
	     */
	    DeviceFunctionUnknown: 4,
	
	    /**
	     * Helper for getting the enum  - if the value is not one of the supported values - DeviceFunctionUnknown is
	     * returned
	     * @param {number} value
	     * @return {number}
	     */
	    fromInteger: function fromInteger(value) {
	        switch (parseInt(value)) {
	            case 0:
	                return this.DeviceFunctionCentralMode;
	            case 1:
	                return this.DeviceFunctionPeripheralMode;
	            case 2:
	                return this.DeviceFunctionIOPorts;
	            case 3:
	                return this.DeviceFunctionActsAsRemoteController;
	            case 4:
	            default:
	                return this.DeviceFunctionUnknown;
	        }
	    }
	};
	
	/**
	 * This class can be used to offload the main thread and execute the callbacks on a different thread (currently
	 * however all the callbacks are simply postponed slightly using setTimeout(callback, timeInMillis).
	 *
	 * As a user of the SDK you are not supposed to use this class directly, instead you should use the
	 * registerCallbackListener and unregisterCallbackListener methods of the {@link LegoDeviceImpl} class
	 *
	 * Created by frj on 18/02/16.
	 */
	
	var DeviceCallbackHelper = exports.DeviceCallbackHelper = function () {
	
	    /**
	     *
	     * @param {string} legoDeviceAddress
	     * @param {LegoDeviceManagerImpl} legoDeviceManager
	     */
	    function DeviceCallbackHelper(legoDeviceAddress, legoDeviceManager) {
	        (0, _classCallCheck3.default)(this, DeviceCallbackHelper);
	
	        this._legoDeviceAddress = legoDeviceAddress;
	        this._legoDeviceManager = legoDeviceManager;
	        if (_LDSDKLogger2.default.isDebugEnabled()) {
	            _LDSDKLogger2.default.warn('Creating new ' + this.constructor.name + ' for device address ' + legoDeviceAddress + ' ::' + ' Initializing to empty list of listeners');
	        }
	        this.callbackListeners = new _map2.default();
	
	        var requiredCallbackFunctions = [];
	        requiredCallbackFunctions.push('didUpdateDeviceInfo');
	        requiredCallbackFunctions.push('didChangeButtonState');
	        requiredCallbackFunctions.push('didUpdateLowVoltageState');
	        requiredCallbackFunctions.push('didUpdateBatteryLevel');
	        requiredCallbackFunctions.push('didChangeNameFrom');
	        requiredCallbackFunctions.push('didFailToAddServiceWithError');
	        requiredCallbackFunctions.push('didRemoveService');
	        requiredCallbackFunctions.push('didAddService');
	
	        this.requiredCallbackFunctions = requiredCallbackFunctions;
	    }
	
	    (0, _createClass3.default)(DeviceCallbackHelper, [{
	        key: 'registerCallbackListener',
	
	
	        /**
	         * Registers a callback
	         * @param callback
	         * @returns {string} A unique callback id that can be used to unregister the callback later.s
	         */
	        value: function registerCallbackListener(callback) {
	            if (!callback || callback === null) {
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('Cannot register undefined or null as callbacks');
	                }
	                return null;
	            }
	            this.checkCallbackListener(callback);
	
	            var callbackId = _IdHelper2.default.generateID();
	            while (this.callbackListeners.has(callbackId)) {
	                // in case the map already has a key === callbackId we generate a new one
	                callbackId = _IdHelper2.default.generateID();
	            }
	            this.callbackListeners.set(callbackId, callback);
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('Registered listener of type ' + callback.constructor.name + ' (Id: ' + callbackId + ') with ' + this.constructor.name + ' :: Total listeners registered: ' + this.callbackListeners.size);
	            }
	            return callbackId;
	        }
	
	        /**
	         *  Unregisters a callback
	         *
	         * @param callbackId - A unique callback id that was returned when registering the listener.
	         * @returns {boolean} - Returns true if a callback existed with that id, or false if no callback was found with
	         * that id.
	         */
	
	    }, {
	        key: 'unregisterCallbackListener',
	        value: function unregisterCallbackListener(callbackId) {
	            var deleted = this.callbackListeners.delete(callbackId);
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('Unregistered listener with id ' + callbackId + ' from ' + this.constructor.name + ' :: Total listeners registered: ' + this.callbackListeners.size);
	            }
	            return deleted;
	        }
	    }, {
	        key: 'performDidUpdateDeviceInfoCallback',
	        value: function performDidUpdateDeviceInfoCallback(device, deviceInfo, error) {
	            var _this = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                setTimeout(function () {
	                    if (_this.callbackListeners.size === 0) {
	                        if (_this.legoBluetoothDevice.cachedListener && _this.legoBluetoothDevice.cachedListener !== null) {
	                            _this.registerCallbackListener(_this.legoBluetoothDevice.cachedListener);
	                        }
	
	                        if (_LDSDKLogger2.default.isDebugEnabled()) {
	                            _LDSDKLogger2.default.debug(_this.constructor.name + '.performDidUpdateDeviceInfoCallback :: No callback' + ' listeners' + ' found - unable to' + ' call didUpdateDeviceInfo function');
	                        }
	                    }
	                    _this.callbackListeners.forEach(function (callbackListener, key) {
	                        if (callbackListener !== null && typeof callbackListener.didUpdateDeviceInfo === 'function') {
	                            callbackListener.didUpdateDeviceInfo(device.getSimpleDevice(), device.getSimpleDeviceInfo(), error);
	                        } else {
	                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                _LDSDKLogger2.default.debug('Callback listener does not have a didUpdateDeviceInfo function -' + ' unable to' + ' call back');
	                            }
	                        }
	                    });
	                    return resolve();
	                }, 0);
	            });
	        }
	    }, {
	        key: 'performDidChangeButtonStateCallback',
	        value: function performDidChangeButtonStateCallback(device, buttonPressed) {
	            var _this2 = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                setTimeout(function () {
	                    if (_this2.callbackListeners.size === 0) {
	                        if (_this2.legoBluetoothDevice.cachedListener && _this2.legoBluetoothDevice.cachedListener !== null) {
	                            _this2.registerCallbackListener(_this2.legoBluetoothDevice.cachedListener);
	                        }
	
	                        if (_LDSDKLogger2.default.isDebugEnabled()) {
	                            _LDSDKLogger2.default.debug(_this2.constructor.name + '.performDidChangeButtonStateCallback :: No callback listeners found - unable to' + ' call didChangeButtonState function');
	                        }
	                    }
	
	                    _this2.callbackListeners.forEach(function (callbackListener, key) {
	                        if (callbackListener !== null && typeof callbackListener.didChangeButtonState === 'function') {
	                            callbackListener.didChangeButtonState(device.getSimpleDevice(), buttonPressed);
	                        } else {
	                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                _LDSDKLogger2.default.debug('Callback listener does not have a didChangeButtonState function - unable' + ' to' + ' call back');
	                            }
	                        }
	                    });
	                    return resolve();
	                }, 0);
	            });
	        }
	    }, {
	        key: 'performDidUpdateLowVoltageStateCallback',
	        value: function performDidUpdateLowVoltageStateCallback(device, lowVoltage) {
	            var _this3 = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                setTimeout(function () {
	                    if (_this3.callbackListeners.size === 0) {
	                        if (_this3.legoBluetoothDevice.cachedListener && _this3.legoBluetoothDevice.cachedListener !== null) {
	                            _this3.registerCallbackListener(_this3.legoBluetoothDevice.cachedListener);
	                        }
	
	                        if (_LDSDKLogger2.default.isDebugEnabled()) {
	                            _LDSDKLogger2.default.debug(_this3.constructor.name + '.performDidUpdateLowVoltageStateCallback :: No callback listeners found - unable to' + ' call didUpdateLowVoltageState function');
	                        }
	                    }
	
	                    _this3.callbackListeners.forEach(function (callbackListener, key) {
	                        if (callbackListener !== null && typeof callbackListener.didUpdateLowVoltageState === 'function') {
	                            callbackListener.didUpdateLowVoltageState(device.getSimpleDevice(), lowVoltage);
	                        } else {
	                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                _LDSDKLogger2.default.debug('Callback listener does not have a didUpdateLowVoltageState function -' + ' unable to' + ' call back');
	                            }
	                        }
	                    });
	                    return resolve();
	                }, 0);
	            });
	        }
	    }, {
	        key: 'performDidUpdateBatteryLevelCallback',
	        value: function performDidUpdateBatteryLevelCallback(device, batteryLevel) {
	            var _this4 = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                setTimeout(function () {
	                    if (_this4.callbackListeners.size === 0) {
	                        if (_this4.legoBluetoothDevice.cachedListener && _this4.legoBluetoothDevice.cachedListener !== null) {
	                            _this4.registerCallbackListener(_this4.legoBluetoothDevice.cachedListener);
	                        }
	
	                        if (_LDSDKLogger2.default.isDebugEnabled()) {
	                            _LDSDKLogger2.default.debug(_this4.constructor.name + '.performDidUpdateBatteryLevelCallback :: No callback listeners found - unable to' + ' call didUpdateBatteryLevel function');
	                        }
	                    }
	
	                    _this4.callbackListeners.forEach(function (callbackListener, key) {
	                        if (callbackListener !== null && typeof callbackListener.didUpdateBatteryLevel === 'function') {
	                            callbackListener.didUpdateBatteryLevel(device.getSimpleDevice(), batteryLevel);
	                        } else {
	                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                _LDSDKLogger2.default.debug('Callback listener of type ', callbackListener.constructor.name, ' does' + ' not' + ' have a didUpdateBatteryLevel function - unable to call back');
	                            }
	                        }
	                    });
	                    return resolve();
	                }, 0);
	            });
	        }
	    }, {
	        key: 'performDidChangeNameCallback',
	        value: function performDidChangeNameCallback(device, oldName, newName) {
	            var _this5 = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                setTimeout(function () {
	                    if (_this5.callbackListeners.size === 0) {
	                        if (_this5.legoBluetoothDevice.cachedListener && _this5.legoBluetoothDevice.cachedListener !== null) {
	                            _this5.registerCallbackListener(_this5.legoBluetoothDevice.cachedListener);
	                        }
	
	                        if (_LDSDKLogger2.default.isDebugEnabled()) {
	                            _LDSDKLogger2.default.debug(_this5.constructor.name + '.performDidChangeNameCallback :: No callback listeners found - unable to' + ' call didChangeNameFrom function');
	                        }
	                    }
	
	                    _this5.callbackListeners.forEach(function (callbackListener, key) {
	                        if (callbackListener !== null && typeof callbackListener.didChangeNameFrom === 'function') {
	                            if (device && device.getSimpleDevice) {
	                                callbackListener.didChangeNameFrom(device.getSimpleDevice(), oldName, newName);
	                            } else {
	                                _LDSDKLogger2.default.warn('performDidChangeNameCallback - device has no getSimpleDevice function - device: ' + (0, _stringify2.default)(device) + ', oldName: ' + oldName + ', newName: ' + newName);
	                                callbackListener.didChangeNameFrom(device, oldName, newName);
	                            }
	                        } else {
	                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                _LDSDKLogger2.default.debug('Callback listener of type ', callbackListener.constructor.name, ' does not have a didChangeNameFrom function - unable to' + ' call back');
	                            }
	                        }
	                    });
	                    return resolve();
	                }, 0);
	            });
	        }
	    }, {
	        key: 'performDidFailToAddServiceWithErrorCallback',
	        value: function performDidFailToAddServiceWithErrorCallback(device, error) {
	            var _this6 = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                setTimeout(function () {
	                    if (_this6.callbackListeners.size === 0) {
	                        if (_this6.legoBluetoothDevice.cachedListener && _this6.legoBluetoothDevice.cachedListener !== null) {
	                            _this6.registerCallbackListener(_this6.legoBluetoothDevice.cachedListener);
	                        }
	
	                        if (_LDSDKLogger2.default.isDebugEnabled()) {
	                            _LDSDKLogger2.default.debug(_this6.constructor.name + '.performDidFailToAddServiceWithErrorCallback :: No callback listeners found - unable to' + ' call didFailToAddServiceWithError function');
	                        }
	                    }
	                    _this6.callbackListeners.forEach(function (callbackListener, key) {
	                        if (callbackListener !== null && typeof callbackListener.didFailToAddServiceWithError === 'function') {
	                            callbackListener.didFailToAddServiceWithError(device.getSimpleDevice(), error);
	                        } else {
	                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                _LDSDKLogger2.default.debug('Callback listener of type ', callbackListener.constructor.name, ' does not have a didFailToAddServiceWithError function - unable to' + ' call back');
	                            }
	                        }
	                    });
	                    return resolve();
	                }, 0);
	            });
	        }
	    }, {
	        key: 'performDidRemoveServiceCallback',
	        value: function performDidRemoveServiceCallback(device, service) {
	            var _this7 = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                setTimeout(function () {
	                    if (_this7.callbackListeners.size === 0) {
	                        if (_this7.legoBluetoothDevice.cachedListener && _this7.legoBluetoothDevice.cachedListener !== null) {
	                            _this7.registerCallbackListener(_this7.legoBluetoothDevice.cachedListener);
	                        }
	
	                        if (_LDSDKLogger2.default.isDebugEnabled()) {
	                            _LDSDKLogger2.default.debug(_this7.constructor.name + '.performDidRemoveServiceCallback :: No callback listeners found - unable to' + ' call didRemoveService function');
	                        }
	                    }
	                    var simpleDevice = device.getSimpleDevice();
	                    var simpleService = service.getSimpleService();
	                    _this7.callbackListeners.forEach(function (callbackListener, key) {
	                        if (callbackListener !== null && typeof callbackListener.didRemoveService === 'function') {
	                            callbackListener.didRemoveService(simpleDevice, simpleService);
	                        } else {
	                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                _LDSDKLogger2.default.debug('Callback listener of type ', callbackListener.constructor.name, ' does not have a didRemoveService function - unable to' + ' call back');
	                            }
	                        }
	                    });
	                    return resolve();
	                }, 0);
	            });
	        }
	    }, {
	        key: 'performDidAddServiceCallback',
	        value: function performDidAddServiceCallback(device, service) {
	            var _this8 = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                setTimeout(function () {
	                    if (_this8.callbackListeners.size === 0) {
	                        if (_LDSDKLogger2.default.isInfoEnabled()) {
	                            _LDSDKLogger2.default.info('performDidAddServiceCallback - no listeners found - adding cachedListener:' + ' ' + _this8.legoBluetoothDevice.cachedListener);
	                        }
	                        if (_this8.legoBluetoothDevice.cachedListener && _this8.legoBluetoothDevice.cachedListener !== null) {
	                            _this8.registerCallbackListener(_this8.legoBluetoothDevice.cachedListener);
	                        }
	                    }
	                    var simpleDevice = device.getSimpleDevice();
	                    var simpleService = service.getSimpleService();
	                    _this8.callbackListeners.forEach(function (callbackListener, key) {
	                        if (callbackListener !== null && typeof callbackListener.didAddService === 'function') {
	                            if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                _LDSDKLogger2.default.debug('performDidAddServiceCallback :: calling back didAddService ' + service.getServiceName() + ' [' + service.getConnectInfo().toString() + '] for device: ' + device.getName());
	                            }
	                            callbackListener.didAddService(simpleDevice, simpleService);
	                        } else {
	                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                _LDSDKLogger2.default.debug('Callback listener of type ', callbackListener.constructor.name, ' does not have a didAddService function - unable to call back');
	                            }
	                        }
	                    });
	                    return resolve();
	                }, 0);
	            });
	        }
	    }, {
	        key: 'checkCallbackListener',
	        value: function checkCallbackListener(callbackListener) {
	            if (callbackListener === null || callbackListener === undefined) {
	                _LDSDKLogger2.default.warn('Attempt to add undefined callback listener to ' + this.constructor.name + ' ignored');
	                return;
	            }
	
	            for (var i = 0; i < this.requiredCallbackFunctions.length; i++) {
	                var requiredFuncName = this.requiredCallbackFunctions[i];
	                var requiredFunc = callbackListener[requiredFuncName];
	                if (typeof requiredFunc !== 'function') {
	                    _LDSDKLogger2.default.warn('The added callbacklistener of type ' + callbackListener.constructor.name + ' does not have an implementation of the required callback method ' + requiredFuncName);
	                }
	            }
	        }
	    }, {
	        key: 'legoDeviceManager',
	        get: function get() {
	            return this._legoDeviceManager;
	        }
	    }, {
	        key: 'legoBluetoothDevice',
	        get: function get() {
	            return this.legoDeviceManager.getDevice(this._legoDeviceAddress, false);
	        }
	    }]);
	    return DeviceCallbackHelper;
	}();
	
	var LegoDeviceImpl = function () {
	    function LegoDeviceImpl(legoDeviceManager) {
	        (0, _classCallCheck3.default)(this, LegoDeviceImpl);
	
	        this.instanceId = _IdHelper2.default.generateID();
	        this._legoDeviceManager = legoDeviceManager;
	
	        this.connectState = StateEnum.DisconnectedNotAdvertising;
	        this.deviceId = LegoDeviceImpl.UNDEFINED_DEVICE_ID;
	        this.deviceName = '';
	        this.buttonPressed = false;
	        this._batteryLevel = 0;
	        this.deviceInfo = new _DeviceInfo2.default();
	
	        this.lowVoltage = false;
	        this.category = DeviceCategoryEnum.DeviceCategoryUnknown;
	        this.supportedFunctions = DeviceFunctionEnum.DeviceFunctionUnknown;
	        this.lastConnectedNetworkId = -1;
	    }
	
	    (0, _createClass3.default)(LegoDeviceImpl, [{
	        key: 'getServices',
	        value: function getServices() {
	            return this.services;
	        }
	    }, {
	        key: 'getInternalServices',
	        value: function getInternalServices() {
	            return this.getFilteredServices(true);
	        }
	    }, {
	        key: 'getExternalServices',
	        value: function getExternalServices() {
	            return this.getFilteredServices(false);
	        }
	
	        /**
	         *
	         * @return {number}
	         */
	
	    }, {
	        key: 'getConnectState',
	        value: function getConnectState() {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.getConnectState();
	                }
	            }
	
	            return this.connectState;
	        }
	
	        /**
	         *
	         * @return {string} - The mac address for the device
	         */
	
	    }, {
	        key: 'getDeviceId',
	        value: function getDeviceId() {
	            return this.deviceId;
	        }
	
	        /**
	         *
	         * @return {string} - The name of the device
	         */
	
	    }, {
	        key: 'getName',
	        value: function getName() {
	            return this.deviceName;
	        }
	
	        /**
	         *
	         * @return {boolean} - True means pressed, false is not pressed
	         */
	
	    }, {
	        key: 'isButtonPressed',
	        value: function isButtonPressed() {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.isButtonPressed();
	                }
	            }
	
	            return this.buttonPressed;
	        }
	
	        /**
	         *
	         * @return {number} - Battery level in percent (0-100)
	         */
	
	    }, {
	        key: 'getBatteryLevel',
	        value: function getBatteryLevel() {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.getBatteryLevel();
	                }
	            }
	
	            return this.batteryLevel;
	        }
	
	        /**
	         *
	         * @return {DeviceInfo}
	         */
	
	    }, {
	        key: 'getDeviceInfo',
	        value: function getDeviceInfo() {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.getDeviceInfo();
	                }
	            }
	
	            return this.deviceInfo;
	        }
	    }, {
	        key: 'registerCallbackListener',
	        value: function registerCallbackListener(listener) {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.registerCallbackListener(listener);
	                }
	            }
	
	            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                _LDSDKLogger2.default.info('Registering ' + this.callbackHelper.constructor.name + ' listener of type: ' + listener.constructor.name + ' - keeping reference as cachedListener');
	            }
	            this.cachedListener = listener;
	            return this.callbackHelper.registerCallbackListener(listener);
	        }
	    }, {
	        key: 'unregisterCallbackListener',
	        value: function unregisterCallbackListener(listenerId) {
	            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                _LDSDKLogger2.default.info('Unregistering ' + this.callbackHelper.constructor.name + ' with listenerId: ' + listenerId);
	            }
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.callbackHelper.unregisterCallbackListener(listenerId);
	                }
	            }
	
	            return this.callbackHelper.unregisterCallbackListener(listenerId);
	        }
	    }, {
	        key: 'getFilteredServices',
	        value: function getFilteredServices(internalOnly) {
	            var filteredServices = [];
	
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                for (var _iterator = (0, _getIterator3.default)(this.services.values()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var service = _step.value;
	
	                    if (service.isInternalService()) {
	                        if (internalOnly) {
	                            filteredServices.push(service);
	                        }
	                    } else {
	                        if (!internalOnly) {
	                            filteredServices.push(service);
	                        }
	                    }
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	
	            return filteredServices;
	        }
	
	        /**
	         * Get a simple representation of a device
	         * @return {{deviceId: string, deviceName: string, isButtonPressed: boolean, batteryLevel: number, isLowVoltage: boolean, connectState: number, category: number, supportedFunctions: number, lastConnectedNetworkId: number, instanceId: string}}
	         */
	
	    }, {
	        key: 'getSimpleDevice',
	        value: function getSimpleDevice() {
	            var simpleDeviceObj = {
	                'deviceId': this.getDeviceId(),
	                'deviceName': this.getName(),
	                'isButtonPressed': this.isButtonPressed(),
	                'batteryLevel': this.getBatteryLevel(),
	                'isLowVoltage': this.isLowVoltage(),
	                'connectState': this.getConnectState(),
	                'category': this.getCategory(),
	                'supportedFunctions': this.getSupportedFunctions(),
	                'lastConnectedNetworkId': this.getLastConnectedNetworkId(),
	                'instanceId': this.instanceId
	            };
	            var simpleDeviceInfo = this.getSimpleDeviceInfo();
	            if (simpleDeviceInfo !== null) {
	                simpleDeviceObj['deviceInfo'] = simpleDeviceInfo;
	            }
	            return simpleDeviceObj;
	        }
	
	        /**
	         * Get simple device info representation or null if no device info available
	         * @return {{firmwareRevision: string, hardwareRevision: string, softwareRevision: string, manufacturerName: string}|null}
	         */
	
	    }, {
	        key: 'getSimpleDeviceInfo',
	        value: function getSimpleDeviceInfo() {
	            if (this.getDeviceInfo() && this.getDeviceInfo() !== null) {
	                return this.getDeviceInfo().getSimpleDeviceInfo();
	            }
	            return null;
	        }
	    }, {
	        key: 'services',
	        get: function get() {
	            return _LegoServiceFactory2.default.getServiceInstances(this.getDeviceId());
	        }
	    }, {
	        key: 'legoDeviceManager',
	        get: function get() {
	            return this._legoDeviceManager;
	            // return LegoDeviceManagerImpl.getInstance();
	        }
	    }, {
	        key: 'callbackHelper',
	        get: function get() {
	            var deviceCallbackHelper = this.legoDeviceManager.getDeviceCallbackHelper(this.getAddress());
	            if (deviceCallbackHelper === null) {
	                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                    _LDSDKLogger2.default.info('Creating a new device callback helper for device with address: ' + this.getAddress());
	                }
	                deviceCallbackHelper = new DeviceCallbackHelper(this.getAddress(), this.legoDeviceManager);
	                this.legoDeviceManager.setDeviceCallbackHelper(this.getAddress(), deviceCallbackHelper);
	            } else {
	                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                    _LDSDKLogger2.default.debug('Found cached device callback helper with ' + deviceCallbackHelper.callbackListeners.size + ' callback listeners');
	                }
	            }
	            return deviceCallbackHelper;
	        }
	    }, {
	        key: 'batteryLevel',
	        get: function get() {
	            return this._batteryLevel;
	        },
	        set: function set(value) {
	            this._batteryLevel = Math.max(0, Math.min(100, value));
	        }
	    }]);
	    return LegoDeviceImpl;
	}();
	
	LegoDeviceImpl.UNDEFINED_DEVICE_ID = 'Undefined';
	exports.default = LegoDeviceImpl;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @ignore Internal use only
	 */
	var IdHelper = function () {
	    function IdHelper() {
	        (0, _classCallCheck3.default)(this, IdHelper);
	    }
	
	    (0, _createClass3.default)(IdHelper, null, [{
	        key: 'generateID',
	        value: function generateID() {
	            var timestamp = new Date().getTime();
	            var id = 'xxxxxxxxxxxx'.replace(/[x]/g, function (c) {
	                var r = (timestamp + Math.random() * 16) % 16 | 0;
	                timestamp = Math.floor(timestamp / 16);
	                return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);
	            });
	            return id;
	        }
	    }]);
	    return IdHelper;
	}();
	
	exports.default = IdHelper;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(64);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.LegoDeviceManagerConfig = exports.DeviceManagerCallbackHelper = undefined;
	
	var _regenerator = __webpack_require__(14);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _getIterator2 = __webpack_require__(33);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _asyncToGenerator2 = __webpack_require__(13);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _map = __webpack_require__(9);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _LegoBluetoothDeviceManagerImpl = __webpack_require__(84);
	
	var _LegoBluetoothDeviceManagerImpl2 = _interopRequireDefault(_LegoBluetoothDeviceManagerImpl);
	
	var _LegoBluetoothDeviceImpl = __webpack_require__(59);
	
	var _LegoBluetoothDeviceImpl2 = _interopRequireDefault(_LegoBluetoothDeviceImpl);
	
	var _LegoDeviceManager = __webpack_require__(85);
	
	var _LegoDeviceManager2 = _interopRequireDefault(_LegoDeviceManager);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	var _SimpleList = __webpack_require__(45);
	
	var _SimpleList2 = _interopRequireDefault(_SimpleList);
	
	var _ChromeOsBluetoothAdapterWrapper = __webpack_require__(83);
	
	var _ChromeOsBluetoothAdapterWrapper2 = _interopRequireDefault(_ChromeOsBluetoothAdapterWrapper);
	
	var _IdHelper = __webpack_require__(28);
	
	var _IdHelper2 = _interopRequireDefault(_IdHelper);
	
	var _LegoDeviceImpl = __webpack_require__(27);
	
	var _StringUtils = __webpack_require__(21);
	
	var _StringUtils2 = _interopRequireDefault(_StringUtils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var DeviceManagerCallbackHelper = exports.DeviceManagerCallbackHelper = function () {
	    function DeviceManagerCallbackHelper() {
	        (0, _classCallCheck3.default)(this, DeviceManagerCallbackHelper);
	
	        this.counter = 0;
	        this.callbackListeners = new _map2.default();
	
	        var requiredCallbackFunctions = [];
	
	        // These calls are used while connecting
	        requiredCallbackFunctions.push('onWillStartConnectingToDevice');
	        requiredCallbackFunctions.push('onDidStartInterrogatingDevice');
	        requiredCallbackFunctions.push('onDidFinishInterrogatingDevice');
	        requiredCallbackFunctions.push('onDidDisconnectFromDevice');
	        requiredCallbackFunctions.push('onDidFailToConnectToDevice');
	
	        // These calls are used while scanning
	        requiredCallbackFunctions.push('onDeviceDisappeared');
	        requiredCallbackFunctions.push('onDeviceAppeared');
	
	        // TODO: Split the scanning and connecting calls into two separate implementations
	
	        this.requiredCallbackFunctions = requiredCallbackFunctions;
	    }
	
	    /**
	     * Registers a callback that while scanning can get calls on its onDeviceAppeared, and onDeviceDisappeared
	     * functions. And while connecting to a device the following functions can be called:
	     *
	     *
	     *
	     * @param callback
	     * @returns {string} A unique callback id that can be used to unregister the callback later.s
	     */
	
	
	    (0, _createClass3.default)(DeviceManagerCallbackHelper, [{
	        key: 'registerCallbackListener',
	        value: function registerCallbackListener(callback) {
	            this.checkCallbackListener(callback);
	
	            var callbackId = _IdHelper2.default.generateID();
	            while (this.callbackListeners.has(callbackId)) {
	                // in case the map already has a key === callbackId we generate a new one
	                callbackId = _IdHelper2.default.generateID();
	            }
	            this.callbackListeners.set(callbackId, callback);
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('Registered callbacklistener for ' + this.constructor.name + ' - Id: ' + callbackId + ' - callback name: ' + callback.constructor.name + ' - callbacklistener count: ' + this.callbackListeners.size);
	            }
	            return callbackId;
	        }
	
	        /**
	         *  Unregisters a callback
	         *
	         * @param callbackId - A unique callback id that was returned when registering the listener.
	         * @returns {boolean} - Returns true if a callback existed with that id, or false if no callback was found with
	         * that id.
	         */
	
	    }, {
	        key: 'unregisterCallbackListener',
	        value: function unregisterCallbackListener(callbackId) {
	            var result = this.callbackListeners.delete(callbackId);
	            if (_LDSDKLogger2.default.isTraceEnabled()) {
	                _LDSDKLogger2.default.trace('Unregistered callbacklistener for ' + this.constructor.name + ' - Id: ' + callbackId + ' - callbacklistener count: ' + this.callbackListeners.size);
	            }
	            return result;
	        }
	
	        /**
	         * @ignore
	         * <b>Not to be called directly by a client.</b>
	         *
	         * This function is used internally to notify the client listeners about device appeared events.
	         *
	         * @param legoDevice
	         */
	
	    }, {
	        key: 'performDeviceAppearedCallback',
	        value: function performDeviceAppearedCallback(legoDevice) {
	            var _this = this;
	
	            setTimeout(function () {
	                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                    _LDSDKLogger2.default.debug(_this.constructor.name + ' - Calling onDeviceAppeared on this.callbackListeners with length: ' + _this.callbackListeners.size);
	                }
	                var simpleDevice = legoDevice.getSimpleDevice();
	                _this.callbackListeners.forEach(function (callbackListener, key) {
	                    if (callbackListener !== null && typeof callbackListener.onDeviceAppeared === 'function') {
	                        callbackListener.onDeviceAppeared(simpleDevice);
	                    } else {
	                        if (_LDSDKLogger2.default.isDebugEnabled()) {
	                            _LDSDKLogger2.default.debug('Callback does not have a onDeviceAppeared function - unable to call back.' + ' Callback type: ', callbackListener.constructor.name);
	                        }
	                    }
	                });
	            }, 0);
	        }
	
	        /**
	         * @ignore
	         * <b>Not to be called directly by a client.</b>
	         *
	         * This function is used internally to notify the client listeners about device disappeared events.
	         *
	         * @param legoDevice
	         */
	
	    }, {
	        key: 'performDeviceDisappearedCallback',
	        value: function performDeviceDisappearedCallback(legoDevice) {
	            var _this2 = this;
	
	            setTimeout(function () {
	                if (_this2.callbackListeners.size === 0) {
	                    if (_LDSDKLogger2.default.isInfoEnabled()) {
	                        _LDSDKLogger2.default.info(_this2.constructor.name + '.performDeviceDisappearedCallback - ' + 'No listeners' + ' registered to call onDeviceDisappeared on');
	                    }
	                    return;
	                }
	                var simpleDevice = legoDevice.getSimpleDevice();
	                _this2.callbackListeners.forEach(function (callbackListener, key) {
	                    if (callbackListener !== null && typeof callbackListener.onDeviceDisappeared === 'function') {
	                        if (_LDSDKLogger2.default.isTraceEnabled()) {
	                            _LDSDKLogger2.default.trace(_this2.constructor.name + '.performDeviceDisappearedCallback calling' + ' onDeviceDisappeared on ' + callbackListener.constructor.name);
	                        }
	                        callbackListener.onDeviceDisappeared(simpleDevice);
	                    } else {
	                        if (_LDSDKLogger2.default.isDebugEnabled()) {
	                            _LDSDKLogger2.default.debug('Callback does not have a onDeviceDisappeared function - unable to call' + ' back');
	                        }
	                    }
	                });
	            }, 0);
	        }
	
	        /**
	         * @ignore
	         * <b>Not to be called directly by a client.</b>
	         *
	         * This function is used internally to notify the client listeners about the sdk starts connecting to a device events.
	         *
	         * @param legoDevice
	         */
	
	    }, {
	        key: 'performWillStartConnectingToDeviceCallback',
	        value: function performWillStartConnectingToDeviceCallback(legoDevice) {
	            var _this3 = this;
	
	            setTimeout(function () {
	                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                    _LDSDKLogger2.default.debug(_this3.constructor.name + ' - Calling onWillStartConnectingToDevice on this.callbackListeners with length: ' + _this3.callbackListeners.size);
	                }
	                var simpleDevice = legoDevice.getSimpleDevice();
	                _this3.callbackListeners.forEach(function (callbackListener, key) {
	                    if (callbackListener !== null && typeof callbackListener.onWillStartConnectingToDevice === 'function') {
	                        callbackListener.onWillStartConnectingToDevice(simpleDevice);
	                    } else {
	                        if (_LDSDKLogger2.default.isDebugEnabled()) {
	                            _LDSDKLogger2.default.debug('Callback does not have a onWillStartConnectingToDevice function - unable' + ' to call back');
	                        }
	                    }
	                });
	            }, 0);
	        }
	
	        /**
	         * @ignore
	         * <b>Not to be called directly by a client.</b>
	         *
	         * This function is used internally to notify the client listeners about the sdk starts interrogating a device for services
	         * and characteristics.
	         *
	         * @param legoDevice
	         */
	
	    }, {
	        key: 'performDidStartInterrogatingDevice',
	        value: function performDidStartInterrogatingDevice(legoDevice) {
	            var _this4 = this;
	
	            setTimeout((0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
	                var simpleDevice, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, callbackListener;
	
	                return _regenerator2.default.wrap(function _callee$(_context) {
	                    while (1) {
	                        switch (_context.prev = _context.next) {
	                            case 0:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug(_this4.constructor.name + ' - Calling onDidStartInterrogatingDevice on this.callbackListeners with length: ' + _this4.callbackListeners.size);
	                                }
	                                simpleDevice = legoDevice.getSimpleDevice();
	                                _iteratorNormalCompletion = true;
	                                _didIteratorError = false;
	                                _iteratorError = undefined;
	                                _context.prev = 5;
	                                _iterator = (0, _getIterator3.default)(_this4.callbackListeners.values());
	
	                            case 7:
	                                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
	                                    _context.next = 18;
	                                    break;
	                                }
	
	                                callbackListener = _step.value;
	
	                                if (!(callbackListener !== null && typeof callbackListener.onDidStartInterrogatingDevice === 'function')) {
	                                    _context.next = 14;
	                                    break;
	                                }
	
	                                _context.next = 12;
	                                return callbackListener.onDidStartInterrogatingDevice(simpleDevice);
	
	                            case 12:
	                                _context.next = 15;
	                                break;
	
	                            case 14:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('Callback does not have a onDidStartInterrogatingDevice function - unable' + ' to call back');
	                                }
	
	                            case 15:
	                                _iteratorNormalCompletion = true;
	                                _context.next = 7;
	                                break;
	
	                            case 18:
	                                _context.next = 24;
	                                break;
	
	                            case 20:
	                                _context.prev = 20;
	                                _context.t0 = _context['catch'](5);
	                                _didIteratorError = true;
	                                _iteratorError = _context.t0;
	
	                            case 24:
	                                _context.prev = 24;
	                                _context.prev = 25;
	
	                                if (!_iteratorNormalCompletion && _iterator.return) {
	                                    _iterator.return();
	                                }
	
	                            case 27:
	                                _context.prev = 27;
	
	                                if (!_didIteratorError) {
	                                    _context.next = 30;
	                                    break;
	                                }
	
	                                throw _iteratorError;
	
	                            case 30:
	                                return _context.finish(27);
	
	                            case 31:
	                                return _context.finish(24);
	
	                            case 32:
	                            case 'end':
	                                return _context.stop();
	                        }
	                    }
	                }, _callee, _this4, [[5, 20, 24, 32], [25,, 27, 31]]);
	            })), 0);
	        }
	
	        /**
	         * @ignore
	         * <b>Not to be called directly by a client.</b>
	         *
	         * This function is used internally to notify the client listeners that the sdk has completed interrogating the device for
	         * services and characteristics - and the device is now ready for use.
	         *
	         * @param legoDevice
	         */
	
	    }, {
	        key: 'performDidFinishInterrogratingDevice',
	        value: function performDidFinishInterrogratingDevice(legoDevice) {
	            var _this5 = this;
	
	            setTimeout(function () {
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug(_this5.constructor.name + ' - Calling onDidFinishInterrogatingDevice on this.callbackListeners with length: ' + _this5.callbackListeners.size);
	                }
	                var simpleDevice = legoDevice.getSimpleDevice();
	                _this5.callbackListeners.forEach(function (callbackListener, key) {
	                    if (callbackListener !== null && typeof callbackListener.onDidFinishInterrogatingDevice === 'function') {
	                        if (_LDSDKLogger2.default.isTraceEnabled()) {
	                            _LDSDKLogger2.default.debug(_this5.constructor.name + ' - Calling' + ' callbackListener.onDidFinishInterrogatingDevice' + legoDevice.getName() + ' [' + legoDevice.getAddress() + ']');
	                        }
	                        callbackListener.onDidFinishInterrogatingDevice(simpleDevice);
	                    } else {
	                        if (_LDSDKLogger2.default.isDebugEnabled()) {
	                            _LDSDKLogger2.default.debug('Callback does not have a onDidFinishInterrogatingDevice function - unable to' + ' call back');
	                        }
	                    }
	                });
	            }, 0);
	        }
	
	        /**
	         * @ignore
	         * <b>Not to be called directly by a client.</b>
	         *
	         * This function is used internally to notify the client listeners that the sdk has disconnected from the device.
	         *
	         * @param legoDevice
	         * @param {Boolean} autoReconnect
	         * @param {string} error
	         */
	
	    }, {
	        key: 'performDidDisconnectFromDevice',
	        value: function performDidDisconnectFromDevice(legoDevice, autoReconnect, error) {
	            var _this6 = this;
	
	            setTimeout(function () {
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug(_this6.constructor.name + ' - Calling onDidDisconnectFromDevice on this.callbackListeners with length: ' + _this6.callbackListeners.size);
	                }
	                var simpleDevice = legoDevice.getSimpleDevice();
	                _this6.callbackListeners.forEach(function (callbackListener, key) {
	                    if (callbackListener !== null && typeof callbackListener.onDidDisconnectFromDevice === 'function') {
	                        callbackListener.onDidDisconnectFromDevice(simpleDevice, autoReconnect, error);
	                    } else {
	                        if (_LDSDKLogger2.default.isDebugEnabled()) {
	                            _LDSDKLogger2.default.debug('Callback does not have a onDidDisconnectFromDevice function - unable to' + ' call back');
	                        }
	                    }
	                });
	            }, 0);
	        }
	
	        /**
	         * @ignore
	         * <b>Not to be called directly by a client.</b>
	         *
	         * This function is used internally to notify the client listeners that the sdk failed to connect to the device.
	         *
	         * @param legoDevice
	         * @param {Boolean} autoReconnect
	         * @param {string} error
	         */
	
	    }, {
	        key: 'performDidFailToConnectToDevice',
	        value: function performDidFailToConnectToDevice(legoDevice, autoReconnect, error) {
	            var _this7 = this;
	
	            setTimeout(function () {
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug(_this7.constructor.name + ' - Calling onDidFailToConnectToDevice on this.callbackListeners with length: ' + _this7.callbackListeners.size);
	                }
	                var simpleDevice = legoDevice.getSimpleDevice();
	                _this7.callbackListeners.forEach(function (callbackListener, key) {
	                    if (callbackListener !== null && typeof callbackListener.onDidFailToConnectToDevice === 'function') {
	                        callbackListener.onDidFailToConnectToDevice(simpleDevice, autoReconnect, error);
	                    } else {
	                        if (_LDSDKLogger2.default.isDebugEnabled()) {
	                            _LDSDKLogger2.default.debug('Callback does not have a onDidFailToConnectToDevice function - unable to' + ' call back');
	                        }
	                    }
	                });
	            }, 0);
	        }
	
	        /**
	         * @ignore
	         * <b>Not to be called directly by a client.</b>
	         *
	         * This function validates the supplied listener implements the functions expected by this class.
	         *
	         * @param callbackListener
	         */
	
	    }, {
	        key: 'checkCallbackListener',
	        value: function checkCallbackListener(callbackListener) {
	            if (callbackListener === null || callbackListener === undefined) {
	                _LDSDKLogger2.default.error('Attempt to add undefined callback listener to ' + this.constructor.name + ' ignored');
	                return;
	            }
	            for (var i = 0; i < this.requiredCallbackFunctions.length; i++) {
	                var requiredFuncName = this.requiredCallbackFunctions[i];
	                var requiredFunc = callbackListener[requiredFuncName];
	                if (typeof requiredFunc !== 'function') {
	                    if (_LDSDKLogger2.default.isWarnEnabled()) {
	                        _LDSDKLogger2.default.warn('The added callbacklistener of type ' + callbackListener.constructor.name + ' does not have an implementation of the required callback method ' + requiredFuncName);
	                    }
	                }
	            }
	        }
	    }]);
	    return DeviceManagerCallbackHelper;
	}();
	
	/**
	 * Configuration class for holding all the user adjustable settings in the SDK
	 */
	/**
	 * @ignore
	 * The functions in this class is used for firing the callbacks in relation to scanning for devices, and connecting to them.
	 *
	 * As a user of the SDK you are not supposed to use this class directly, instead you should use the
	 * registerCallbackListener and unregisterCallbackListener methods of the {@link LegoDeviceManagerImpl} class
	 *
	 * Created by frj on 18/02/16.
	 */
	
	
	var LegoDeviceManagerConfig = exports.LegoDeviceManagerConfig = function () {
	    function LegoDeviceManagerConfig() {
	        (0, _classCallCheck3.default)(this, LegoDeviceManagerConfig);
	        this._fireDeviceInfoUpdateOnTheOnDeviceEvents = false;
	        this._automaticReconnectOnConnectionLostEnabled = false;
	        this._startStopRepeatedScanning = false;
	        this._registerForBatteryLevelNotifications = false;
	        this._registerForCurrentNotifications = false;
	        this._registerForVoltageNotifications = false;
	        this._listenForConnectionsAllTheTime = false;
	        this._disconnectOnOperationFailedBLEError = false;
	        this._filterFallbackEnabled = false;
	        this._usePreviouslySeenCacheAsFallbackFilter = true;
	        this._connectRequestTimeoutInterval = _LegoDeviceManager2.default.DEFAULT_CONNECT_REQUEST_TIMEOUT;
	        this._startStopScanningInterval = _LegoBluetoothDeviceManagerImpl2.default.START_STOP_SCANNING_INTERVAL;
	        this._batteryPollingInterval = 15000;
	        this._disableAdvertisingWindowSizeMillis = 100;
	        this._updateAdvertisingDevicesIntervalMillis = _LegoBluetoothDeviceManagerImpl2.default.REFRESH_DEVICE_LIST_DEFAULT_INTERVAL;
	        this._handleUpdatedInputRetryDelay = 200;
	        this._synchronousOperationsQueuePollDelay = 0;
	        this._startCharacteristicNotificationsWhenConnectedRetryDelay = 500;
	        this._startCharacteristicNotificationsWhenConnectedRetryMax = 15;
	        this._lookupServicesWhenConnectedRetryDelay = 750;
	        this._lookupServicesWhenConnectedRetryMaxCount = _LegoBluetoothDeviceManagerImpl.BaseBluetoothGattCallback.MAX_RETRIES;
	        this._serviceCountComplete = 5;
	        this._waitForAddServicesBeforePollingMillis = 4000;
	    }
	
	    (0, _createClass3.default)(LegoDeviceManagerConfig, [{
	        key: 'shouldUpdateOnTheOnDeviceEvents',
	
	
	        /**
	         * Alternative function for checking the value of the fireDeviceInfoUpdateOnTheOnDeviceEvents setting
	         * @return {boolean}
	         */
	        value: function shouldUpdateOnTheOnDeviceEvents() {
	            return this.fireDeviceInfoUpdateOnTheOnDeviceEvents;
	        }
	
	        /**
	         * Alternative function for checking the value of the automaticReconnectOnConnectionLostEnabled setting
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'shouldAutomaticallyReconnectOnConnectionLost',
	        value: function shouldAutomaticallyReconnectOnConnectionLost() {
	            return this.automaticReconnectOnConnectionLostEnabled;
	        }
	
	        /**
	         * Alternative function for checking the value of the startStopRepeatedScanning setting
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'shouldStartStopRepeatedScanning',
	        value: function shouldStartStopRepeatedScanning() {
	            return this.startStopRepeatedScanning;
	        }
	
	        /**
	         * Alternative function for checking the value of the registerForCurrentNotifications setting
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'shouldRegisterForCurrentNotifications',
	        value: function shouldRegisterForCurrentNotifications() {
	            return this.registerForCurrentNotifications;
	        }
	
	        /**
	         * Alternative function for checking the value of the registerForVoltageNotifications setting
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'shouldRegisterForVoltageNotifications',
	        value: function shouldRegisterForVoltageNotifications() {
	            return this.registerForVoltageNotifications;
	        }
	
	        /**
	         * Get the value for the connectRequestTimeoutInterval setting.
	         * @return {number}. The interval in milliseconds before deciding that the connect attempt failed.
	         */
	
	    }, {
	        key: 'listenForConnectionsAllTheTime',
	
	
	        /**
	         * Get the value of the listenForConnectionsAllTheTime setting
	         * @return {boolean}
	         */
	        get: function get() {
	            return this._listenForConnectionsAllTheTime;
	        }
	
	        /**
	         * Set the value of the listenForConnectionsAllTheTime setting
	         * @param {boolean} value - The value to set
	         */
	        ,
	        set: function set(value) {
	            this._listenForConnectionsAllTheTime = value === true;
	        }
	
	        /**
	         * Get the value of the fireDeviceInfoUpdateOnTheOnDeviceEvents config setting
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'fireDeviceInfoUpdateOnTheOnDeviceEvents',
	        get: function get() {
	            return this._fireDeviceInfoUpdateOnTheOnDeviceEvents;
	        }
	
	        /**
	         * Set the value of the fireDeviceInfoUpdateOnTheOnDeviceEvents config setting.
	         * The value is used in the onDevice* event handlers. If value=true then the DeviceInfoUpdated callback is called
	         * on all onDevice* events. If false the DeviceInfoUpdated is only called when the connection state changes.
	         * @param {boolean} value - The value to set
	         */
	        ,
	        set: function set(value) {
	            this._fireDeviceInfoUpdateOnTheOnDeviceEvents = value === true;
	        }
	
	        /**
	         * Get the value of the automaticReconnectOnConnectionLostEnabled config setting
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'automaticReconnectOnConnectionLostEnabled',
	        get: function get() {
	            return this._automaticReconnectOnConnectionLostEnabled;
	        }
	
	        /**
	         * Set the value of the automaticReconnectOnConnectionLostEnabled config setting.
	         * The value is used when a connected device loses connection and is still discoverable. In that case if
	         * value=true a reconnect will be attempted.  If value=false a manual call to connect is need for the device to
	         * be connected again.
	         * @param {boolean} value - The value to set
	         */
	        ,
	        set: function set(value) {
	            this._automaticReconnectOnConnectionLostEnabled = value === true;
	        }
	
	        /**
	         * Should the BLE wrapper automatically send a disconnect if an 'Operation failed' message is received
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'disconnectOnOperationFailedBLEError',
	        get: function get() {
	            return this._disconnectOnOperationFailedBLEError;
	        }
	
	        /**
	         * Set whether the BLE wrapper should automatically send a disconnect if an 'Operation failed' message is received
	         * @param {boolean} value - The value to set
	         */
	        ,
	        set: function set(value) {
	            this._disconnectOnOperationFailedBLEError = value === true;
	        }
	
	        /**
	         * Get the value of the startStopRepeatedScanning config setting.
	         * @return {boolean}. True means the setting is enabled, false if not enabled
	         */
	
	    }, {
	        key: 'startStopRepeatedScanning',
	        get: function get() {
	            return this._startStopRepeatedScanning;
	        }
	
	        /**
	         * Set the value of the startStopRepeatedScanning config setting.
	         * The value controls the strategy used while scanning for WeDo SmartHubs. On some Chromebooks the events do not
	         * appear immediately when a scan is running - and given the short time the hubs announce themselves we need to
	         * get the events as fast as possible. So in some scenarios starting and stopping discovery is more effective in
	         * discovering devices.
	         * @param {boolean} value - The value to set. True enables start/stop scanning, False disables it.
	         * @see startStopScanningInterval for controlling how often the scan is
	         */
	        ,
	        set: function set(value) {
	            this._startStopRepeatedScanning = value === true;
	        }
	
	        /**
	         * Get the value for the registerForCurrentNotifications setting.
	         * @return {boolean}. True means register for the current notifications, false to not register for the current
	         * notifications.
	         */
	
	    }, {
	        key: 'registerForCurrentNotifications',
	        get: function get() {
	            return this._registerForCurrentNotifications;
	        }
	
	        /**
	         * Set the value for the registerForCurrentNotifications setting.
	         * @param {boolean} value. True means register for the current notifications, false to not register for the current
	         * notifications.
	         */
	        ,
	        set: function set(value) {
	            this._registerForCurrentNotifications = value === true;
	        }
	
	        /**
	         * Get the value for the registerForVoltageNotifications setting.
	         * @return {boolean}. True means register for the voltage notifications, false to not register for the voltage
	         * notifications.
	         */
	
	    }, {
	        key: 'registerForVoltageNotifications',
	        get: function get() {
	            return this._registerForVoltageNotifications;
	        }
	
	        /**
	         * Set the value for the registerForVoltageNotifications setting.
	         * @param {boolean} value. True means register for the voltage notifications, false to not register for the voltage
	         * notifications.
	         */
	        ,
	        set: function set(value) {
	            this._registerForVoltageNotifications = value === true;
	        }
	
	        /**
	         * Get the value for the registerForBatteryLevelNotifications setting.
	         * @return {boolean}. True means register for the battery level notifications, false to not register for the battery
	         * level notifications.
	         */
	
	    }, {
	        key: 'registerForBatteryLevelNotifications',
	        get: function get() {
	            return this._registerForBatteryLevelNotifications;
	        }
	
	        /**
	         * Set the value for the registerForBatteryLevelNotifications setting.
	         * @param {boolean} value. True means register for the battery level notifications, false to not register for the battery
	         * level notifications.
	         */
	        ,
	        set: function set(value) {
	            this._registerForBatteryLevelNotifications = value === true;
	        }
	    }, {
	        key: 'connectRequestTimeoutInterval',
	        get: function get() {
	            return this._connectRequestTimeoutInterval;
	        }
	
	        /**
	         * Set the value for the connectRequestTimeoutInterval setting.
	         * @param {number} value. The interval in milliseconds before deciding that the connect attempt failed.
	         */
	        ,
	        set: function set(value) {
	            this._connectRequestTimeoutInterval = Math.max(0, value);
	        }
	
	        /**
	         * Get the value for the startStopScanningInterval setting.
	         * @return {number}. The interval in milliseconds to let scan start run before stopping the scan. NOTE: This
	         * setting only has effect if you also enable startStopScanning. @see
	         * LegoDeviceManagerConfig#startStopRepeatedScanning
	         */
	
	    }, {
	        key: 'startStopScanningInterval',
	        get: function get() {
	            return this._startStopScanningInterval;
	        }
	
	        /**
	         * Set the value for the startStopScanningInterval setting.
	         * @param {number} value. The interval in milliseconds to let scan start run before stopping the scan. NOTE: This
	         * setting only has effect if you also enable startStopScanning. @see
	         * LegoDeviceManagerConfig#startStopRepeatedScanning
	         */
	        ,
	        set: function set(value) {
	            this._startStopScanningInterval = Math.max(0, value);
	        }
	    }, {
	        key: 'disableAdvertisingWindowSizeMillis',
	        get: function get() {
	            return this._disableAdvertisingWindowSizeMillis;
	        },
	        set: function set(value) {
	            this._disableAdvertisingWindowSizeMillis = Math.max(20, value);
	        }
	
	        /**
	         * Get the value for the batteryPollingInterval setting.
	         * @return {number}. The time in milliseconds to wait before reading the battery level
	         */
	
	    }, {
	        key: 'batteryPollingInterval',
	        get: function get() {
	            return this._batteryPollingInterval;
	        }
	
	        /**
	         * Set the value for the batteryPollingInterval setting.
	         * @param {number} value. The time in milliseconds to wait before reading the battery level
	         */
	        ,
	        set: function set(value) {
	            this._batteryPollingInterval = Math.max(0, value);
	        }
	
	        /**
	         * Get the value for the handleUpdatedInputRetryDelay setting.
	         * @return {number}. The time in milliseconds to wait before retrying to handle the updated input
	         */
	
	    }, {
	        key: 'handleUpdatedInputRetryDelay',
	        get: function get() {
	            return this._handleUpdatedInputRetryDelay;
	        }
	
	        /**
	         * Set the value for the handleUpdatedInputRetryDelay setting.
	         * @param {number} value. The time in milliseconds to wait before retrying to handle the updated input
	         */
	        ,
	        set: function set(value) {
	            this._handleUpdatedInputRetryDelay = Math.max(0, value);
	        }
	
	        /**
	         * Get the value for the synchronousOperationsQueuePollDelay setting.
	         * @return {number}. The time in milliseconds to wait before polling the queue for items to process
	         */
	
	    }, {
	        key: 'synchronousOperationsQueuePollDelay',
	        get: function get() {
	            return this._synchronousOperationsQueuePollDelay;
	        }
	
	        /**
	         * Set the value for the synchronousOperationsQueuePollDelay setting.
	         * @param {number} value. The time in milliseconds to wait before polling the queue for items to process
	         */
	        ,
	        set: function set(value) {
	            this._synchronousOperationsQueuePollDelay = Math.max(0, value);
	        }
	
	        /**
	         * Get the value for the lookupServicesWhenConnectedRetryDelay setting.
	         * @return {number}. The time in milliseconds to wait before retrying to lookup the BLE services and
	         * characteristics after connecting
	         */
	
	    }, {
	        key: 'lookupServicesWhenConnectedRetryDelay',
	        get: function get() {
	            return this._lookupServicesWhenConnectedRetryDelay;
	        }
	
	        /**
	         * Set the value for the lookupServicesWhenConnectedRetryDelay setting.
	         * @param {number} value. The time in milliseconds to wait before retrying to lookup the BLE services and
	         * characteristics after connecting
	         */
	        ,
	        set: function set(value) {
	            this._lookupServicesWhenConnectedRetryDelay = Math.max(0, value);
	        }
	
	        /**
	         * Get the value for the lookupServicesWhenConnectedRetryMaxCount setting.
	         * @return {number}. The number of times to retry lookup of the BLE services and
	         * characteristics after connecting
	         */
	
	    }, {
	        key: 'lookupServicesWhenConnectedRetryMaxCount',
	        get: function get() {
	            return this._lookupServicesWhenConnectedRetryMaxCount;
	        }
	
	        /**
	         * Set the value for the lookupServicesWhenConnectedRetryMaxCount setting.
	         * @param {number} value. The number of times to retry lookup of the BLE services and
	         * characteristics after connecting
	         */
	        ,
	        set: function set(value) {
	            this._lookupServicesWhenConnectedRetryMaxCount = Math.max(0, value);
	        }
	
	        /**
	         * Get the value for the updateAdvertisingDevicesIntervalMillis setting.
	         * @return {number}. The time in milliseconds to wait before pruning the list of advertising devices
	         */
	
	    }, {
	        key: 'updateAdvertisingDevicesIntervalMillis',
	        get: function get() {
	            return this._updateAdvertisingDevicesIntervalMillis;
	        }
	
	        /**
	         * Set the value for the updateAdvertisingDevicesIntervalMillis setting.
	         * @param {number} value. The time in milliseconds to wait before pruning the list of advertising devices
	         */
	        ,
	        set: function set(value) {
	            this._updateAdvertisingDevicesIntervalMillis = Math.max(0, value);
	        }
	    }, {
	        key: 'startCharacteristicNotificationsWhenConnectedRetryDelay',
	        get: function get() {
	            return this._startCharacteristicNotificationsWhenConnectedRetryDelay;
	        },
	        set: function set(value) {
	            this._startCharacteristicNotificationsWhenConnectedRetryDelay = value;
	        }
	    }, {
	        key: 'startCharacteristicNotificationsWhenConnectedRetryMax',
	        get: function get() {
	            return this._startCharacteristicNotificationsWhenConnectedRetryMax;
	        },
	        set: function set(value) {
	            this._startCharacteristicNotificationsWhenConnectedRetryMax = value;
	        }
	    }, {
	        key: 'serviceCountComplete',
	        get: function get() {
	            return this._serviceCountComplete;
	        },
	        set: function set(value) {
	            this._serviceCountComplete = value;
	        }
	    }, {
	        key: 'waitForAddServicesBeforePollingMillis',
	        get: function get() {
	            return this._waitForAddServicesBeforePollingMillis;
	        },
	        set: function set(value) {
	            this._waitForAddServicesBeforePollingMillis = value;
	        }
	    }, {
	        key: 'filterFallbackEnabled',
	        get: function get() {
	            return this._filterFallbackEnabled;
	        },
	        set: function set(value) {
	            this._filterFallbackEnabled = value;
	        }
	    }, {
	        key: 'usePreviouslySeenCacheAsFallbackFilter',
	        get: function get() {
	            return this._usePreviouslySeenCacheAsFallbackFilter;
	        },
	        set: function set(value) {
	            this._usePreviouslySeenCacheAsFallbackFilter = value;
	        }
	    }]);
	    return LegoDeviceManagerConfig;
	}();
	
	/**
	 * This class is the entry point for a client to use the SDK for communicating with a LEGO smarthub device.
	 *
	 * @see {@link LegoDeviceManagerImpl#getInstance}
	 */
	
	
	var LegoDeviceManagerImpl = function () {
	    (0, _createClass3.default)(LegoDeviceManagerImpl, null, [{
	        key: 'getInstance',
	
	
	        /**
	         * Use this function for getting the client a configured LegoDeviceManagerImpl that can be used for starting
	         * BLE scans, connecting and disconnecting to a device and so on.
	         *
	         * @returns {LegoDeviceManagerImpl} singleton instance that can be used for the lifespan of the session.
	         */
	        value: function getInstance() {
	            if (LegoDeviceManagerImpl.instance === null) {
	                LegoDeviceManagerImpl.instance = new LegoDeviceManagerImpl();
	                LegoDeviceManagerImpl.instance.registerDisconnectListener();
	            }
	            if (LegoDeviceManagerImpl.instance.config.listenForConnectionsAllTheTime) {
	                LegoDeviceManagerImpl.instance.registerConnectListener();
	            }
	
	            return LegoDeviceManagerImpl.instance;
	        }
	
	        /**
	         * @static {LegoDeviceManagerImpl}
	         */
	
	    }]);
	
	    function LegoDeviceManagerImpl() {
	        (0, _classCallCheck3.default)(this, LegoDeviceManagerImpl);
	        this._config = new LegoDeviceManagerConfig();
	        this._deviceCallbackHelpers = new _map2.default();
	        this._bluetoothDeviceManager = null;
	        this.scanListenerCallbackId = null;
	        this.connectListenerCallbackId = null;
	        this.callbackHelper = new DeviceManagerCallbackHelper();
	
	        this._bluetoothDeviceManager = new _LegoBluetoothDeviceManagerImpl2.default(this.getBluetoothAdapter());
	    }
	
	    /**
	     * Get the configuration object
	     * @return {LegoDeviceManagerConfig} The config
	     */
	
	
	    (0, _createClass3.default)(LegoDeviceManagerImpl, [{
	        key: 'getConfig',
	
	
	        /**
	         * @return {LegoDeviceManagerConfig} The config
	         * @deprecated Use the config property instead
	         */
	        value: function getConfig() {
	            return this.config;
	        }
	    }, {
	        key: 'getDeviceCallbackHelper',
	
	
	        /**
	         *
	         * @param {string} address - The mac address of the hub
	         * @return {DeviceCallbackHelper} - The helper instance handling callbacks for the hub matching the mac address
	         * parameter
	         */
	        value: function getDeviceCallbackHelper(address) {
	            if (this.deviceCallbackHelpers.has(address)) {
	                return this.deviceCallbackHelpers.get(address);
	            } else {
	                return null;
	            }
	        }
	
	        /**
	         * Set a devicecallbackhelper for the hub that matches the mac address - if and only if no devicecallbackhelper
	         * already exist for the address.
	         *
	         * @param {string} address - The mac address of the hub
	         * @param {DeviceCallbackHelper} deviceCallbackHelper - The device callbackhelper to set as callback helper
	         * implementation for the hub matching the mac address parameter
	         * @return {boolean} - Return true if there was no devicecallbackhelper for the address and the provided
	         * callbackhelper has been set. False if there was already a devicecallbackhelper for the address and no changes
	         * were made.
	         */
	
	    }, {
	        key: 'setDeviceCallbackHelper',
	        value: function setDeviceCallbackHelper(address, deviceCallbackHelper) {
	            if (!this.deviceCallbackHelpers.has(address)) {
	                this.deviceCallbackHelpers.set(address, deviceCallbackHelper);
	                return true;
	            } else {
	                return false;
	            }
	        }
	
	        /**
	         * Remove the devicecallbackhelper for the hub that matches the mac address
	         * @param {string} address - The mac address of the hub
	         * @return {boolean} - True if the helper was found and deleted, false otherwise.
	         */
	
	    }, {
	        key: 'removeDeviceCallbackHelper',
	        value: function removeDeviceCallbackHelper(address) {
	            return this.deviceCallbackHelpers.delete(address);
	        }
	
	        /**
	         * Start scanning as a Promise
	         *
	         * The scan function is implemented as a promise which means that a client can wait for the scan operation to
	         * finish by using this syntax:
	         * @example
	         * LegoDeviceManagerImpl.getInstance().scan()
	         *      .then(() => {
	         *          // Scan started
	         *      }
	         *      .catch( err => {
	         *          // Scan failed starting - reason stated in error param
	         *      }
	         * )
	         *
	         * @return {Promise} The promise resolves once the scan has started, or rejects if an error occurs when trying
	         * to start the scan.
	         */
	
	    }, {
	        key: 'scan',
	        value: function () {
	            var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
	                return _regenerator2.default.wrap(function _callee2$(_context2) {
	                    while (1) {
	                        switch (_context2.prev = _context2.next) {
	                            case 0:
	                                this.scanListenerCallbackId = this.bluetoothDeviceManager.registerCallbackListener(this);
	                                _context2.next = 3;
	                                return this.bluetoothDeviceManager.scan();
	
	                            case 3:
	                            case 'end':
	                                return _context2.stop();
	                        }
	                    }
	                }, _callee2, this);
	            }));
	
	            function scan() {
	                return _ref2.apply(this, arguments);
	            }
	
	            return scan;
	        }()
	
	        /**
	         * Stop scanning as a Promise
	         *
	         * The stopScanning function is implemented as a promise which means that a client can wait for the scan to stop
	         * - or simply fire a stop and not wait around for it to finish.
	         *
	         * @example
	         * LegoDeviceManagerImpl.getInstance().stopScanning()
	         *      .then(() => {
	         *          // Scan stopped
	         *      }
	         *      .catch( err => {
	         *          // Stopping scan failed - reason stated in error param
	         *      }
	         * )
	         *
	         * @return {Promise} The promise resolves once the scan has started, or rejects if an error occurs when trying
	         * to stop the adapter from scanning for devices.
	         */
	
	    }, {
	        key: 'stopScanning',
	        value: function () {
	            var _ref3 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3() {
	                return _regenerator2.default.wrap(function _callee3$(_context3) {
	                    while (1) {
	                        switch (_context3.prev = _context3.next) {
	                            case 0:
	                                if (!(this.bluetoothDeviceManager !== null)) {
	                                    _context3.next = 6;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('bluetoothDeviceManager.stopScanning - begin');
	                                }
	                                _context3.next = 4;
	                                return this.bluetoothDeviceManager.stopScanning();
	
	                            case 4:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('bluetoothDeviceManager.stopScanning - completed');
	                                }
	                                if (!LegoDeviceManagerImpl.getInstance().config.listenForConnectionsAllTheTime) {
	                                    if (this.scanListenerCallbackId !== null) {
	                                        this.bluetoothDeviceManager.unregisterCallbackListener(this.scanListenerCallbackId);
	                                        this.scanListenerCallbackId = null;
	                                    }
	                                }
	
	                            case 6:
	                            case 'end':
	                                return _context3.stop();
	                        }
	                    }
	                }, _callee3, this);
	            }));
	
	            function stopScanning() {
	                return _ref3.apply(this, arguments);
	            }
	
	            return stopScanning;
	        }()
	
	        /**
	         * isScanning as a Promise
	         **
	         * @return {Promise} The promise resolves to either true if the bluetooth adapter is scanning, or false if it is
	         * not.
	         */
	
	    }, {
	        key: 'isScanning',
	        value: function () {
	            var _ref4 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
	                return _regenerator2.default.wrap(function _callee4$(_context4) {
	                    while (1) {
	                        switch (_context4.prev = _context4.next) {
	                            case 0:
	                                if (!(this.bluetoothDeviceManager !== null)) {
	                                    _context4.next = 4;
	                                    break;
	                                }
	
	                                _context4.next = 3;
	                                return this.bluetoothDeviceManager.isScanning();
	
	                            case 3:
	                                return _context4.abrupt('return', _context4.sent);
	
	                            case 4:
	                                return _context4.abrupt('return', false);
	
	                            case 5:
	                            case 'end':
	                                return _context4.stop();
	                        }
	                    }
	                }, _callee4, this);
	            }));
	
	            function isScanning() {
	                return _ref4.apply(this, arguments);
	            }
	
	            return isScanning;
	        }()
	
	        /**
	         * ConnectsToDevice
	         *
	         * @param {string} legoDeviceAddress - The mac address of the LEGO hub to connect to
	         * @param {bool} stopScanning  -  Default value is false, set this to true in order to automatically stop
	         * scanning when connecting (on slow hardware the connect attempt may time out if scanning is active during
	         * connect).
	         *
	         * @return {Promise}  The promise resolves when the bluetooth adapter has connected to the device, or rejects
	         * with an error description.
	         */
	
	    }, {
	        key: 'connectToDevice',
	        value: function () {
	            var _ref5 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5(legoDeviceAddress) {
	                var stopScanning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	                var restoreScanning, legoDevice, isScanning;
	                return _regenerator2.default.wrap(function _callee5$(_context5) {
	                    while (1) {
	                        switch (_context5.prev = _context5.next) {
	                            case 0:
	                                restoreScanning = false;
	                                legoDevice = this.bluetoothDeviceManager.getLegoBluetoothDeviceWithAddress(legoDeviceAddress);
	
	                                if (!(legoDevice && legoDevice !== null)) {
	                                    _context5.next = 33;
	                                    break;
	                                }
	
	                                if (!stopScanning) {
	                                    _context5.next = 18;
	                                    break;
	                                }
	
	                                _context5.prev = 4;
	                                _context5.next = 7;
	                                return this.isScanning();
	
	                            case 7:
	                                isScanning = _context5.sent;
	
	                                if (!isScanning) {
	                                    _context5.next = 13;
	                                    break;
	                                }
	
	                                restoreScanning = true;
	                                _context5.next = 12;
	                                return this.stopScanning();
	
	                            case 12:
	                                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                    _LDSDKLogger2.default.debug('Scanning stopped as part of connectToDevice');
	                                }
	
	                            case 13:
	                                _context5.next = 18;
	                                break;
	
	                            case 15:
	                                _context5.prev = 15;
	                                _context5.t0 = _context5['catch'](4);
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('In connectToDevice stopScanning failed: ', _context5.t0);
	                                }
	
	                            case 18:
	                                _context5.prev = 18;
	
	                                // register a new listener that is active while connecting - unregister in the callbacks
	                                this.registerConnectListener();
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug(this.constructor.name + ' connectToDevice \'' + legoDevice.getName() + '\' start');
	                                }
	                                _context5.next = 23;
	                                return this.bluetoothDeviceManager.connectToDevice(legoDevice);
	
	                            case 23:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug(this.constructor.name + ' connectToDevice \'' + legoDevice.getName() + '\' done');
	                                }
	                                if (restoreScanning) {
	                                    try {
	                                        if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                            _LDSDKLogger2.default.debug(this.constructor.name + ' connectToDevice \'' + legoDevice.getName() + '\'' + ' Restarting scan after connect complete');
	                                        }
	                                        this.scan();
	                                    } catch (err) {
	                                        if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                            _LDSDKLogger2.default.info(this.constructor.name + ' connectToDevice \'' + legoDevice.getName() + '\'' + ' failed starting scan', err);
	                                        }
	                                    }
	                                }
	                                _context5.next = 31;
	                                break;
	
	                            case 27:
	                                _context5.prev = 27;
	                                _context5.t1 = _context5['catch'](18);
	
	                                _LDSDKLogger2.default.error(this.constructor.name + ' connectToDevice \'' + legoDevice.getName() + '\' failed', _context5.t1);
	                                throw _context5.t1;
	
	                            case 31:
	                                _context5.next = 34;
	                                break;
	
	                            case 33:
	                                _LDSDKLogger2.default.error('No LegoBluetoothDeviceImpl found for address', legoDeviceAddress);
	
	                            case 34:
	                            case 'end':
	                                return _context5.stop();
	                        }
	                    }
	                }, _callee5, this, [[4, 15], [18, 27]]);
	            }));
	
	            function connectToDevice(_x) {
	                return _ref5.apply(this, arguments);
	            }
	
	            return connectToDevice;
	        }()
	
	        /**
	         * @ignore - This is internal functionality
	         *
	         * Registers the listener responsible for handling connect callbacks.
	         *
	         * Can be called repeatedly - registers a new listener only if none is registered in advance
	         */
	
	    }, {
	        key: 'registerDisconnectListener',
	        value: function registerDisconnectListener() {
	            if (this.disconnectListenerCallbackId === null) {
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('Registering proxy for disconnect listener - registerCallbackListener');
	                }
	                var self = this;
	                var proxyDisconnectListener = {
	                    onDidDisconnectFromDevice: function onDidDisconnectFromDevice(device, autoReconnect, error) {
	                        if (_LDSDKLogger2.default.isDebugEnabled()) {
	                            _LDSDKLogger2.default.debug('Proxy disconnect listener forwarding to ' + self.constructor.name + '.onDidDisconnectFromDevice');
	                        }
	                        self.onDidDisconnectFromDevice(device, autoReconnect, error);
	                    }
	                };
	                this.disconnectListenerCallbackId = this.bluetoothDeviceManager.registerCallbackListener(proxyDisconnectListener);
	            }
	        }
	
	        /**
	         * @ignore - This is internal functionality
	         *
	         * Registers the listener responsible for handling connect callbacks.
	         *
	         * Can be called repeatedly - registers a new listener only if none is registered in advance
	         */
	
	    }, {
	        key: 'registerConnectListener',
	        value: function registerConnectListener() {
	            if (this.connectListenerCallbackId === null) {
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('connectToDevice - registerCallbackListener');
	                }
	                this.connectListenerCallbackId = this.bluetoothDeviceManager.registerCallbackListener(this);
	            }
	        }
	
	        /**
	         * @ignore - This is internal functionality
	         *
	         * Unregisters the listener responsible for handling connect callbacks.
	         *
	         * Can be called repeatedly - unregisters the listener only if none is registered in advance
	         */
	
	    }, {
	        key: 'unregisterConnectListener',
	        value: function unregisterConnectListener() {
	            if (this.connectListenerCallbackId !== null) {
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('connectToDevice - UnregisterCallbackListener ' + this.connectListenerCallbackId);
	                }
	                this.bluetoothDeviceManager.unregisterCallbackListener(this.connectListenerCallbackId);
	                this.connectListenerCallbackId = null;
	            } else {
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('connectToDevice - No connectListenerCallbackId found to unregister');
	                }
	            }
	        }
	
	        /**
	         * Set the timeout before aborting a connect attempt - the default value is specified in {@link LegoDeviceManager.DEFAULT_CONNECT_REQUEST_TIMEOUT}
	         * @param timeoutInterval - The timeout in milliseconds
	         */
	
	    }, {
	        key: 'setConnectRequestTimeoutInterval',
	        value: function setConnectRequestTimeoutInterval(timeoutInterval) {
	            this.config.connectRequestTimeoutInterval = timeoutInterval;
	        }
	
	        /**
	         * Get the timout interval
	         * @return {number} The timeout interval in milliseconds
	         */
	
	    }, {
	        key: 'getConnectRequestTimeoutInterval',
	        value: function getConnectRequestTimeoutInterval() {
	            return this.config.connectRequestTimeoutInterval;
	        }
	
	        /**
	         * Sets whether or not to autmatically reconnect to a device if the connection is lost. Default value is false.
	         * @param {bool} enabled - Enabled=true, disabled=false
	         */
	
	    }, {
	        key: 'setAutomaticReconnectOnConnectionLostEnabled',
	        value: function setAutomaticReconnectOnConnectionLostEnabled(enabled) {
	            this.config.automaticReconnectOnConnectionLostEnabled = enabled;
	        }
	
	        /**
	         * Return whether or not automatically reconnect is enabled.
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'isAutomaticReconnectOnConnectionLostEnabled',
	        value: function isAutomaticReconnectOnConnectionLostEnabled() {
	            return this.config.automaticReconnectOnConnectionLostEnabled;
	        }
	
	        /**
	         * Cancel connecting to a device
	         *
	         * @param {string} legoDeviceAddress - The mac address of the device to disconnect
	         * @return {Promise} Returns a promise that resolves when the connection has been canceled
	         */
	
	    }, {
	        key: 'cancelDeviceConnection',
	        value: function () {
	            var _ref6 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6(legoDeviceAddress) {
	                return _regenerator2.default.wrap(function _callee6$(_context6) {
	                    while (1) {
	                        switch (_context6.prev = _context6.next) {
	                            case 0:
	                                _context6.next = 2;
	                                return this.bluetoothDeviceManager.cancelDeviceConnection(legoDeviceAddress);
	
	                            case 2:
	                            case 'end':
	                                return _context6.stop();
	                        }
	                    }
	                }, _callee6, this);
	            }));
	
	            function cancelDeviceConnection(_x3) {
	                return _ref6.apply(this, arguments);
	            }
	
	            return cancelDeviceConnection;
	        }()
	
	        /**
	         *
	         * @param {number} connectionState - @see {@link StateEnum}
	         * @param {boolean} [simple = true] - True means get a simple device representation, false will return the full device representation
	         * @return {SimpleList.<LegoBluetoothDeviceImpl>}
	         */
	
	    }, {
	        key: 'devicesInState',
	        value: function devicesInState(connectionState) {
	            var simple = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	
	            var devicesInStateList = this.bluetoothDeviceManager.devicesInState(connectionState);
	            if (simple) {
	                var simpleDevices = new _SimpleList2.default();
	                for (var i = 0; i < devicesInStateList.length(); i++) {
	                    simpleDevices.add(devicesInStateList.get(i).getSimpleDevice());
	                }
	                return simpleDevices;
	            } else {
	                return devicesInStateList;
	            }
	        }
	
	        /**
	         * Get a cached device for the given MAC address.
	         * @param {string} address - The MAC address of the device
	         * @param {boolean} simple - Optional parameter - defaults to true. True means get a simple device, false gets
	         * the full device representation
	         * @return {LegoBluetoothDeviceImpl} - Returns null if not found in the cache
	         */
	
	    }, {
	        key: 'getDevice',
	        value: function getDevice(address) {
	            var simple = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	
	            var legoDevice = this.bluetoothDeviceManager.getLegoBluetoothDeviceWithAddress(address);
	            if (legoDevice === null) {
	                return null;
	            }
	            if (simple) {
	                return legoDevice.getSimpleDevice();
	            } else {
	                return legoDevice;
	            }
	        }
	
	        /**
	         * Get a list of all known devices
	         *
	         * @param {boolean} simple - Optional parameter - defaults to true. True means get a simple device, false gets
	         * the full device representation
	         * @return {SimpleList<LegoBluetoothDeviceImpl>}
	         */
	
	    }, {
	        key: 'allDevices',
	        value: function allDevices() {
	            var simple = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	
	            var devices = new _SimpleList2.default();
	            if (this.bluetoothDeviceManager !== null) {
	                var allBluetoothDevices = this.bluetoothDeviceManager.allDevices();
	                for (var i = 0; i < allBluetoothDevices.length(); i++) {
	                    if (simple) {
	                        devices.add(allBluetoothDevices.get(i).getSimpleDevice());
	                    } else {
	                        devices.add(allBluetoothDevices.get(i));
	                    }
	                }
	            }
	            if (_LDSDKLogger2.default.isTraceEnabled()) {
	                _LDSDKLogger2.default.debug(this.constructor.name + '.allDevices returning ' + devices.length() + ' devices');
	            }
	            return devices;
	        }
	
	        /**
	         * Register a callback listener for receiving callbacks during scanning and connection attempts
	         * @see {@link DeviceManagerCallbackHelper}
	         *
	         * @param {object} listener - An object that has functions that match the expected names and signatures of {@link DeviceManagerCallbackHelper}
	         * @return {string} - The id of the listener registered. This id can be used for unregistering the listener later.
	         */
	
	    }, {
	        key: 'registerCallbackListener',
	        value: function registerCallbackListener(listener) {
	            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                _LDSDKLogger2.default.info('Registering DeviceManagerCallbackHelper listener of type: ', listener.constructor.name);
	            }
	            return this.callbackHelper.registerCallbackListener(listener);
	        }
	
	        /**
	         * Unregisters the callback listener with the given id.
	         *
	         * @param {string} listenerId - The listener id returned when registering the listener.
	         * @return {boolean} - Returns true if a listener was unregistered, or false if none with that id was found
	         */
	
	    }, {
	        key: 'unregisterCallbackListener',
	        value: function unregisterCallbackListener(listenerId) {
	            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                _LDSDKLogger2.default.info('Unregistering DeviceManagerCallbackHelper listener with id: ', listenerId);
	            }
	            return this.callbackHelper.unregisterCallbackListener(listenerId);
	        }
	
	        /**
	         * Register a callback listener for Device callbacks
	         *
	         * @param {string} address
	         * @param {DeviceCallbackHelper} listener
	         * @return {string|null}. If successful return the listenerId the callback listener has been registered under
	         * or return null if device with address not found.
	         * @see {DeviceCallbackHelper}
	         */
	
	    }, {
	        key: 'registerDeviceCallbackListener',
	        value: function registerDeviceCallbackListener(address, listener) {
	            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                _LDSDKLogger2.default.info('Registering DeviceCallback listener of type: ', listener.constructor.name + ', for' + ' device address: ' + address);
	            }
	            var cachedDevice = this.getDevice(address, false);
	            if (cachedDevice && cachedDevice !== null) {
	                return cachedDevice.registerCallbackListener(listener);
	            }
	            return null;
	        }
	
	        /**
	         * Unregister a Device callback listener with the given listenerId
	         *
	         * @param {string} address - The mac address of the device
	         * @param {string} listenerId - The listenerId returned when registering the listener.
	         * @return {boolean}. If true the listener was found and unregister, false otherwise.
	         * @see {DeviceCallbackHelper}
	         */
	
	    }, {
	        key: 'unregisterDeviceCallbackListener',
	        value: function unregisterDeviceCallbackListener(address, listenerId) {
	            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                _LDSDKLogger2.default.info('Unregistering DeviceCallback listener with id: ', listenerId + ', for device address: ' + address);
	            }
	            var cachedDevice = this.getDevice(address, false);
	            if (cachedDevice && cachedDevice !== null) {
	                return cachedDevice.unregisterCallbackListener(listenerId);
	            }
	            return false;
	        }
	
	        /**
	         * Register a callback listener for Service callbacks
	         *
	         * @param {string} address - The mac address of the hub
	         * @param {string} serviceConnectId - The connect id of the service
	         * @param {object} listener - Implementation of object that has functions that can be called back when the
	         * service data changes.
	         * @return {string|null}. If successful return the listenerId the callback listener has been registered under
	         * or return null if device with address not found.
	         * @see {LegoServiceCallbackHelper}
	         */
	
	    }, {
	        key: 'registerServiceCallbackListener',
	        value: function registerServiceCallbackListener(address, serviceConnectId, listener) {
	            var service = this.getDeviceServiceWithConnectId(address, serviceConnectId, false);
	            if (service && service !== null) {
	                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                    _LDSDKLogger2.default.info('Service "' + service.getServiceName() + '" found for [address: ' + address + ', connectId: ' + serviceConnectId + '] registering service listener');
	                }
	                return service.registerCallbackListener(listener);
	            } else {
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('No service found for [address: ' + address + ', connectId: ' + serviceConnectId + '] unable to register listener');
	                }
	            }
	            return null;
	        }
	
	        /**
	         * Unregister a service callback listener with the given listenerId
	         *
	         * @param {string} address - The mac address of the hub
	         * @param {string} serviceConnectId - The connect id of the service
	         * @param {string} listenerId - The listenerId returned when registering the listener.
	         * @return {boolean}. If true the listener was found and unregister, false otherwise.
	         * @see {LegoServiceCallbackHelper}
	         */
	
	    }, {
	        key: 'unregisterServiceCallbackListener',
	        value: function unregisterServiceCallbackListener(address, serviceConnectId, listenerId) {
	            var service = this.getDeviceServiceWithConnectId(address, serviceConnectId, false);
	            if (service && service !== null) {
	                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                    _LDSDKLogger2.default.info('Service "' + service.getServiceName() + '" found for [address: ' + address + ', connectId: ' + serviceConnectId + '] unregistering service listener with id: ' + listenerId);
	                }
	                return service.unregisterCallbackListener(listenerId);
	            } else {
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('No service found for [address: ' + address + ', connectId: ' + serviceConnectId + '] unable to unregister listener');
	                }
	            }
	            return false;
	        }
	
	        /**
	         * Get a specific service from the device with the given address.
	         *
	         * @param {string} address - The mac address of the hub
	         * @param {number} serviceConnectId - The connect id of the service connected to the hub
	         * @param {boolean} simple - Optional argument - defaults to a simple representation. If true a simple version of the object is returned, if false the full object is returned
	         * @return {LegoService|null} - The LegoService instance found, or null if either no or no service is found
	         */
	
	    }, {
	        key: 'getDeviceServiceWithConnectId',
	        value: function getDeviceServiceWithConnectId(address, serviceConnectId) {
	            var simple = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	
	            var cachedDevice = this.getDevice(address, false);
	            if (cachedDevice && cachedDevice !== null) {
	                var fullService = cachedDevice.getService(serviceConnectId);
	                if (simple) {
	                    return fullService.getSimpleService();
	                } else {
	                    return fullService;
	                }
	            }
	            return null;
	        }
	
	        /**
	         * Get a specific service from the device with the given address.
	         * @param {{deviceId: !string, connectInfo: !Object} simpleService
	         * @param {boolean} simple - Optional argument - defaults to a simple representation. If true a simple version of the object is returned, if false the full object is returned
	         */
	
	    }, {
	        key: 'getDeviceService',
	        value: function getDeviceService(simpleService) {
	            var simple = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	
	            return this.getDeviceServiceWithConnectId(simpleService.deviceId, simpleService.connectInfo.connectId, simple);
	        }
	
	        /**
	         * Set the name of the hub with the given address.
	         * @param {string} address - The mac address of the hub
	         * @param {string} name
	         */
	
	    }, {
	        key: 'setDeviceName',
	        value: function setDeviceName(address, name) {
	            var cachedDevice = this.getDevice(address, false);
	            if (cachedDevice && cachedDevice !== null) {
	                cachedDevice.setName(name);
	            }
	        }
	
	        /**
	         * Get the current SDK version
	         * @return {string} - The sdk version.
	         */
	
	    }, {
	        key: 'getSDKVersion',
	        value: function getSDKVersion() {
	            return '2.4.2.236'; // REPLACE_MARKER_DO_NOT_DELETE // TODO make a config where this can be read from
	        }
	
	        /**
	         * This function is called once for each device found while the sdk is scanning for devices
	         * @param {LegoBluetoothDeviceImpl} device
	         */
	
	    }, {
	        key: 'onDeviceDidAppear',
	        value: function onDeviceDidAppear(device) {
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                if (this.callbackHelper && this.callbackHelper !== null) {
	                    _LDSDKLogger2.default.debug('onDeviceDidAppear - Calling callbackHelper.performDeviceAppearedCallback - ' + _StringUtils2.default.getDeviceString(device));
	                } else {
	                    _LDSDKLogger2.default.warn('onDeviceDidAppear - NOT Calling callbackHelper.performDeviceAppearedCallback - callbackHelper is not initialized. Name: ' + device.getName() + ' [' + device.getAddress() + ']');
	                }
	            }
	            // this.bluetoothDeviceManager.devices.set(device.getAddress(), device);
	            this.callbackHelper.performDeviceAppearedCallback(device);
	        }
	
	        /**
	         * This function is called once for each device that was seen, but is no longer found while the sdk is scanning for
	         * devices
	         * @param {LegoBluetoothDeviceImpl} device
	         */
	
	    }, {
	        key: 'onDeviceDidDisappear',
	        value: function onDeviceDidDisappear(device) {
	            if (device.getConnectState() !== _LegoDeviceImpl.StateEnum.DisconnectedNotAdvertising) {
	                device.updateConnectionStateUponConnectionStateChange(null, _LegoDeviceImpl.StateEnum.DisconnectedNotAdvertising);
	            }
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('onDeviceDidDisappear - Calling callbackHelper.performDeviceDisappearedCallback - ' + _StringUtils2.default.getDeviceString(device) + '. Devices size: ' + this.bluetoothDeviceManager.devices.size);
	            }
	            try {
	                this.callbackHelper.performDeviceDisappearedCallback(device);
	            } catch (err) {
	                if (_LDSDKLogger2.default.isErrorEnabled()) {
	                    _LDSDKLogger2.default.error('Failed performDeviceDisappearedCallback for ' + _StringUtils2.default.getDeviceString(device) + '. Error: ', err);
	                }
	            }
	            this.bluetoothDeviceManager.devices.delete(device.getAddress());
	        }
	
	        /**
	         * Called when the sdk will start connecting to a device
	         * @param {LegoBluetoothDeviceImpl} device
	         */
	
	    }, {
	        key: 'onWillStartConnectingToDevice',
	        value: function onWillStartConnectingToDevice(device) {
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('onWillStartConnectingToDevice - Calling' + ' callbackHelper.performWillStartConnectingToDeviceCallback - ' + _StringUtils2.default.getDeviceString(device));
	            }
	            if (!this.config.listenForConnectionsAllTheTime) {
	                this.registerConnectListener(); // Register connect callback listener
	            }
	            this.callbackHelper.performWillStartConnectingToDeviceCallback(device);
	        }
	
	        /**
	         *
	         * @param {LegoBluetoothDeviceImpl} device
	         * @param autoReconnect
	         * @param error
	         */
	
	    }, {
	        key: 'onDidFailToConnectToDevice',
	        value: function onDidFailToConnectToDevice(device, autoReconnect, error) {
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('onDidFailToConnectToDevice - Calling callbackHelper.performDidFailToConnectToDevice - ' + _StringUtils2.default.getDeviceString(device));
	            }
	            try {
	                this.callbackHelper.performDidFailToConnectToDevice(device, autoReconnect, error);
	            } catch (err) {
	                if (_LDSDKLogger2.default.isErrorEnabled()) {
	                    _LDSDKLogger2.default.error('onDidFailToConnectToDevice - failed' + ' callbackHelper.performDidFailToConnectToDevice - ' + _StringUtils2.default.getDeviceString(device) + '. Error: ', err);
	                }
	            }
	            if (!this.config.listenForConnectionsAllTheTime) {
	                this.unregisterConnectListener();
	            }
	        }
	
	        /**
	         *
	         * @param {LegoBluetoothDeviceImpl} device - The bluetooth device
	         * @param {bool} autoReconnect - Automatically reconnect if the device appears again
	         * @param {string} error - If an error occurred this parameter will be defined and contain the error
	         */
	
	    }, {
	        key: 'onDidDisconnectFromDevice',
	        value: function onDidDisconnectFromDevice(device, autoReconnect, error) {
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('onDidDisconnectFromDevice - Calling callbackHelper.performDidDisconnectFromDevice - ' + _StringUtils2.default.getDeviceString(device));
	            }
	            this.callbackHelper.performDidDisconnectFromDevice(device, autoReconnect, error);
	        }
	
	        /**
	         *
	         * @param {LegoBluetoothDeviceImpl} device
	         *
	         * @return {Promise}
	         */
	
	    }, {
	        key: 'onDidStartInterrogatingDevice',
	        value: function () {
	            var _ref7 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7(device) {
	                return _regenerator2.default.wrap(function _callee7$(_context7) {
	                    while (1) {
	                        switch (_context7.prev = _context7.next) {
	                            case 0:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('onDidStartInterrogatingDevice - Calling callbackHelper.performDidStartInterrogatingDevice - ' + _StringUtils2.default.getDeviceString(device));
	                                }
	                                _context7.next = 3;
	                                return this.callbackHelper.performDidStartInterrogatingDevice(device);
	
	                            case 3:
	                            case 'end':
	                                return _context7.stop();
	                        }
	                    }
	                }, _callee7, this);
	            }));
	
	            function onDidStartInterrogatingDevice(_x9) {
	                return _ref7.apply(this, arguments);
	            }
	
	            return onDidStartInterrogatingDevice;
	        }()
	
	        /**
	         * When the device has been interrogated abouts its services and characteristics this function is called. This
	         * signals that the connection attempt was successful.
	         *
	         * @param {LegoBluetoothDeviceImpl} device
	         */
	
	    }, {
	        key: 'onDidFinishInterrogatingDevice',
	        value: function onDidFinishInterrogatingDevice(device) {
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('onDidFinishInterrogatingDevice - Calling callbackHelper.performDidFinishInterrogatingDevice - ' + _StringUtils2.default.getDeviceString(device));
	            }
	            try {
	                this.callbackHelper.performDidFinishInterrogratingDevice(device);
	            } catch (err) {
	                if (_LDSDKLogger2.default.isErrorEnabled()) {
	                    _LDSDKLogger2.default.error('onDidFinishInterrogatingDevice - failed' + ' callbackHelper.performDidFinishInterrogratingDevice - ' + _StringUtils2.default.getDeviceString(device) + '. Error: ', err);
	                }
	            }
	            if (!this.config.listenForConnectionsAllTheTime) {
	                this.unregisterConnectListener();
	            }
	        }
	
	        /**
	         * Get a bluetoothadapter for
	         * @return {ChromeOsBluetoothAdapterWrapper}
	         */
	
	    }, {
	        key: 'getBluetoothAdapter',
	        value: function getBluetoothAdapter() {
	            // TODO: Once we want to support web bluetooth, this should return a web bluetooth adapter instead of a ChromeOsBluetoothAdapter
	            // if (chrome !== undefined && chrome.bluetooth !== undefined && chrome.bluetoothLowEnergy !== undefined) {
	            return _ChromeOsBluetoothAdapterWrapper2.default.getInstance();
	            // }
	        }
	    }, {
	        key: 'config',
	        get: function get() {
	            return this._config;
	        }
	    }, {
	        key: 'bluetoothDeviceManager',
	        get: function get() {
	            return this._bluetoothDeviceManager;
	        }
	    }, {
	        key: 'deviceCallbackHelpers',
	        get: function get() {
	            return this._deviceCallbackHelpers;
	        }
	    }]);
	    return LegoDeviceManagerImpl;
	}();
	
	LegoDeviceManagerImpl.instance = null;
	exports.default = LegoDeviceManagerImpl;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getPrototypeOf = __webpack_require__(5);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(7);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(6);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _BaseServiceDefinition = __webpack_require__(36);
	
	var _BaseServiceDefinition2 = _interopRequireDefault(_BaseServiceDefinition);
	
	var _CharacteristicDefinition = __webpack_require__(38);
	
	var _CharacteristicDefinition2 = _interopRequireDefault(_CharacteristicDefinition);
	
	var _UuidHelper = __webpack_require__(11);
	
	var _UuidHelper2 = _interopRequireDefault(_UuidHelper);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var DeviceInfoServiceDefinition = function (_BaseServiceDefinitio) {
	    (0, _inherits3.default)(DeviceInfoServiceDefinition, _BaseServiceDefinitio);
	
	    function DeviceInfoServiceDefinition() {
	        (0, _classCallCheck3.default)(this, DeviceInfoServiceDefinition);
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, (DeviceInfoServiceDefinition.__proto__ || (0, _getPrototypeOf2.default)(DeviceInfoServiceDefinition)).call(this));
	
	        _this.firmwareRevision = null;
	        _this.hardwareRevision = null;
	        _this.softwareRevision = null;
	        _this.manufacturerName = null;
	        return _this;
	    }
	
	    (0, _createClass3.default)(DeviceInfoServiceDefinition, [{
	        key: 'init',
	        value: function init() {
	            this.serviceUUID = _UuidHelper2.default.getSpecUuid(DeviceInfoServiceDefinition.DEVICE_INFO_SERVICE_UUID);
	            this.serviceName = 'DeviceInfoService';
	
	            this.firmwareRevision = new _CharacteristicDefinition2.default('FirmwareRevision', this, _UuidHelper2.default.getSpecUuid(DeviceInfoServiceDefinition.DEVICE_INFO_FIRMWARE_REVISION_CHARACTERISTIC_UUID), true, 0 /* (BluetoothHelper.Properties.PROPERTY_READ.ordinal()) */
	            , 0, 0 /* (BluetoothHelper.Permissions.PERMISSION_READ.ordinal()) */);
	
	            this.hardwareRevision = new _CharacteristicDefinition2.default('HardwareRevision', this, _UuidHelper2.default.getSpecUuid(DeviceInfoServiceDefinition.DEVICE_INFO_HARDWARE_REVISION_CHARACTERISTIC_UUID), false, 0 /* (BluetoothHelper.Properties.PROPERTY_READ.ordinal()) */
	            , 0, 0 /* (BluetoothHelper.Permissions.PERMISSION_READ.ordinal()) */);
	
	            this.softwareRevision = new _CharacteristicDefinition2.default('SoftwareRevision', this, _UuidHelper2.default.getSpecUuid(DeviceInfoServiceDefinition.DEVICE_INFO_SOFTWARE_REVISION_CHARACTERISTIC_UUID), true, 0 /* (BluetoothHelper.Properties.PROPERTY_READ.ordinal()) */
	            , 0, 0 /* (BluetoothHelper.Permissions.PERMISSION_READ.ordinal()) */);
	
	            this.manufacturerName = new _CharacteristicDefinition2.default('ManufacturerName', this, _UuidHelper2.default.getSpecUuid(DeviceInfoServiceDefinition.DEVICE_INFO_MANUFACTURER_NAME_CHARACTERISTIC_UUID), true, 0 /* (BluetoothHelper.Properties.PROPERTY_READ.ordinal()) */
	            , 0, 0 /* (BluetoothHelper.Permissions.PERMISSION_READ.ordinal()) */);
	
	            this.characteristicDefinitions.add(this.firmwareRevision);
	            this.characteristicDefinitions.add(this.hardwareRevision);
	            this.characteristicDefinitions.add(this.softwareRevision);
	            this.characteristicDefinitions.add(this.manufacturerName);
	        }
	    }, {
	        key: 'getFirmwareRevision',
	        value: function getFirmwareRevision() {
	            return this.firmwareRevision;
	        }
	    }, {
	        key: 'getHardwareRevision',
	        value: function getHardwareRevision() {
	            return this.hardwareRevision;
	        }
	    }, {
	        key: 'getSoftwareRevision',
	        value: function getSoftwareRevision() {
	            return this.softwareRevision;
	        }
	    }, {
	        key: 'getManufacturerName',
	        value: function getManufacturerName() {
	            return this.manufacturerName;
	        }
	    }], [{
	        key: 'getInstance',
	        value: function getInstance() {
	            if (DeviceInfoServiceDefinition.instance === null) {
	                DeviceInfoServiceDefinition.instance = new DeviceInfoServiceDefinition();
	                DeviceInfoServiceDefinition.instance.init();
	            }
	            return DeviceInfoServiceDefinition.instance;
	        }
	    }]);
	    return DeviceInfoServiceDefinition;
	}(_BaseServiceDefinition2.default); /**
	                                     * Created by frj on 20/02/16.
	                                     */
	
	
	DeviceInfoServiceDefinition.DEVICE_INFO_SERVICE_UUID = '180A';
	DeviceInfoServiceDefinition.DEVICE_INFO_FIRMWARE_REVISION_CHARACTERISTIC_UUID = '2A26';
	DeviceInfoServiceDefinition.DEVICE_INFO_HARDWARE_REVISION_CHARACTERISTIC_UUID = '2A27';
	DeviceInfoServiceDefinition.DEVICE_INFO_SOFTWARE_REVISION_CHARACTERISTIC_UUID = '2A28';
	DeviceInfoServiceDefinition.DEVICE_INFO_MANUFACTURER_NAME_CHARACTERISTIC_UUID = '2A29';
	DeviceInfoServiceDefinition.instance = null;
	exports.default = DeviceInfoServiceDefinition;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(132), __esModule: true };

/***/ }),
/* 34 */
/***/ (function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ }),
/* 35 */
/***/ (function(module, exports) {

	module.exports = {};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _SimpleList = __webpack_require__(45);
	
	var _SimpleList2 = _interopRequireDefault(_SimpleList);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by frj on 22/02/16.
	 */
	var BaseServiceDefinition = function () {
	    function BaseServiceDefinition() {
	        (0, _classCallCheck3.default)(this, BaseServiceDefinition);
	        this.serviceName = null;
	        this.serviceUUID = null;
	        this.characteristicDefinitions = new _SimpleList2.default();
	        this.characteristicUUIDs = new _SimpleList2.default();
	    }
	
	    (0, _createClass3.default)(BaseServiceDefinition, [{
	        key: 'getServiceName',
	        value: function getServiceName() {
	            return this.serviceName;
	        }
	    }, {
	        key: 'getServiceUUID',
	        value: function getServiceUUID() {
	            return this.serviceUUID;
	        }
	    }, {
	        key: 'matchesService',
	        value: function matchesService(service) {
	            if (service && service !== null) {
	                return this.serviceUUID === service.uuid;
	            } else {
	                return false;
	            }
	        }
	    }, {
	        key: 'characteristicForDefinition',
	        value: function characteristicForDefinition(definition, service) {
	            for (var i = 0; i < service.getCharacteristics().length; i++) {
	                var characteristic = service.getCharacteristics()[i];
	                if (characteristic.uuid === definition.getUuid()) {
	                    return characteristic;
	                }
	            }
	            return null;
	        }
	    }, {
	        key: 'characteristicUUIDs',
	        value: function characteristicUUIDs() {
	            if (this.characteristicUUIDs === null) {
	                this.characteristicUUIDs = [this.characteristicDefinitions.length];
	
	                for (var i = 0; i < this.characteristicDefinitions.length; i++) {
	                    var definition = this.characteristicDefinitions[i];
	                    this.characteristicUUIDs.push(definition.getUuid());
	                }
	            }
	            return this.characteristicUUIDs;
	        }
	    }, {
	        key: 'characteristicDefinitionWithUUID',
	        value: function characteristicDefinitionWithUUID(uuid) {
	            for (var i = 0; i < this.characteristicDefinitions.length; i++) {
	                var definition = this.characteristicDefinitions[i];
	                if (definition.getUuid() === uuid) {
	                    return definition;
	                }
	            }
	            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                _LDSDKLogger2.default.info('Did not find characteristic with UUID ' + uuid + ' in service ' + this.serviceName);
	            }
	            return null;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return '< ' + this.serviceName + ': (' + this.serviceUUID + '), self.characteristicDefinitions size=' + this.characteristicDefinitions.length() + ' >';
	        }
	    }, {
	        key: 'toStringShort',
	        value: function toStringShort() {
	            return this.serviceName + '(' + this.serviceUUID + ')';
	        }
	    }, {
	        key: 'equals',
	        value: function equals(o) {
	            if (this === o) return true;
	            if (o === null || o === undefined || this.constructor.name !== o.constructor.name) return false;
	            return this.isEqualToDefinition(o);
	        }
	    }, {
	        key: 'isEqualToDefinition',
	        value: function isEqualToDefinition(o) {
	            if (this.characteristicDefinitions !== null ? !this.characteristicDefinitions.equals(o.characteristicDefinitions) : o.characteristicDefinitions !== null) {
	                return false;
	            }
	            if (this.characteristicUUIDs !== null ? !this.characteristicUUIDs.equals(o.characteristicUUIDs) : o.characteristicUUIDs !== null) {
	                return false;
	            }
	            if (this.serviceName !== null ? !this.serviceName.equals(o.serviceName) : o.serviceName !== null) {
	                return false;
	            }
	            if (this.serviceUUID !== null ? !this.serviceUUID.equals(o.serviceUUID) : o.serviceUUID !== null) {
	                return false;
	            }
	            return true;
	        }
	    }]);
	    return BaseServiceDefinition;
	}();
	
	exports.default = BaseServiceDefinition;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _IOServiceDefinition = __webpack_require__(48);
	
	var _IOServiceDefinition2 = _interopRequireDefault(_IOServiceDefinition);
	
	var _DeviceInfoServiceDefinition = __webpack_require__(32);
	
	var _DeviceInfoServiceDefinition2 = _interopRequireDefault(_DeviceInfoServiceDefinition);
	
	var _DeviceServiceDefinition = __webpack_require__(47);
	
	var _DeviceServiceDefinition2 = _interopRequireDefault(_DeviceServiceDefinition);
	
	var _BatteryServiceDefinition = __webpack_require__(98);
	
	var _BatteryServiceDefinition2 = _interopRequireDefault(_BatteryServiceDefinition);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by frj on 19/02/16.
	 */
	
	var BluetoothServiceDefinition = function () {
	    function BluetoothServiceDefinition() {
	        (0, _classCallCheck3.default)(this, BluetoothServiceDefinition);
	    }
	
	    (0, _createClass3.default)(BluetoothServiceDefinition, null, [{
	        key: 'ioServiceDefinition',
	        value: function ioServiceDefinition() {
	            return _IOServiceDefinition2.default.getInstance();
	        }
	    }, {
	        key: 'deviceServiceDefinition',
	        value: function deviceServiceDefinition() {
	            return _DeviceServiceDefinition2.default.getInstance();
	        }
	    }, {
	        key: 'deviceInfoServiceDefinition',
	        value: function deviceInfoServiceDefinition() {
	            return _DeviceInfoServiceDefinition2.default.getInstance();
	        }
	    }, {
	        key: 'batteryServiceDefinition',
	        value: function batteryServiceDefinition() {
	            return _BatteryServiceDefinition2.default.getInstance();
	        }
	    }, {
	        key: 'serviceDefinitionWithUUID',
	        value: function serviceDefinitionWithUUID(serviceUUID) {
	            if (BluetoothServiceDefinition.ioServiceDefinition().getServiceUUID() === serviceUUID) {
	                return BluetoothServiceDefinition.ioServiceDefinition();
	            } else if (BluetoothServiceDefinition.deviceServiceDefinition().getServiceUUID() === serviceUUID) {
	                return BluetoothServiceDefinition.deviceServiceDefinition();
	            } else if (BluetoothServiceDefinition.deviceInfoServiceDefinition().getServiceUUID() === serviceUUID) {
	                return BluetoothServiceDefinition.deviceInfoServiceDefinition();
	            } else if (BluetoothServiceDefinition.batteryServiceDefinition().getServiceUUID() === serviceUUID) {
	                return BluetoothServiceDefinition.batteryServiceDefinition();
	            }
	            return null;
	        }
	    }]);
	    return BluetoothServiceDefinition;
	}();
	
	exports.default = BluetoothServiceDefinition;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _BluetoothHelper = __webpack_require__(62);
	
	var _BluetoothHelper2 = _interopRequireDefault(_BluetoothHelper);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	var _LDSDKError = __webpack_require__(44);
	
	var _LDSDKError2 = _interopRequireDefault(_LDSDKError);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by frj on 20/02/16.
	 */
	var CharacteristicDefinition = function () {
	    (0, _createClass3.default)(CharacteristicDefinition, [{
	        key: 'getServiceDefinition',
	        value: function getServiceDefinition() {
	            return this.serviceDefinition;
	        }
	    }, {
	        key: 'getName',
	        value: function getName() {
	            return this.name;
	        }
	    }, {
	        key: 'getUuid',
	        value: function getUuid() {
	            return this.uuid;
	        }
	    }, {
	        key: 'isMandatory',
	        value: function isMandatory() {
	            return this.mandatory;
	        }
	    }, {
	        key: 'getMandatoryProperties',
	        value: function getMandatoryProperties() {
	            return this.mandatoryProperties;
	        }
	    }, {
	        key: 'getRecommendedProperties',
	        value: function getRecommendedProperties() {
	            return this.recommendedProperties;
	        }
	    }, {
	        key: 'getPermissions',
	        value: function getPermissions() {
	            return this.permissions;
	        }
	    }]);
	
	    function CharacteristicDefinition(name, serviceDefinition, uuid, mandatory, mandatoryProperties, recommendedProperties, permissions) {
	        (0, _classCallCheck3.default)(this, CharacteristicDefinition);
	        this.serviceDefinition = null;
	        this.name = null;
	        this.uuid = null;
	        this.mandatory = false;
	        this.mandatoryProperties = null;
	        this.recommendedProperties = null;
	        this.permissions = null;
	
	        this.name = name;
	        this.serviceDefinition = serviceDefinition;
	        this.uuid = uuid;
	        this.mandatory = mandatory;
	        this.mandatoryProperties = mandatoryProperties;
	        this.recommendedProperties = recommendedProperties;
	        this.permissions = permissions;
	    }
	
	    (0, _createClass3.default)(CharacteristicDefinition, [{
	        key: 'validateDefinitionIsSatisfiedByCharacteristic',
	        value: function validateDefinitionIsSatisfiedByCharacteristic(characteristic) {
	
	            if (this.mandatoryProperties !== 0 && (characteristic.getProperties() & this.mandatoryProperties) !== 0) {
	                var errorMessage = 'Characteristic ' + this.toStringShort() + ' with properties ' + this.stringsFromProperties(characteristic.getProperties()) + ' does not include mandatory properties ' + this.stringsFromProperties(this.mandatoryProperties);
	                throw _LDSDKError2.default.deviceError(_LDSDKError2.default.ErrorCode.BLUETOOTH_INVALID_CHARACTERISTIC_PROPERTIES, errorMessage);
	            }
	
	            if (this.recommendedProperties !== 0 && (characteristic.getProperties() & this.recommendedProperties) !== 0) {
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('Characteristic ' + this.toStringShort() + ' with properties ' + this.stringsFromProperties(characteristic.getProperties()) + ' does not include recommended properties ' + this.stringsFromProperties(recommendedProperties));
	                }
	            }
	        }
	    }, {
	        key: 'matchesCharacteristic',
	        value: function matchesCharacteristic(characteristic) {
	            if (characteristic && characteristic !== null) {
	                return this.uuid === characteristic.uuid;
	            } else {
	                return false;
	            }
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return '< serviceName=' + this.serviceDefinition.serviceName + ', UUID=' + this.uuid.toString() + ', isMandatory=' + this.mandatory + ', mandatoryProperties=' + _BluetoothHelper2.default.arrayOfStringsFromCharacteristicProperties(this.mandatoryProperties) + ', recommendedProperties=' + _BluetoothHelper2.default.arrayOfStringsFromCharacteristicProperties(this.recommendedProperties) + ' >';
	        }
	    }, {
	        key: 'toStringShort',
	        value: function toStringShort() {
	            return this.serviceDefinition.serviceName + '.' + this.name + '(' + this.uuid.toString();
	        }
	    }, {
	        key: 'stringsFromProperties',
	        value: function stringsFromProperties(properties) {
	            return _BluetoothHelper2.default.arrayOfStringsFromCharacteristicProperties(properties);
	        }
	    }]);
	    return CharacteristicDefinition;
	}();
	
	exports.default = CharacteristicDefinition;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	var def = __webpack_require__(17).f
	  , has = __webpack_require__(30)
	  , TAG = __webpack_require__(8)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(167)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(68)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(171);
	var global        = __webpack_require__(10)
	  , hide          = __webpack_require__(24)
	  , Iterators     = __webpack_require__(35)
	  , TO_STRING_TAG = __webpack_require__(8)('toStringTag');
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.IOType = undefined;
	
	var _map = __webpack_require__(9);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by frj on 12/02/16.
	 */
	
	/**
	* @type {object} IOType
	* @property {number} IO_TYPE_MOTOR - A motor - use the SimpleMotor service to communicate with this type of IO. @see
	* {@link SimpleMotor}
	* @property {number} IO_TYPE_VOLTAGE - A Voltage Sensor - use the VoltageSensor to communicate with this type of IO.
	 * @see {@link VoltageSensor}
	* @property {number} IO_TYPE_CURRENT - A Current Sensor - use the CurrentSensor to communicate with this type of IO.
	 * @see {@link CurrentSensor}
	* @property {number} IO_TYPE_PIEZO_TONE_PLAYER - A Piezo Tone player - use the PiezoTonePlayer to communicate with
	 * this type of IO. @see {@link PiezoTonePlayer}
	* @property {number} IO_TYPE_RGB_LIGHT - An RGB light - use the RGBLight to communicate with this type of IO. @see
	 * {@link RGBLight}
	* @property {number} IO_TYPE_TILT_SENSOR - A Tilt Sensor - use the TiltSensor to communicate with this type of IO.
	 * @see {@link TiltSensor}
	* @property {number} IO_TYPE_MOTION_SENSOR - A Motion Sensor (aka. Detect Sensor) - use the MotionSensor to
	 * communicate with this type of IO. @see {@link MotionSensor}
	* @property {number} IO_TYPE_GENERIC - A type unknown to the SDK - use the GenericService to communicate with this
	 * type of IO. @see {@link GenericService}
	*
	*/
	var IOType = exports.IOType = {
	    /**
	     * IO_TYPE_MOTOR is a Motor - use the SimpleMotor to communicate with this type of IO.
	     * @see {@link SimpleMotor}
	     */
	    IO_TYPE_MOTOR: 1,
	
	    /**
	     * A Voltage Sensor - use the VoltageSensor to communicate with this type of IO.
	     * See {VoltageSensor}
	     */
	    IO_TYPE_VOLTAGE: 20,
	
	    /**
	     * A Current Sensor - use the CurrentSensor to communicate with this type of IO.
	     * See {CurrentSensor}
	     */
	    IO_TYPE_CURRENT: 21,
	
	    /**
	     * A Piezo Tone player - use the PiezoTonePlayer to communicate with this type of IO.
	     * See {PiezoTonePlayer}
	     */
	    IO_TYPE_PIEZO_TONE_PLAYER: 22,
	
	    /**
	     * An RGB light - use the RGBLight to communicate with this type of IO.
	     * See {RGBLight}
	     */
	    IO_TYPE_RGB_LIGHT: 23,
	
	    /**
	     * A Tilt Sensor - use the TiltSensor to communicate with this type of IO.
	     * See {TiltSensor}
	     */
	    IO_TYPE_TILT_SENSOR: 34,
	
	    /**
	     * A Motion Sensor (aka. Detect Sensor) - use the MotionSensor to communicate with this type of IO.
	     * See {MotionSensor}
	     */
	    IO_TYPE_MOTION_SENSOR: 35,
	
	    /**
	     * A type unknown to the SDK - use the {GenericService} to communicate with this type of IO.
	     */
	    IO_TYPE_GENERIC: 0,
	
	    fromInteger: function fromInteger(val) {
	        switch (parseInt(val)) {
	            case this.IO_TYPE_MOTOR:
	                return this.IO_TYPE_MOTOR;
	
	            case this.IO_TYPE_VOLTAGE:
	                return this.IO_TYPE_VOLTAGE;
	
	            case this.IO_TYPE_CURRENT:
	                return this.IO_TYPE_CURRENT;
	
	            case this.IO_TYPE_PIEZO_TONE_PLAYER:
	                return this.IO_TYPE_PIEZO_TONE_PLAYER;
	
	            case this.IO_TYPE_RGB_LIGHT:
	                return this.IO_TYPE_RGB_LIGHT;
	
	            case this.IO_TYPE_TILT_SENSOR:
	                return this.IO_TYPE_TILT_SENSOR;
	
	            case this.IO_TYPE_MOTION_SENSOR:
	                return this.IO_TYPE_MOTION_SENSOR;
	
	            default:
	                return this.IO_TYPE_GENERIC;
	        }
	    }
	};
	
	var ConnectInfo = function () {
	    function ConnectInfo(connectId, hubIndex, type) {
	        var hardwareVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	        var firmwareVersion = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
	        (0, _classCallCheck3.default)(this, ConnectInfo);
	
	        this.connectId = connectId;
	        this.hubIndex = hubIndex;
	        this.type = type;
	        this.hardwareVersion = hardwareVersion;
	        this.firmwareVersion = firmwareVersion;
	
	        this.populateValidTypes();
	    }
	    /*
	        constructor(connectId, hubIndex, type) {
	            this(connectId, hubIndex, type, null, null);
	        }
	    */
	
	
	    (0, _createClass3.default)(ConnectInfo, [{
	        key: 'populateValidTypes',
	        value: function populateValidTypes() {
	            this.validTypes = new _map2.default();
	            var ioType = IOType.IO_TYPE_MOTOR;
	
	            // We use a enum with fall-through (no break statements) to make sure we get all types
	            // this will also give a compile warning if a new type is added that is not in the cases below
	            switch (ioType) {
	                case IOType.IO_TYPE_MOTOR:
	                    this.validTypes.set(IOType.IO_TYPE_MOTOR, IOType.IO_TYPE_MOTOR);
	                case IOType.IO_TYPE_VOLTAGE:
	                    this.validTypes.set(IOType.IO_TYPE_VOLTAGE, IOType.IO_TYPE_VOLTAGE);
	                case IOType.IO_TYPE_CURRENT:
	                    this.validTypes.set(IOType.IO_TYPE_CURRENT, IOType.IO_TYPE_CURRENT);
	                case IOType.IO_TYPE_PIEZO_TONE_PLAYER:
	                    this.validTypes.set(IOType.IO_TYPE_PIEZO_TONE_PLAYER, IOType.IO_TYPE_PIEZO_TONE_PLAYER);
	                case IOType.IO_TYPE_RGB_LIGHT:
	                    this.validTypes.set(IOType.IO_TYPE_RGB_LIGHT, IOType.IO_TYPE_RGB_LIGHT);
	                case IOType.IO_TYPE_TILT_SENSOR:
	                    this.validTypes.set(IOType.IO_TYPE_TILT_SENSOR, IOType.IO_TYPE_TILT_SENSOR);
	                case IOType.IO_TYPE_MOTION_SENSOR:
	                    this.validTypes.set(IOType.IO_TYPE_MOTION_SENSOR, IOType.IO_TYPE_MOTION_SENSOR);
	                case IOType.IO_TYPE_GENERIC:
	                    this.validTypes.set(IOType.IO_TYPE_GENERIC, IOType.IO_TYPE_GENERIC);
	            }
	
	            this.typeStrings = {};
	            this.typeStrings[IOType.IO_TYPE_MOTOR] = 'IO_TYPE_MOTOR';
	            this.typeStrings[IOType.IO_TYPE_VOLTAGE] = 'IO_TYPE_VOLTAGE';
	            this.typeStrings[IOType.IO_TYPE_CURRENT] = 'IO_TYPE_CURRENT';
	            this.typeStrings[IOType.IO_TYPE_PIEZO_TONE_PLAYER] = 'IO_TYPE_PIEZO_TONE_PLAYER';
	            this.typeStrings[IOType.IO_TYPE_RGB_LIGHT] = 'IO_TYPE_RGB_LIGHT';
	            this.typeStrings[IOType.IO_TYPE_TILT_SENSOR] = 'IO_TYPE_TILT_SENSOR';
	            this.typeStrings[IOType.IO_TYPE_MOTION_SENSOR] = 'IO_TYPE_MOTION_SENSOR';
	            this.typeStrings[IOType.IO_TYPE_GENERIC] = 'IO_TYPE_GENERIC';
	        }
	    }, {
	        key: 'getConnectId',
	        value: function getConnectId() {
	            return this.connectId;
	        }
	    }, {
	        key: 'getHubIndex',
	        value: function getHubIndex() {
	            return this.hubIndex;
	        }
	    }, {
	        key: 'getType',
	        value: function getType() {
	            return IOType.fromInteger(this.type);
	        }
	    }, {
	        key: 'getHardwareVersion',
	        value: function getHardwareVersion() {
	            return this.hardwareVersion;
	        }
	    }, {
	        key: 'getFirmwareVersion',
	        value: function getFirmwareVersion() {
	            return this.firmwareVersion;
	        }
	    }, {
	        key: 'getTypeString',
	        value: function getTypeString() {
	            return this.typeStrings[this.getTypeEnum()];
	        }
	
	        /**
	         * Get the type of the connect info
	         * @return {number} - A number from {@link IOType}
	         */
	
	    }, {
	        key: 'getTypeEnum',
	        value: function getTypeEnum() {
	            if (this.validTypes.has(this.type)) {
	                return IOType.fromInteger(this.type);
	            } else {
	                return IOType.IO_TYPE_GENERIC;
	            }
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return 'ConnectInfo{' + ' connectId=' + this.connectId + ', hubIndex=' + this.hubIndex + ', type=' + this.type + ', firmwareVersion=' + this.firmwareVersion + ', hardwareVersion=' + this.hardwareVersion + '}';
	        }
	    }, {
	        key: 'equals',
	        value: function equals(o) {
	            if (this === o) return true;
	            if (o === null || this.constructor.name !== o.constructor.name) return false;
	
	            if (this.connectId !== o.connectId) return false;
	            if (this.hubIndex !== o.hubIndex) return false;
	            if (this.type !== o.type) return false;
	            if (this.firmwareVersion && this.firmwareVersion !== null) {
	                if (this.firmwareVersion !== o.firmwareVersion) {
	                    return false;
	                }
	            } else {
	                if (o.firmwareVersion && o.firmwareVersion !== null) {
	                    return false;
	                }
	            }
	            if (this.hardwareVersion && this.hardwareVersion !== null) {
	                if (this.hardwareVersion !== o.hardwareVersion) {
	                    return false;
	                }
	            } else {
	                if (o.hardwareVersion && o.hardwareVersion !== null) {
	                    return false;
	                }
	            }
	            return true;
	        }
	
	        /**
	         * Get a simple connect info representation
	         * @return {{connectId: number, hubIndex: number, type: number, hardwareVersion: string, firmwareVersion: string}}
	         */
	
	    }, {
	        key: 'getSimpleConnectInfo',
	        value: function getSimpleConnectInfo() {
	            return {
	                connectId: this.getConnectId(),
	                hubIndex: this.getHubIndex(),
	                type: this.getTypeEnum(),
	                hardwareVersion: this.getHardwareVersion(),
	                firmwareVersion: this.getFirmwareVersion()
	            };
	        }
	    }]);
	    return ConnectInfo;
	}();
	
	exports.default = ConnectInfo;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.LDKSDKBluetoothInvalidCharacteristicProperties = exports.LDKSDKBluetoothMissingCharacteristics = exports.LDKSDKBluetoothUnknownServiceUuid = exports.LDKSDKBluetoothUnsupportedFirmwareVersion = exports.LDKSDKBluetoothConnectionError = exports.LDKSDKBluetoothConnectionTimeout = exports.LDKSDKInternalError = exports.ErrorCode = undefined;
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _getPrototypeOf = __webpack_require__(5);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(7);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(6);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by frj on 22/02/16.
	 */
	
	/**
	 * Error codes used by the {@link LDSDKError} and its specialized children to report the nature of the error.
	 * @property {number} INTERNAL_ERROR - Error code for sdk internal errors
	 * @property {number} BLUETOOTH_CONNECTION_TIMEOUT - Error code for Bluetooth connection timeout problems
	 * @property {number} BLUETOOTH_CONNECTION_ERROR - Error code for Bluetooth connection error problems
	 * @property {number} BLUETOOTH_UNSUPPORTED_FIRMWARE_VERSION - Error code for unsupported firmware version
	 * @property {number} BLUETOOTH_UNKNOWN_SERVICE_UUID - Error code for unknown BLE service uuid
	 * @property {number} BLUETOOTH_MISSING_CHARACTERISTICS - Error code for a missing BLE characteristic
	 * @property {number} BLUETOOTH_INVALID_CHARACTERISTIC_PROPERTIES - Error code for invalid BLE characteristic properties
	 */
	var ErrorCode = exports.ErrorCode = {
	    INTERNAL_ERROR: 1,
	    BLUETOOTH_CONNECTION_TIMEOUT: 10,
	    BLUETOOTH_CONNECTION_ERROR: 11,
	    BLUETOOTH_UNSUPPORTED_FIRMWARE_VERSION: 50,
	    BLUETOOTH_UNKNOWN_SERVICE_UUID: 100,
	    BLUETOOTH_MISSING_CHARACTERISTICS: 105,
	    BLUETOOTH_INVALID_CHARACTERISTIC_PROPERTIES: 110
	};
	
	/**
	 * @abstract
	 * Base error class - not to be created directly - Use {@link LDSDKError}, or one of its subclasses instead
	 */
	
	var ExtendableError = function (_Error) {
	    (0, _inherits3.default)(ExtendableError, _Error);
	
	    function ExtendableError(message) {
	        (0, _classCallCheck3.default)(this, ExtendableError);
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, (ExtendableError.__proto__ || (0, _getPrototypeOf2.default)(ExtendableError)).call(this, message));
	
	        _this.name = _this.constructor.name;
	        _this.message = message;
	        // Error.captureStackTrace(this, this.constructor.name);
	        return _this;
	    }
	
	    return ExtendableError;
	}(Error);
	
	/**
	 * Main error class for SDK related errors - see {@link ErrorCode} for error codes
	 */
	
	
	var LDSDKError = function (_ExtendableError) {
	    (0, _inherits3.default)(LDSDKError, _ExtendableError);
	    (0, _createClass3.default)(LDSDKError, null, [{
	        key: "deviceError",
	
	
	        /**
	         * Factory method for creating an error instance to be thrown.
	         *
	         * @param {number} errorCode - see {@link ErrorCode} for valid error codes
	         * @param {string} message - The message for the error
	         * @return {LDSDKError}
	         */
	        value: function deviceError(errorCode, message) {
	            return new LDSDKError(message, errorCode, null);
	        }
	
	        /**
	         * Constructor
	         * @param {string} message - The message for the error
	         * @param {number} errorCode - see {@link ErrorCode} for valid error codes
	         */
	
	    }]);
	
	    function LDSDKError(message, errorCode) {
	        (0, _classCallCheck3.default)(this, LDSDKError);
	
	        var _this2 = (0, _possibleConstructorReturn3.default)(this, (LDSDKError.__proto__ || (0, _getPrototypeOf2.default)(LDSDKError)).call(this, message));
	
	        _this2.errorCode = null;
	
	        _this2.errorCode = errorCode;
	        return _this2;
	    }
	
	    /**
	     * Get the error code
	     * @return {number} - see {@link ErrorCode} for the error types
	     */
	
	
	    (0, _createClass3.default)(LDSDKError, [{
	        key: "getErrorCode",
	        value: function getErrorCode() {
	            return this.errorCode;
	        }
	
	        /**
	         * User readable (loggable) string representation of the error
	         * @return {string}
	         */
	
	    }, {
	        key: "toString",
	        value: function toString() {
	            return this.name + " (code: " + this.getErrorCode() + "): " + this.message;
	        }
	    }]);
	    return LDSDKError;
	}(ExtendableError);
	
	/**
	 * Error for internal errors in the SDK
	 */
	
	
	exports.default = LDSDKError;
	
	var LDKSDKInternalError = exports.LDKSDKInternalError = function (_LDSDKError) {
	    (0, _inherits3.default)(LDKSDKInternalError, _LDSDKError);
	
	    function LDKSDKInternalError(message) {
	        (0, _classCallCheck3.default)(this, LDKSDKInternalError);
	        return (0, _possibleConstructorReturn3.default)(this, (LDKSDKInternalError.__proto__ || (0, _getPrototypeOf2.default)(LDKSDKInternalError)).call(this, message, ErrorCode.INTERNAL_ERROR));
	    }
	
	    return LDKSDKInternalError;
	}(LDSDKError);
	
	/**
	 * Error to be thrown when connection attempt times out
	 */
	
	
	var LDKSDKBluetoothConnectionTimeout = exports.LDKSDKBluetoothConnectionTimeout = function (_LDSDKError2) {
	    (0, _inherits3.default)(LDKSDKBluetoothConnectionTimeout, _LDSDKError2);
	
	    function LDKSDKBluetoothConnectionTimeout(message) {
	        (0, _classCallCheck3.default)(this, LDKSDKBluetoothConnectionTimeout);
	        return (0, _possibleConstructorReturn3.default)(this, (LDKSDKBluetoothConnectionTimeout.__proto__ || (0, _getPrototypeOf2.default)(LDKSDKBluetoothConnectionTimeout)).call(this, message, ErrorCode.BLUETOOTH_CONNECTION_TIMEOUT));
	    }
	
	    return LDKSDKBluetoothConnectionTimeout;
	}(LDSDKError);
	
	/**
	 * Error to be thrown when connection fails
	 */
	
	
	var LDKSDKBluetoothConnectionError = exports.LDKSDKBluetoothConnectionError = function (_LDSDKError3) {
	    (0, _inherits3.default)(LDKSDKBluetoothConnectionError, _LDSDKError3);
	
	    function LDKSDKBluetoothConnectionError(message) {
	        (0, _classCallCheck3.default)(this, LDKSDKBluetoothConnectionError);
	        return (0, _possibleConstructorReturn3.default)(this, (LDKSDKBluetoothConnectionError.__proto__ || (0, _getPrototypeOf2.default)(LDKSDKBluetoothConnectionError)).call(this, message, ErrorCode.BLUETOOTH_CONNECTION_ERROR));
	    }
	
	    return LDKSDKBluetoothConnectionError;
	}(LDSDKError);
	
	/**
	 * Error to be thrown when the firmware version reported by the hub is not supported by the SDK
	 */
	
	
	var LDKSDKBluetoothUnsupportedFirmwareVersion = exports.LDKSDKBluetoothUnsupportedFirmwareVersion = function (_LDSDKError4) {
	    (0, _inherits3.default)(LDKSDKBluetoothUnsupportedFirmwareVersion, _LDSDKError4);
	
	    function LDKSDKBluetoothUnsupportedFirmwareVersion(message) {
	        (0, _classCallCheck3.default)(this, LDKSDKBluetoothUnsupportedFirmwareVersion);
	        return (0, _possibleConstructorReturn3.default)(this, (LDKSDKBluetoothUnsupportedFirmwareVersion.__proto__ || (0, _getPrototypeOf2.default)(LDKSDKBluetoothUnsupportedFirmwareVersion)).call(this, message, ErrorCode.BLUETOOTH_UNSUPPORTED_FIRMWARE_VERSION));
	    }
	
	    return LDKSDKBluetoothUnsupportedFirmwareVersion;
	}(LDSDKError);
	
	/**
	 * Error to be thrown if the service uuid is not know to the SDK
	 */
	
	
	var LDKSDKBluetoothUnknownServiceUuid = exports.LDKSDKBluetoothUnknownServiceUuid = function (_LDSDKError5) {
	    (0, _inherits3.default)(LDKSDKBluetoothUnknownServiceUuid, _LDSDKError5);
	
	    function LDKSDKBluetoothUnknownServiceUuid(message) {
	        (0, _classCallCheck3.default)(this, LDKSDKBluetoothUnknownServiceUuid);
	        return (0, _possibleConstructorReturn3.default)(this, (LDKSDKBluetoothUnknownServiceUuid.__proto__ || (0, _getPrototypeOf2.default)(LDKSDKBluetoothUnknownServiceUuid)).call(this, message, ErrorCode.BLUETOOTH_UNKNOWN_SERVICE_UUID));
	    }
	
	    return LDKSDKBluetoothUnknownServiceUuid;
	}(LDSDKError);
	
	/**
	 * Error to be thrown if BLE characteristics for the hub is missing
	 */
	
	
	var LDKSDKBluetoothMissingCharacteristics = exports.LDKSDKBluetoothMissingCharacteristics = function (_LDSDKError6) {
	    (0, _inherits3.default)(LDKSDKBluetoothMissingCharacteristics, _LDSDKError6);
	
	    function LDKSDKBluetoothMissingCharacteristics(message) {
	        (0, _classCallCheck3.default)(this, LDKSDKBluetoothMissingCharacteristics);
	        return (0, _possibleConstructorReturn3.default)(this, (LDKSDKBluetoothMissingCharacteristics.__proto__ || (0, _getPrototypeOf2.default)(LDKSDKBluetoothMissingCharacteristics)).call(this, message, ErrorCode.BLUETOOTH_MISSING_CHARACTERISTICS));
	    }
	
	    return LDKSDKBluetoothMissingCharacteristics;
	}(LDSDKError);
	
	/**
	 * Error to be thrown if the properties for the characteristic are invalid
	 */
	
	
	var LDKSDKBluetoothInvalidCharacteristicProperties = exports.LDKSDKBluetoothInvalidCharacteristicProperties = function (_LDSDKError7) {
	    (0, _inherits3.default)(LDKSDKBluetoothInvalidCharacteristicProperties, _LDSDKError7);
	
	    function LDKSDKBluetoothInvalidCharacteristicProperties(message) {
	        (0, _classCallCheck3.default)(this, LDKSDKBluetoothInvalidCharacteristicProperties);
	        return (0, _possibleConstructorReturn3.default)(this, (LDKSDKBluetoothInvalidCharacteristicProperties.__proto__ || (0, _getPrototypeOf2.default)(LDKSDKBluetoothInvalidCharacteristicProperties)).call(this, message, ErrorCode.BLUETOOTH_INVALID_CHARACTERISTIC_PROPERTIES));
	    }
	
	    return LDKSDKBluetoothInvalidCharacteristicProperties;
	}(LDSDKError);

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _is = __webpack_require__(127);
	
	var _is2 = _interopRequireDefault(_is);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by frj on 22/02/16.
	 */
	/**
	 * @ignore Internal use only
	 */
	var SimpleList = function () {
	    function SimpleList() {
	        (0, _classCallCheck3.default)(this, SimpleList);
	
	        this.simpleList = [];
	    }
	
	    (0, _createClass3.default)(SimpleList, [{
	        key: "add",
	        value: function add(item) {
	            this.simpleList.push(item);
	        }
	    }, {
	        key: "push",
	        value: function push(item) {
	            this.simpleList.push(item);
	        }
	    }, {
	        key: "addAll",
	        value: function addAll(copyFrom) {
	            for (var i = 0; i < copyFrom.length; i++) {
	                this.add(copyFrom[i]);
	            }
	        }
	    }, {
	        key: "get",
	        value: function get(idx) {
	            if (idx < this.length() && idx >= 0) {
	                return this.simpleList[idx];
	            }
	            return null; // ...or throw error
	        }
	    }, {
	        key: "splice",
	        value: function splice(start, deleteCount) {
	            return this.simpleList.splice(start, deleteCount);
	        }
	    }, {
	        key: "remove",
	        value: function remove(item) {
	            var idxToRemove = -1;
	            for (var i = 0; i < this.simpleList.length; i++) {
	                if ((0, _is2.default)(item, this.simpleList[i])) {
	                    idxToRemove = i;
	                }
	            }
	            // const idx = this.simpleList.indexOf(item);
	            if (idxToRemove >= 0) {
	                this.simpleList.splice(idxToRemove, 1);
	            }
	        }
	    }, {
	        key: "length",
	        value: function length() {
	            return this.simpleList.length;
	        }
	    }, {
	        key: "size",
	        value: function size() {
	            return this.length();
	        }
	    }, {
	        key: "sort",
	        value: function sort(compareFunction) {
	            this.simpleList.sort(compareFunction);
	        }
	    }]);
	    return SimpleList;
	}();
	
	exports.default = SimpleList;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by frj on 11/02/16.
	 */
	
	/**
	 * The DataFormat holds information about the format data is communicated for a given service
	 */
	var DataFormat = function () {
	  (0, _createClass3.default)(DataFormat, null, [{
	    key: 'create',
	
	
	    /**
	     * Create and initialize a new instance of an DataFormat.
	     * <p/>
	     * Example: When a tilt sensor is in mode 'angle' it will create readings of in the x, y and z-dimension. If the mode is set to SI each
	     * angle will be a float representing with a value between 0 and 90 degrees. To create a data set that tells the SDK how to interpret values
	     * for til tilt sensor in this mode you would write.
	     * <p/>
	     * <code>DataFormat tiltSensorFormat = DataFormat.create('Angle', 0, InputFormatUnit.SI, 3, 4);</code>
	     *
	     * @param {string} modeName         The name of the mode
	     * @param {number} mode             The sensor mode
	     * @param {number} unit             The sensor unit - see {@link InputFormatUnit} for values supported
	     * @param {number} numberOfBytes    The number of bytes in a data set
	     * @param {number} numberOfDataSets The number of data sets
	     *
	     * @return {DataFormat}
	     */
	    value: function create(modeName, mode, unit, numberOfBytes, numberOfDataSets) {
	      return new DataFormat(modeName, mode, unit, numberOfBytes, numberOfDataSets);
	    }
	
	    /**
	     * @ignore
	     *
	     * @param {string} modeName
	     * @param {number} mode
	     * @param {number} unit
	     * @param {number} numberOfBytes
	     * @param {number} numberOfDataSets
	     */
	
	  }]);
	
	  function DataFormat(modeName, mode, unit, numberOfBytes, numberOfDataSets) {
	    (0, _classCallCheck3.default)(this, DataFormat);
	
	    this.modeName = modeName;
	    this.mode = mode;
	    this.unit = unit;
	    this.dataSetSize = numberOfBytes;
	    this.dataSetCount = numberOfDataSets;
	  }
	
	  /**
	   * Get the mode name
	   * @return {*}
	   */
	
	
	  (0, _createClass3.default)(DataFormat, [{
	    key: 'getModeName',
	    value: function getModeName() {
	      return this.modeName;
	    }
	
	    /**
	     * Get the mode number
	     * @return {number|*}
	     */
	
	  }, {
	    key: 'getMode',
	    value: function getMode() {
	      return this.mode;
	    }
	
	    /**
	     * Get the format unit - see {@link InputFormatUnit} for values supported
	     * @return {number|*}
	     */
	
	  }, {
	    key: 'getUnit',
	    value: function getUnit() {
	      return this.unit;
	    }
	
	    /**
	     * Get the data set size
	     * @return {number|*}
	     */
	
	  }, {
	    key: 'getDataSetSize',
	    value: function getDataSetSize() {
	      return this.dataSetSize;
	    }
	
	    /**
	     * Get the data set count
	     * @return {number|*}
	     */
	
	  }, {
	    key: 'getDataSetCount',
	    value: function getDataSetCount() {
	      return this.dataSetCount;
	    }
	
	    /**
	     * Get a string representation of the DataFormat for logging
	     * @return {string}
	     */
	
	  }, {
	    key: 'toString',
	    value: function toString() {
	      return 'DataFormat{' + 'modeName=' + this.modeName + ', unit=' + this.unit + ', dataSetSize=' + this.dataSetSize + ', dataSetCount=' + this.dataSetCount + '}';
	    }
	  }]);
	  return DataFormat;
	}();
	
	exports.default = DataFormat;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getPrototypeOf = __webpack_require__(5);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(7);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(6);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _BaseServiceDefinition = __webpack_require__(36);
	
	var _BaseServiceDefinition2 = _interopRequireDefault(_BaseServiceDefinition);
	
	var _CharacteristicDefinition = __webpack_require__(38);
	
	var _CharacteristicDefinition2 = _interopRequireDefault(_CharacteristicDefinition);
	
	var _UuidHelper = __webpack_require__(11);
	
	var _UuidHelper2 = _interopRequireDefault(_UuidHelper);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var DeviceServiceDefinition = function (_BaseServiceDefinitio) {
	    (0, _inherits3.default)(DeviceServiceDefinition, _BaseServiceDefinitio);
	
	    function DeviceServiceDefinition() {
	        (0, _classCallCheck3.default)(this, DeviceServiceDefinition);
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, (DeviceServiceDefinition.__proto__ || (0, _getPrototypeOf2.default)(DeviceServiceDefinition)).call(this));
	
	        _this.deviceName = null;
	        _this.attachedIO = null;
	        _this.deviceButton = null;
	        _this.lowVoltageAlert = null;
	        _this.disconnect = null;
	        return _this;
	    }
	
	    (0, _createClass3.default)(DeviceServiceDefinition, [{
	        key: 'init',
	        value: function init() {
	            this.serviceUUID = _UuidHelper2.default.getLegoUuid(DeviceServiceDefinition.HUB_SERVICE_16_BIT_UUID);
	            this.serviceName = 'DeviceService';
	
	            this.deviceName = new _CharacteristicDefinition2.default('DeviceName', this, _UuidHelper2.default.getLegoUuid(DeviceServiceDefinition.HUB_CHARACTERISTIC_NAME_UUID), true, 0 /* (BluetoothHelper.Properties.PROPERTY_WRITE.ordinal() | BluetoothHelper.Properties.PROPERTY_WRITE_NO_RESPONSE.ordinal() | BluetoothHelper.Properties.PROPERTY_READ.ordinal()) */
	            , 0, 0 /* (BluetoothHelper.Permissions.PERMISSION_WRITE.ordinal() |
	                   BluetoothHelper.Permissions.PERMISSION_READ.ordinal())*/);
	
	            this.attachedIO = new _CharacteristicDefinition2.default('AttachedIO', this, _UuidHelper2.default.getLegoUuid(DeviceServiceDefinition.HUB_CHARACTERISTIC_ATTACHED_IO), true, 0 /* (BluetoothHelper.Properties.PROPERTY_NOTIFY.ordinal()) */
	            , 0, 0 /* (BluetoothHelper.Permissions.PERMISSION_READ.ordinal())*/);
	
	            this.deviceButton = new _CharacteristicDefinition2.default('DeviceButton', this, _UuidHelper2.default.getLegoUuid(DeviceServiceDefinition.HUB_CHARACTERISTIC_BUTTON_STATE), true, 0 /* (BluetoothHelper.Properties.PROPERTY_READ.ordinal() |
	                                                                                                                                                                                                BluetoothHelper.Properties.PROPERTY_NOTIFY.ordinal()) */
	            , 0, 0 /* (BluetoothHelper.Permissions.PERMISSION_READ.ordinal())*/);
	
	            this.lowVoltageAlert = new _CharacteristicDefinition2.default('LowVoltageAlert', this, _UuidHelper2.default.getLegoUuid(DeviceServiceDefinition.HUB_CHARACTERISTIC_LOW_VOLTAGE_ALERT), false, 0 /* (BluetoothHelper.Properties.PROPERTY_READ.ordinal() |
	                                                                                                                                                                                                            BluetoothHelper.Properties.PROPERTY_NOTIFY.ordinal()) */
	            , 0, 0 /* (BluetoothHelper.Permissions.PERMISSION_READ.ordinal())*/);
	            this.disconnect = new _CharacteristicDefinition2.default('Disconnect', this, _UuidHelper2.default.getLegoUuid(DeviceServiceDefinition.HUB_CHARACTERISTIC_DISCONNECT), true, 0, 0, 0);
	
	            this.characteristicDefinitions.add(this.deviceName);
	            this.characteristicDefinitions.add(this.attachedIO);
	            this.characteristicDefinitions.add(this.deviceButton);
	            this.characteristicDefinitions.add(this.lowVoltageAlert);
	            this.characteristicDefinitions.add(this.disconnect);
	        }
	    }, {
	        key: 'getDeviceName',
	        value: function getDeviceName() {
	            return this.deviceName;
	        }
	    }, {
	        key: 'getAttachedIO',
	        value: function getAttachedIO() {
	            return this.attachedIO;
	        }
	    }, {
	        key: 'getDeviceButton',
	        value: function getDeviceButton() {
	            return this.deviceButton;
	        }
	    }, {
	        key: 'getLowVoltageAlert',
	        value: function getLowVoltageAlert() {
	            return this.lowVoltageAlert;
	        }
	    }, {
	        key: 'getDisconnect',
	        value: function getDisconnect() {
	            return this.disconnect;
	        }
	    }, {
	        key: 'getShortServiceUUID',
	        value: function getShortServiceUUID() {
	            return DeviceServiceDefinition.HUB_SERVICE_16_BIT_UUID;
	        }
	    }, {
	        key: 'getServiceUuid',
	        value: function getServiceUuid() {
	            return _UuidHelper2.default.getLegoUuid(this.getShortServiceUUID());
	        }
	    }], [{
	        key: 'getInstance',
	        value: function getInstance() {
	            if (DeviceServiceDefinition.instance === null) {
	                DeviceServiceDefinition.instance = new DeviceServiceDefinition();
	                DeviceServiceDefinition.instance.init();
	            }
	            return DeviceServiceDefinition.instance;
	        }
	    }]);
	    return DeviceServiceDefinition;
	}(_BaseServiceDefinition2.default); /**
	                                     * Created by frj on 20/02/16.
	                                     */
	
	
	DeviceServiceDefinition.HUB_SERVICE_16_BIT_UUID = '1523';
	DeviceServiceDefinition.HUB_CHARACTERISTIC_NAME_UUID = '1524';
	DeviceServiceDefinition.HUB_CHARACTERISTIC_COLOR = '1525';
	DeviceServiceDefinition.HUB_CHARACTERISTIC_BUTTON_STATE = '1526';
	DeviceServiceDefinition.HUB_CHARACTERISTIC_ATTACHED_IO = '1527';
	DeviceServiceDefinition.HUB_CHARACTERISTIC_LOW_VOLTAGE_ALERT = '1528';
	DeviceServiceDefinition.HUB_CHARACTERISTIC_DISCONNECT = '152e';
	DeviceServiceDefinition.instance = null;
	exports.default = DeviceServiceDefinition;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getPrototypeOf = __webpack_require__(5);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(7);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(6);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _BaseServiceDefinition = __webpack_require__(36);
	
	var _BaseServiceDefinition2 = _interopRequireDefault(_BaseServiceDefinition);
	
	var _CharacteristicDefinition = __webpack_require__(38);
	
	var _CharacteristicDefinition2 = _interopRequireDefault(_CharacteristicDefinition);
	
	var _UuidHelper = __webpack_require__(11);
	
	var _UuidHelper2 = _interopRequireDefault(_UuidHelper);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var IOServiceDefinition = function (_BaseServiceDefinitio) {
	    (0, _inherits3.default)(IOServiceDefinition, _BaseServiceDefinitio);
	
	    function IOServiceDefinition() {
	        (0, _classCallCheck3.default)(this, IOServiceDefinition);
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, (IOServiceDefinition.__proto__ || (0, _getPrototypeOf2.default)(IOServiceDefinition)).call(this));
	
	        _this.inputValue = null;
	        _this.inputFormat = null;
	        _this.inputCommand = null;
	        _this.outputCommand = null;
	        return _this;
	    }
	
	    (0, _createClass3.default)(IOServiceDefinition, [{
	        key: 'init',
	        value: function init() {
	            this.serviceUUID = _UuidHelper2.default.getLegoUuid(IOServiceDefinition.INPUT_SERVICE_UUID);
	            this.serviceName = 'IOService';
	
	            this.inputValue = new _CharacteristicDefinition2.default('InputValue', this, _UuidHelper2.default.getLegoUuid(IOServiceDefinition.CHARACTERISTIC_INPUT_VALUE_UUID), true, 0 /* (BluetoothHelper.Properties.PROPERTY_NOTIFY.ordinal()) */
	            , 0, 0 /* (BluetoothHelper.Permissions.PERMISSION_READ.ordinal()) */);
	
	            this.inputFormat = new _CharacteristicDefinition2.default('InputFormat', this, _UuidHelper2.default.getLegoUuid(IOServiceDefinition.CHARACTERISTIC_INPUT_FORMAT_UUID), true, 0 /* (BluetoothHelper.Properties.PROPERTY_NOTIFY.ordinal()) */
	            , 0, 0 /* (BluetoothHelper.Permissions.PERMISSION_READ.ordinal()) */);
	
	            this.inputCommand = new _CharacteristicDefinition2.default('InputCommand', this, _UuidHelper2.default.getLegoUuid(IOServiceDefinition.CHARACTERISTIC_INPUT_COMMAND_UUID), true, 0 /* (BluetoothHelper.Properties.PROPERTY_WRITE_NO_RESPONSE.ordinal() |
	                                                                                                                                                                                              BluetoothHelper.Properties.PROPERTY_WRITE.ordinal()) */
	            , 0, 0 /* (BluetoothHelper.Permissions.PERMISSION_READ.ordinal()) */);
	
	            this.outputCommand = new _CharacteristicDefinition2.default('OutputCommand', this, _UuidHelper2.default.getLegoUuid(IOServiceDefinition.CHARACTERISTIC_OUTPUT_COMMAND_UUID), true, 0 /* (BluetoothHelper.Properties.PROPERTY_WRITE_NO_RESPONSE.ordinal() |
	                                                                                                                                                                                                 BluetoothHelper.Properties.PROPERTY_WRITE.ordinal()) */
	            , 0, 0 /* (BluetoothHelper.Permissions.PERMISSION_READ.ordinal()) */);
	
	            this.characteristicDefinitions.add(this.inputValue);
	            this.characteristicDefinitions.add(this.inputFormat);
	            this.characteristicDefinitions.add(this.inputCommand);
	            this.characteristicDefinitions.add(this.outputCommand);
	        }
	    }, {
	        key: 'getInputValue',
	        value: function getInputValue() {
	            return this.inputValue;
	        }
	    }, {
	        key: 'getInputFormat',
	        value: function getInputFormat() {
	            return this.inputFormat;
	        }
	    }, {
	        key: 'getInputCommand',
	        value: function getInputCommand() {
	            return this.inputCommand;
	        }
	    }, {
	        key: 'getOutputCommand',
	        value: function getOutputCommand() {
	            return this.outputCommand;
	        }
	    }], [{
	        key: 'getInstance',
	        value: function getInstance() {
	            if (IOServiceDefinition.instance === null) {
	                IOServiceDefinition.instance = new IOServiceDefinition();
	                IOServiceDefinition.instance.init();
	            }
	            return IOServiceDefinition.instance;
	        }
	    }]);
	    return IOServiceDefinition;
	}(_BaseServiceDefinition2.default); /**
	                                     * Created by frj on 20/02/16.
	                                     */
	
	
	IOServiceDefinition.INPUT_SERVICE_UUID = '4F0E';
	IOServiceDefinition.CHARACTERISTIC_INPUT_VALUE_UUID = '1560';
	IOServiceDefinition.CHARACTERISTIC_INPUT_FORMAT_UUID = '1561';
	IOServiceDefinition.CHARACTERISTIC_INPUT_COMMAND_UUID = '1563';
	IOServiceDefinition.CHARACTERISTIC_OUTPUT_COMMAND_UUID = '1565';
	IOServiceDefinition.instance = null;
	exports.default = IOServiceDefinition;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _iterator = __webpack_require__(130);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _symbol = __webpack_require__(129);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(39)
	  , TAG = __webpack_require__(8)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ }),
/* 51 */
/***/ (function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(29)
	  , call        = __webpack_require__(157)
	  , isArrayIter = __webpack_require__(156)
	  , anObject    = __webpack_require__(20)
	  , toLength    = __webpack_require__(76)
	  , getIterFn   = __webpack_require__(112)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ }),
/* 53 */
/***/ (function(module, exports) {

	module.exports = true;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(20)
	  , dPs         = __webpack_require__(162)
	  , enumBugKeys = __webpack_require__(67)
	  , IE_PROTO    = __webpack_require__(73)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(66)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(99).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(107)
	  , enumBugKeys = __webpack_require__(67);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ }),
/* 56 */
/***/ (function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ }),
/* 57 */
/***/ (function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _promise = __webpack_require__(12);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _regenerator = __webpack_require__(14);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _stringify = __webpack_require__(19);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _asyncToGenerator2 = __webpack_require__(13);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _map = __webpack_require__(9);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	var _UuidHelper = __webpack_require__(11);
	
	var _UuidHelper2 = _interopRequireDefault(_UuidHelper);
	
	var _StorageHelper = __webpack_require__(86);
	
	var _StorageHelper2 = _interopRequireDefault(_StorageHelper);
	
	var _LegoDeviceManagerImpl = __webpack_require__(31);
	
	var _LegoDeviceManagerImpl2 = _interopRequireDefault(_LegoDeviceManagerImpl);
	
	var _LegoDeviceImpl = __webpack_require__(27);
	
	var _TimerUtil = __webpack_require__(87);
	
	var _TimerUtil2 = _interopRequireDefault(_TimerUtil);
	
	var _StringUtils = __webpack_require__(21);
	
	var _StringUtils2 = _interopRequireDefault(_StringUtils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * The native Bluetooth Device object returned by the operations of the chrome.bluetooth.* functions.
	 *
	 * @external {NativeDevice} https://developer.chrome.com/apps/bluetooth#type-Device
	 * @see  https://developer.chrome.com/apps/bluetooth#type-Device
	 */
	
	/**
	 * The native Service object returned by the operations of the chrome.bluetooth.getService and getServices functions.
	 *
	 * @external {NativeService} https://developer.chrome.com/apps/bluetoothLowEnergy#type-Service
	 * @see  https://developer.chrome.com/apps/bluetoothLowEnergy#type-Service
	 */
	
	/**
	 * The native Characteristic object returned by the operations of the chrome.bluetooth.getCharacteristic and
	 * getCharacteristics functions.
	 *
	 * @external {NativeCharacteristic} https://developer.chrome.com/apps/bluetoothLowEnergy#type-Characteristic
	 * @see  https://developer.chrome.com/apps/bluetoothLowEnergy#type-Characteristic
	 */
	
	/**
	 * The native Descriptor object returned by the operations of the chrome.bluetooth.getDescriptor and
	 * getDescriptors functions.
	 *
	 * @external {NativeDescriptor} https://developer.chrome.com/apps/bluetoothLowEnergy#type-Descriptor
	 * @see  https://developer.chrome.com/apps/bluetoothLowEnergy#type-Descriptor
	 */
	
	/**
	 * A TypedArray object describes an array-like view of an underlying binary data buffer. There is no global
	 * property named TypedArray, nor is there a directly visible TypedArray constructor.  Instead, there are a
	 * number of different global properties, whose values are typed array constructors for specific element
	 * types, listed below. On the following pages you will find common properties and methods that can be used
	 * with any typed array containing elements of any type.
	 *
	 * @external {TypedArray} https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/TypedArray
	 * @see  https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/TypedArray
	 */
	
	/**
	 * The ArrayBuffer object is used to represent a generic, fixed-length raw binary data buffer. You cannot directly
	 * manipulate the contents of an ArrayBuffer; instead, you create one of the typed array objects or a DataView
	 * object which represents the buffer in a specific format, and use that to read and write the contents of the buffer.
	 *
	 * @external {ArrayBuffer} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer
	 * @see  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer
	 */
	
	if (window && !window.previouslySeenLegoDevices) {
	    window.previouslySeenLegoDevices = new _map2.default();
	}
	
	/**
	 * @ignore For internal use
	 * This class wraps the native Bluetooth Device object
	 *
	 * See {@link NativeDevice}
	 *
	 * Created by frj on 22/02/16.
	 */
	
	var ChromeOsBluetoothDeviceWrapper = function () {
	
	    /**
	     * Creates a ChromeOsBluetoothDeviceWrapper instance that wraps the supplied native device
	     * @param {NativeDevice} bluetoothDevice
	     */
	
	
	    /**
	     * @private
	     * @type {boolean}
	     */
	
	
	    /**
	     * @private
	     * @type {|null}
	     */
	    function ChromeOsBluetoothDeviceWrapper(bluetoothDevice) {
	        (0, _classCallCheck3.default)(this, ChromeOsBluetoothDeviceWrapper);
	        this.chromeBluetoothDevice = null;
	        this.rssi = -1;
	        this.pairing = false;
	        this.connectCallback = null;
	
	        /**
	         * @private
	         * Native Bluetooth Device object
	         * @type {NativeDevice}
	         */
	        this.chromeBluetoothDevice = bluetoothDevice;
	    }
	
	    /**
	     * Get the active connect callback
	     * @return {*}
	     */
	
	
	    /**
	     * @private
	     * @type {object}
	     */
	
	
	    /**
	     * @private
	     * @type {number}
	     */
	
	
	    (0, _createClass3.default)(ChromeOsBluetoothDeviceWrapper, [{
	        key: 'getConnectCallback',
	        value: function getConnectCallback() {
	            return this.connectCallback;
	        }
	
	        /**
	         * Get the wrapped native device
	         * @return {NativeDevice}
	         */
	
	    }, {
	        key: 'getDevice',
	        value: function getDevice() {
	            return this.chromeBluetoothDevice;
	        }
	
	        /**
	         * Get the name of the wrapped native device
	         * @return {string} Name of the device
	         */
	
	    }, {
	        key: 'getName',
	        value: function getName() {
	            return this.chromeBluetoothDevice.name;
	        }
	
	        /**
	         * Get the MAC address of the wrapped native device
	         * @return {string} MAC address
	         */
	
	    }, {
	        key: 'getAddress',
	        value: function getAddress() {
	            return this.chromeBluetoothDevice.address;
	        }
	
	        /**
	         * The rssi values are only present while scanning (and only since very new Chrome versions)
	         * @returns {number}
	         */
	
	    }, {
	        key: 'getRssi',
	        value: function getRssi() {
	            if (this.chromeBluetoothDevice.hasOwnProperty('inquiryRssi') && this.rssi === -1) {
	                /**
	                 * @private
	                 * The received signal strength, in dBm. This field is avaliable and valid only during discovery. Outside of discovery it's value is not specified.
	                 * @type {number}
	                 */
	                this.rssi = this.chromeBluetoothDevice.inquiryRssi;
	                return this.rssi;
	            } else if (this.rssi !== -1) {
	                return this.rssi;
	            }
	            return -1;
	        }
	
	        /**
	         * Checks if the UUIDs for this device matches the LEGO uuid.
	         * Does caching of mac addresses in order to resolve LECQA-239 and WQ-331
	         * @return {boolean} True if this is a LEGO device, false if it is not
	         */
	
	    }, {
	        key: 'isLegoDevice',
	        value: function isLegoDevice() {
	            var _this = this;
	
	            var device = this.getDevice();
	
	            if (this.getUuids().length > 0) {
	                return _UuidHelper2.default.isLEGODevice(this);
	            }
	
	            if (this.getUuids().length === 0) {
	
	                if (_LegoDeviceManagerImpl2.default.getInstance().config.usePreviouslySeenCacheAsFallbackFilter) {
	                    if (window && window.previouslySeenLegoDevices && window.previouslySeenLegoDevices.has && !window.previouslySeenLegoDevices.has(this.getAddress())) {
	                        // LECQA-239/WQ-331 - This is to avoid forcing the user to have to reboot in order to discover his hub when
	                        // the uuid list has been truncated after a disconnect, and the user has closed and relaunched WeDo.
	                        // Note: The device is saved to local storage when connecting - see connectGatt.
	                        setTimeout((0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
	                            return _regenerator2.default.wrap(function _callee$(_context) {
	                                while (1) {
	                                    switch (_context.prev = _context.next) {
	                                        case 0:
	                                            _StorageHelper2.default.getFromLocalStorage(_this.getAddress()).then(function (device) {
	                                                if (device) {
	                                                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                                        _LDSDKLogger2.default.debug('Storage - Fetched previous device from local storage - adding to memory map - key="' + _this.getAddress() + '": ' + (0, _stringify2.default)(device));
	                                                    }
	                                                    window.previouslySeenLegoDevices.set(_this.getAddress(), device);
	                                                } else {
	                                                    _StorageHelper2.default.getFromSyncStorage(_this.getAddress()).then(function (device) {
	                                                        if (device) {
	                                                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                                                _LDSDKLogger2.default.debug('Storage - Fetched previous device from sync storage - adding to memory map - key="' + _this.getAddress() + '": ' + (0, _stringify2.default)(device));
	                                                            }
	                                                            window.previouslySeenLegoDevices.set(_this.getAddress(), device);
	                                                        }
	                                                    }).catch(function () {
	                                                        if (_LDSDKLogger2.default.isErrorEnabled()) {
	                                                            _LDSDKLogger2.default.error('Storage - Failed getting "' + _this.getAddress() + '" from sync storage', chrome.runtime.lastError);
	                                                        }
	                                                    });
	                                                }
	                                            }).catch(function () {
	                                                if (_LDSDKLogger2.default.isErrorEnabled()) {
	                                                    _LDSDKLogger2.default.error('Storage - Failed getting "' + _this.getAddress() + '" from local storage', chrome.runtime.lastError);
	                                                }
	                                            });
	
	                                        case 1:
	                                        case 'end':
	                                            return _context.stop();
	                                    }
	                                }
	                            }, _callee, _this);
	                        })), 0);
	                    }
	
	                    if (window && window.previouslySeenLegoDevices && window.previouslySeenLegoDevices.has && window.previouslySeenLegoDevices.has(this.getAddress())) {
	                        return true;
	                    }
	                }
	
	                if (_LegoDeviceManagerImpl2.default.getInstance().config.filterFallbackEnabled) {
	                    var inquiryTxPower = device.inquiryTxPower || 0;
	                    if (device.name !== 'Unknown or Unsupported Device (' + this.getAddress() + ')' && device.deviceClass === 0 && inquiryTxPower === 0) {
	                        // LECQA-239/WQ-331 - This is to avoid forcing the user to have to reboot in order to discover his hub when the uuid list has been truncated after a disconnect, and the user has closed and relaunched WeDo
	                        return true;
	                    }
	                }
	
	                if (typeof window.filterLegoDevice === 'function') {
	                    if (window.filterLegoDevice(this.getDevice())) {
	                        return true;
	                    }
	                }
	            }
	
	            return false;
	        }
	
	        /**
	         * Get the uuids for the wrapped native bluetooth device
	         * @return {Array.<string>} Array of uuids
	         */
	
	    }, {
	        key: 'getUuids',
	        value: function getUuids() {
	            return this.chromeBluetoothDevice.uuids || [];
	        }
	
	        /**
	         * Check if the hub is currently pairing with Chrome
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'isPairing',
	        value: function isPairing() {
	            return this.pairing;
	        }
	
	        /**
	         * @private
	         * @param {NativeDevice} nativeDevice
	         */
	
	    }, {
	        key: 'updateNativeDevice',
	        value: function updateNativeDevice(nativeDevice) {
	            // Detect when pairing is going on
	            if (!this.chromeBluetoothDevice.paired && nativeDevice.paired) {
	                /**
	                 * @private
	                 */
	                this.pairing = true;
	            } else {
	                /**
	                 * @private
	                 */
	                this.pairing = false;
	            }
	
	            if (this.chromeBluetoothDevice.paired !== nativeDevice.paired) {
	                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                    _LDSDKLogger2.default.debug(this.constructor.name + ' updateNativeDevice "paired". Old value: ' + this.chromeBluetoothDevice.paired + ', new value: ' + nativeDevice.paired);
	                }
	            }
	            /**
	             * @private
	             */
	            this.chromeBluetoothDevice.paired = nativeDevice.paired;
	
	            if (this.chromeBluetoothDevice.connected !== nativeDevice.connected) {
	                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                    _LDSDKLogger2.default.debug(this.constructor.name + ' updateNativeDevice "connected". Old value: ' + this.chromeBluetoothDevice.connected + ', new value: ' + nativeDevice.connected);
	                }
	            }
	            /**
	             * @private
	             */
	            this.chromeBluetoothDevice.connected = nativeDevice.connected;
	
	            if (this.chromeBluetoothDevice.connecting !== nativeDevice.connecting) {
	                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                    _LDSDKLogger2.default.debug(this.constructor.name + ' updateNativeDevice "connecting". Old value: ' + this.chromeBluetoothDevice.connecting + ', new value: ' + nativeDevice.connecting);
	                }
	            }
	            /**
	             * @private
	             */
	            this.chromeBluetoothDevice.connecting = nativeDevice.connecting;
	
	            if (this.chromeBluetoothDevice.connectable !== nativeDevice.connectable) {
	                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                    _LDSDKLogger2.default.debug(this.constructor.name + ' updateNativeDevice "connectable". Old value: ' + this.chromeBluetoothDevice.connectable + ', new value: ' + nativeDevice.connectable);
	                }
	            }
	            /**
	             * @private
	             */
	            this.chromeBluetoothDevice.connectable = nativeDevice.connectable;
	
	            /**
	             * @private
	             */
	            this.chromeBluetoothDevice.uuids = nativeDevice.uuids;
	
	            if (nativeDevice.hasOwnProperty('inquiryRssi')) {
	                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                    _LDSDKLogger2.default.debug(this.constructor.name + ' updateNativeDevice "inquiryRssi". Old value: ' + this.chromeBluetoothDevice.inquiryRssi + ', new value: ' + nativeDevice.inquiryRssi);
	                }
	                /**
	                 * @private
	                 */
	                this.chromeBluetoothDevice.inquiryRssi = nativeDevice.inquiryRssi;
	            } else {
	                if (this.chromeBluetoothDevice.hasOwnProperty('inquiryRssi')) {
	                    if (_LDSDKLogger2.default.isTraceEnabled()) {
	                        _LDSDKLogger2.default.debug(this.constructor.name + ' updateNativeDevice deleting "inquiryRssi". Old value:' + ' ' + this.chromeBluetoothDevice.inquiryRssi);
	                    }
	                    delete this.chromeBluetoothDevice.inquiryRssi;
	                }
	            }
	
	            if (this.chromeBluetoothDevice.name !== nativeDevice.name) {
	                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                    _LDSDKLogger2.default.debug(this.constructor.name + ' updateNativeDevice "name". Old value: ' + this.chromeBluetoothDevice.name + ', new value: ' + nativeDevice.name);
	                }
	            }
	            /**
	             * @private
	             */
	            this.chromeBluetoothDevice.name = nativeDevice.name;
	        }
	
	        /**
	         * Connects to the device
	         * @param {boolean} autoConnect  True for autoconnect, false otherwise
	         * @param {BluetoothDeviceCallback} bluetoothGattCallback
	         * @return {Promise} Resolves once connection completes, or rejects with an error message in case of an error
	         */
	
	    }, {
	        key: 'connectGatt',
	        value: function connectGatt(autoConnect, bluetoothGattCallback) {
	            var _this2 = this;
	
	            var self = this;
	            /**
	             * @private
	             */
	            this.connectCallback = bluetoothGattCallback;
	
	            return new _promise2.default(function (resolve, reject) {
	                chrome.bluetoothLowEnergy.connect(self.getAddress(), function () {
	                    if (chrome.runtime.lastError) {
	                        if ('Already connected' !== chrome.runtime.lastError.message) {
	                            _LDSDKLogger2.default.error('Failed to connect to ' + self.getName() + ': ' + chrome.runtime.lastError.message);
	                            return reject(chrome.runtime.lastError);
	                        }
	                    }
	                    if (_LDSDKLogger2.default.isInfoEnabled()) {
	                        _LDSDKLogger2.default.info('Connect succeeded - ' + self.getName() + ' (' + self.getAddress() + ')');
	                    }
	                    if (window && window.previouslySeenLegoDevices) {
	                        window.previouslySeenLegoDevices.set(self.getAddress(), self.getDevice());
	                        // LECQA-239/WQ-331 - We use a cached map - in order to be able to recognize LEGO devices that we have disconnected from, since they have an empty uuid list afterwards
	                    }
	                    return _StorageHelper2.default.saveToLocalStorage(self.getAddress(), self.getDevice()).then(function () {
	                        if (_LDSDKLogger2.default.isDebugEnabled()) {
	                            _LDSDKLogger2.default.debug('Storage - Saved "' + self.getAddress() + '" => (' + (0, _stringify2.default)(self.getDevice()) + ') to local storage');
	                        }
	                        return _StorageHelper2.default.saveToSyncStorage(self.getAddress(), self.getDevice()).then(function () {
	                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                _LDSDKLogger2.default.debug('Storage - Saved "' + self.getAddress() + '" => (' + (0, _stringify2.default)(self.getDevice()) + ') to sync storage');
	                            }
	                            return resolve();
	                        }).catch(function (err) {
	                            if (_LDSDKLogger2.default.isErrorEnabled()) {
	                                _LDSDKLogger2.default.error('Storage - Failed saving "' + self.getAddress() + '" to sync storage', err);
	                            }
	                        });
	                    }).catch(function (err) {
	                        if (_LDSDKLogger2.default.isErrorEnabled()) {
	                            _LDSDKLogger2.default.error('Storage - Failed saving "' + self.getAddress() + '" to local storage', err);
	                        }
	                    });
	                });
	            }).then(function () {
	                setTimeout((0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
	                    var legoBluetoothDeviceImpl;
	                    return _regenerator2.default.wrap(function _callee2$(_context2) {
	                        while (1) {
	                            switch (_context2.prev = _context2.next) {
	                                case 0:
	                                    // LWC-1548 - The initial fix where we moved the onConnectionStateChange(null, StateEnum.Interrogating) call to the onDevice seem to be very very slow on Chrome 52 and up. Reattempting the fix by inserting a delay after connect completes
	                                    legoBluetoothDeviceImpl = _LegoDeviceManagerImpl2.default.getInstance().getDevice(self.getAddress(), false);
	
	                                    if (!(legoBluetoothDeviceImpl && legoBluetoothDeviceImpl !== null && legoBluetoothDeviceImpl.connectState !== _LegoDeviceImpl.StateEnum.Interrogating)) {
	                                        _context2.next = 10;
	                                        break;
	                                    }
	
	                                    if (!(!self.isPairing() /* && wrappedDevice.getPaired() */ && !self.getConnecting() && self.getConnected())) {
	                                        _context2.next = 9;
	                                        break;
	                                    }
	
	                                    if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                        _LDSDKLogger2.default.info(self.constructor.name + '.connectGatt - changing state to Interrogating');
	                                    }
	                                    _context2.next = 6;
	                                    return bluetoothGattCallback.onConnectionStateChange(null, _LegoDeviceImpl.StateEnum.Interrogating);
	
	                                case 6:
	                                    return _context2.abrupt('return', _context2.sent);
	
	                                case 9:
	                                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                        _LDSDKLogger2.default.debug('The device is not yet ready for a connect');
	                                    }
	
	                                case 10:
	                                case 'end':
	                                    return _context2.stop();
	                            }
	                        }
	                    }, _callee2, _this2);
	                })), 500);
	            }).catch(function (err) {
	                _LDSDKLogger2.default.error('Failed to connect to ' + self.getName() + ': ' + err);
	                return _promise2.default.reject(err);
	            });
	        }
	    }, {
	        key: 'getConnected',
	        value: function getConnected() {
	            return this.chromeBluetoothDevice.connected;
	        }
	    }, {
	        key: 'getConnecting',
	        value: function getConnecting() {
	            return this.chromeBluetoothDevice.connecting;
	        }
	    }, {
	        key: 'getPaired',
	        value: function getPaired() {
	            if (this.chromeBluetoothDevice.hasOwnProperty('paired')) {
	                return this.chromeBluetoothDevice.paired;
	            }
	            return false;
	        }
	
	        /**
	         * Get isConnected based on the properties of the wrapped native Bluetooth Device.
	         * @return {bool} True if the device properties specify that it is connected, false otherwise.
	         */
	
	    }, {
	        key: 'isConnected',
	        value: function isConnected() {
	            return this.chromeBluetoothDevice && this.chromeBluetoothDevice !== null && !this.chromeBluetoothDevice.connecting && this.chromeBluetoothDevice.connected;
	        }
	
	        /**
	         * @ignore
	         *
	         * @return {Promise}
	         */
	
	    }, {
	        key: 'disconnect',
	        value: function disconnect() {
	            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                _LDSDKLogger2.default.info('Calling Chrome BLE API disconnect for ' + this.getName() + ' [' + this.getAddress() + ']');
	            }
	            var self = this;
	            return new _promise2.default(function (resolve, reject) {
	                chrome.bluetoothLowEnergy.disconnect(self.getAddress(), function () {
	                    if (chrome.runtime.lastError) {
	                        if (chrome.runtime.lastError.message !== 'Not connected') {
	                            return reject(chrome.runtime.lastError);
	                        }
	                    }
	                    return resolve();
	                });
	            });
	        }
	
	        /**
	         * Discover all the services for the device and return them as an array once the promise resolves.
	         * @return {Promise.<Array<NativeService>>} @see {@link NativeService}
	         */
	
	    }, {
	        key: 'discoverServices',
	        value: function discoverServices() {
	            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                _LDSDKLogger2.default.info('Calling Chrome BLE API getServices for ' + this.getName() + ' [' + this.getAddress() + ']');
	            }
	            var self = this;
	            return new _promise2.default(function (resolve, reject) {
	                chrome.bluetoothLowEnergy.getServices(self.getAddress(), function (services) {
	                    if (chrome.runtime.lastError) {
	                        if (_LDSDKLogger2.default.isErrorEnabled()) {
	                            _LDSDKLogger2.default.error('chrome.bluetoothLowEnergy.getServices failed: ', chrome.runtime.lastError.message);
	                        }
	                        return reject(chrome.runtime.lastError.message);
	                    }
	                    if (Array.isArray(services)) {
	                        if (services.length > 0) {
	                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                _LDSDKLogger2.default.debug('discoverServices: Got ' + services.length + ' services for device address ' + self.getAddress() + ' returned by chrome.bluetoothLowEnergy.getServices.');
	                            }
	                            return resolve(services);
	                        } else {
	                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                _LDSDKLogger2.default.debug('discoverServices: Empty list of services returned for device address ' + self.getAddress() + ' by chrome.bluetoothLowEnergy.getServices.');
	                            }
	                        }
	                    }
	                    return resolve(services);
	                });
	            }).catch(function (err) {
	                _LDSDKLogger2.default.error('discoverServices: Failed to getServices for ' + self.getName(), err);
	                return _promise2.default.reject(err);
	            });
	        }
	
	        /**
	         * Get the service that matches the service instance id on the device and return once the promise
	         * resolves.
	         * @param {string} instanceId - The instanceId for the service to retrieve
	         * @return {Promise.<NativeService>} @see {@link NativeService}
	         */
	
	    }, {
	        key: 'getService',
	        value: function getService(instanceId) {
	            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                _LDSDKLogger2.default.info('Calling Chrome BLE API getService for ' + this.getName() + ' [' + this.getAddress() + '] - service instanceId: ' + instanceId);
	            }
	            var self = this;
	            return new _promise2.default(function (resolve, reject) {
	                chrome.bluetoothLowEnergy.getService(instanceId, function (service) {
	                    if (chrome.runtime.lastError) {
	                        if (_LDSDKLogger2.default.isErrorEnabled()) {
	                            _LDSDKLogger2.default.error('chrome.bluetoothLowEnergy.getService failed: ', chrome.runtime.lastError.message);
	                        }
	                        return reject(chrome.runtime.lastError.message);
	                    }
	                    if (_LDSDKLogger2.default.isInfoEnabled()) {
	                        _LDSDKLogger2.default.info('Got service ' + _UuidHelper2.default.getUuid(service) + ' for instanceId: ' + instanceId);
	                    }
	                    return resolve(service);
	                });
	            }).catch(function (err) {
	                _LDSDKLogger2.default.error('Failed to getService with instanceId ' + instanceId + ' for ' + self.getName(), err.message);
	                return _promise2.default.reject(err);
	            });
	        }
	
	        /**
	         *
	         * @param {NativeCharacteristic} characteristic
	         * @return {Promise}
	         */
	
	    }, {
	        key: 'startCharacteristicNotification',
	        value: function startCharacteristicNotification(characteristic) {
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('Calling Chrome BLE API startCharacteristicNotifications for ' + _StringUtils2.default.getCharacteristicString(characteristic));
	            }
	            return new _promise2.default(function (resolve, reject) {
	                var startCharacteristicNotificationsTimer = _TimerUtil2.default.startTimer();
	                chrome.bluetoothLowEnergy.startCharacteristicNotifications(characteristic.instanceId, function () {
	                    if (chrome.runtime.lastError) {
	                        if (chrome.runtime.lastError.message === 'Already notifying') {
	                            return resolve(); // ignore Already notifying 'error'
	                        }
	                        return reject('Failed to startCharacteristicNotifications for characteristic ' + _StringUtils2.default.getCharacteristicString(characteristic) + '. Error: ' + chrome.runtime.lastError.message);
	                    }
	                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                        _LDSDKLogger2.default.debug('Done calling chrome.bluetoothLowEnergy.startCharacteristicNotifications for ' + _StringUtils2.default.getCharacteristicString(characteristic) + ' - it took ' + _TimerUtil2.default.stopTimer(startCharacteristicNotificationsTimer) + ' ms');
	                    }
	                    return resolve();
	                });
	            });
	        }
	
	        /**
	         *
	         * @param characteristic
	         * @return {Promise}
	         */
	
	    }, {
	        key: 'stopCharacteristicNotification',
	        value: function stopCharacteristicNotification(characteristic) {
	            return new _promise2.default(function (resolve, reject) {
	                var stopCharacteristicNotificationsTimer = _TimerUtil2.default.startTimer();
	                chrome.bluetoothLowEnergy.stopCharacteristicNotifications(characteristic.instanceId, function () {
	                    if (chrome.runtime.lastError) {
	                        if (chrome.runtime.lastError.message !== 'Not notifying') {
	                            _LDSDKLogger2.default.error('Failed to stop notifications: ' + chrome.runtime.lastError.message);
	                            return reject(chrome.runtime.lastError);
	                        }
	                    }
	                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                        _LDSDKLogger2.default.debug('Done calling chrome.bluetoothLowEnergy.stopCharacteristicNotifications for ' + _StringUtils2.default.getCharacteristicString(characteristic) + ' - it took ' + _TimerUtil2.default.stopTimer(stopCharacteristicNotificationsTimer) + ' ms');
	                    }
	                    return resolve();
	                });
	            });
	        }
	
	        /**
	         * Get the characteristics for the BLE service
	         * @param {NativeService} service
	         * @return {Promise}
	         */
	
	    }, {
	        key: 'getCharacteristics',
	        value: function getCharacteristics(service) {
	            return new _promise2.default(function (resolve, reject) {
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('Getting characteristics for service: ' + _UuidHelper2.default.getUuid(service) + ' ( ' + service.instanceId + ')');
	                }
	                chrome.bluetoothLowEnergy.getCharacteristics(service.instanceId, function (characteristics) {
	                    if (chrome.runtime.lastError) {
	                        var msg = 'chrome.bluetoothLowEnergy.getCharacteristics failed lookup of service instance id: "' + service.instanceId + '". Original message: ' + chrome.runtime.lastError.message;
	                        return reject(msg);
	                    }
	                    return resolve(characteristics);
	                });
	            });
	        }
	
	        /**
	         *
	         * @param {SynchronousQueueElement} element
	         * @return {Promise<Void>}
	         */
	
	    }, {
	        key: 'writeCharacteristic',
	        value: function writeCharacteristic(element) {
	            var _this3 = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                if (_this3.isConnected() && element && element !== null && element.characteristic && element.characteristic !== null && element.characteristic.instanceId && element.characteristic.instanceId !== null && element.value && element.value !== null) {
	                    chrome.bluetoothLowEnergy.writeCharacteristicValue(element.characteristic.instanceId, element.value, function () {
	                        if (chrome.runtime.lastError) {
	                            var errMsg = 'Failed to write characteristic value ' + element.characteristic.instanceId + ', Value: ' + new Int8Array(element.value) + ' to device ' + _this3.getName() + ' [' + _this3.getAddress() + ']. Reason: ' + chrome.runtime.lastError.message;
	                            _LDSDKLogger2.default.error(errMsg);
	                            if (chrome.runtime.lastError.message === 'Operation failed') {
	                                if (_LegoDeviceManagerImpl2.default.getInstance().config.disconnectOnOperationFailedBLEError) {
	                                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                        _LDSDKLogger2.default.debug('writeCharacteristic failed with "Operation failed"' + ' message and disconnectOnOperationFailedBLEError' + ' config setting is true - disconnecting from device');
	                                    }
	                                    _LegoDeviceManagerImpl2.default.getInstance().cancelDeviceConnection(_this3.getAddress());
	                                }
	                            }
	                            return reject(errMsg);
	                        }
	                        return resolve();
	                    });
	                } else {
	                    return resolve();
	                }
	            }).catch(function (err) {
	                return _promise2.default.reject(err);
	            });
	        }
	
	        /**
	         *
	         * @param {SynchronousQueueElement} element
	         * @return {Promise<NativeCharacteristic>} - The result from the
	         * chrome.bluetoothLowEnergy.readCharacteristicValue call.
	         */
	
	    }, {
	        key: 'readCharacteristic',
	        value: function readCharacteristic(element) {
	            var _this4 = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                if (_this4.isConnected()) {
	                    chrome.bluetoothLowEnergy.readCharacteristicValue(element.characteristic.instanceId, function (result) {
	                        if (chrome.runtime.lastError) {
	                            var errMsg = 'Failed to read ' + element.characteristic.instanceId + ' from device ' + _this4.getName() + ' [' + _this4.getAddress() + ']. Reason: ' + chrome.runtime.lastError.message;
	                            _LDSDKLogger2.default.error(errMsg);
	                            if (chrome.runtime.lastError.message === 'Operation failed') {
	                                if (_LegoDeviceManagerImpl2.default.getInstance().config.disconnectOnOperationFailedBLEError) {
	                                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                        _LDSDKLogger2.default.debug('readCharacteristic failed with "Operation failed"' + ' message and disconnectOnOperationFailedBLEError' + ' config setting is true - disconnecting from device');
	                                    }
	                                    _LegoDeviceManagerImpl2.default.getInstance().cancelDeviceConnection(_this4.getAddress());
	                                }
	                            }
	                            return reject(errMsg);
	                        }
	                        return resolve(result);
	                    });
	                } else {
	                    return resolve();
	                }
	            }).catch(function (err) {
	                return _promise2.default.reject(err);
	            });
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return this.constructor.name + '{' + this.getName() + ' [' + this.getAddress() + ', pairing: ' + this.isPairing() + ', paired: ' + this.getPaired() + ', connecting: ' + this.getConnecting() + ', connected: ' + this.getConnected() + ', rssi:' + ' ' + this.getRssi() + ']' + '}';
	        }
	    }]);
	    return ChromeOsBluetoothDeviceWrapper;
	}();
	
	exports.default = ChromeOsBluetoothDeviceWrapper;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _promise = __webpack_require__(12);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _stringify = __webpack_require__(19);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _getIterator2 = __webpack_require__(33);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _regenerator = __webpack_require__(14);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(13);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _map = __webpack_require__(9);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _getPrototypeOf = __webpack_require__(5);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _possibleConstructorReturn2 = __webpack_require__(7);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(6);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _LegoDeviceImpl2 = __webpack_require__(27);
	
	var _LegoDeviceImpl3 = _interopRequireDefault(_LegoDeviceImpl2);
	
	var _Revision = __webpack_require__(61);
	
	var _Revision2 = _interopRequireDefault(_Revision);
	
	var _DeviceInfo = __webpack_require__(60);
	
	var _DeviceInfo2 = _interopRequireDefault(_DeviceInfo);
	
	var _LegoServiceFactory = __webpack_require__(63);
	
	var _LegoServiceFactory2 = _interopRequireDefault(_LegoServiceFactory);
	
	var _StringUtils = __webpack_require__(21);
	
	var _StringUtils2 = _interopRequireDefault(_StringUtils);
	
	var _UuidHelper = __webpack_require__(11);
	
	var _UuidHelper2 = _interopRequireDefault(_UuidHelper);
	
	var _SimpleList = __webpack_require__(45);
	
	var _SimpleList2 = _interopRequireDefault(_SimpleList);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	var _LDSDKError = __webpack_require__(44);
	
	var _LDSDKError2 = _interopRequireDefault(_LDSDKError);
	
	var _BluetoothServiceDefinition = __webpack_require__(37);
	
	var _BluetoothServiceDefinition2 = _interopRequireDefault(_BluetoothServiceDefinition);
	
	var _DeviceInfoServiceDefinition = __webpack_require__(32);
	
	var _DeviceInfoServiceDefinition2 = _interopRequireDefault(_DeviceInfoServiceDefinition);
	
	var _BluetoothHelper = __webpack_require__(62);
	
	var _BluetoothHelper2 = _interopRequireDefault(_BluetoothHelper);
	
	var _BluetoothIO = __webpack_require__(114);
	
	var _BluetoothIO2 = _interopRequireDefault(_BluetoothIO);
	
	var _ConnectInfo = __webpack_require__(43);
	
	var _ConnectInfo2 = _interopRequireDefault(_ConnectInfo);
	
	var _BluetoothDeviceCallback = __webpack_require__(82);
	
	var _BluetoothDeviceCallback2 = _interopRequireDefault(_BluetoothDeviceCallback);
	
	var _LegoDeviceManagerImpl = __webpack_require__(31);
	
	var _LegoDeviceManagerImpl2 = _interopRequireDefault(_LegoDeviceManagerImpl);
	
	var _TimerUtil = __webpack_require__(87);
	
	var _TimerUtil2 = _interopRequireDefault(_TimerUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var SynchronousQueueElement = function () {
	
	    /**
	     * Constructs a new SynchronousQueueElement - Either a characteristic OR a descriptor must be set for the queue
	     * handler to be able to decide how to handle the element.
	     *
	     * @param {NativeCharacteristic} characteristic The characteristic to use in the command.
	     * @param {NativeDescriptor} descriptor The descriptor to use in the command
	     * @param {ArrayBuffer} value
	     * @param {Promise} promise
	     */
	    function SynchronousQueueElement() {
	        var characteristic = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	        var descriptor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	        var value = arguments[2];
	        var promise = arguments[3];
	        (0, _classCallCheck3.default)(this, SynchronousQueueElement);
	        this.characteristic = null;
	        this.descriptor = null;
	        this.value = null;
	        this.promise = null;
	
	        /**
	         * @private
	         */
	        this.characteristic = characteristic;
	        /**
	         * @private
	         */
	        this.descriptor = descriptor;
	        /**
	         * @private
	         */
	        this.value = value;
	        /**
	         * @private
	         */
	        this.promise = promise;
	    }
	
	    /**
	     * Helper for constructing a new element for a characteristic
	     *
	     * @param {NativeCharacteristic} characteristic
	     * @param {ArrayBuffer} value
	      * @return {SynchronousQueueElement}
	     */
	
	
	    (0, _createClass3.default)(SynchronousQueueElement, null, [{
	        key: 'fromCharacteristic',
	        value: function fromCharacteristic(characteristic, value) {
	            return new SynchronousQueueElement(characteristic, null, value, null);
	        }
	
	        /**
	         * Helper for constructing a new element for a descriptor
	         *
	         * @param {NativeDescriptor} descriptor
	         * @param {ArrayBuffer} value
	          * @return {SynchronousQueueElement}
	         */
	
	    }, {
	        key: 'fromDescriptor',
	        value: function fromDescriptor(descriptor, value) {
	            return new SynchronousQueueElement(null, descriptor, value, null);
	        }
	    }, {
	        key: 'fromPromise',
	        value: function fromPromise(promise) {
	            return new SynchronousQueueElement(null, null, null, promise);
	        }
	    }]);
	    return SynchronousQueueElement;
	}();
	/**
	 * LegoBluetoothDeviceImpl is an Abstract class - it should not be instantiated directly
	 * @abstract
	 */
	/**
	 * SynchronousQueueElement is a class wrapping the characteristic or descriptor (one OR the other, NOT both) and the
	 * ArrayBuffer value to use for the read- or write command.
	 *
	 * SynchronousQueueElement is used only in the queue so each element in the queue is a self contained entity that
	 * the queue handler can execute.
	 *
	 * Created by frj on 19/02/16.
	 */
	
	
	var LegoBluetoothDeviceImpl = function (_LegoDeviceImpl) {
	    (0, _inherits3.default)(LegoBluetoothDeviceImpl, _LegoDeviceImpl);
	    (0, _createClass3.default)(LegoBluetoothDeviceImpl, [{
	        key: 'deviceNativeServices',
	
	
	        /**
	         *
	         * @type {Map<string, NativeService>}
	         */
	
	
	        // DeviceInfoService
	
	        /**
	         * @ignore
	         * @type {Map<string, number>}
	         */
	
	
	        // LEGO IO Service
	        get: function get() {
	            return this._deviceNativeServices;
	        }
	
	        /**
	         * Helper for getting a LegoBluetoothDeviceImpl instance for the given bluetoothDeviceWrapper address. A cached
	         * instance is returned if it exists, otherwise a new instance is created and cached before being returned.
	         * @param {ChromeOsBluetoothDeviceWrapper} bluetoothDeviceWrapper
	         * @param {number} rssi
	         * @param {LegoDeviceManagerImpl} legoDeviceManager
	         *
	         * @return {LegoBluetoothDeviceImpl}
	         */
	
	
	        /**
	         * @private
	         * @type {Map<string, NativeService>}
	         */
	
	
	        // BatteryService
	
	
	        // LEGO Device Service
	
	        /**
	         * @ignore
	         * @type {Map<string, number>}
	         */
	
	        //  ScanRecord scanRecord;
	
	    }], [{
	        key: 'deviceWithWrapper',
	        value: function deviceWithWrapper(bluetoothDeviceWrapper, rssi, legoDeviceManager) {
	            var legoBluetoothDevice = legoDeviceManager.getDevice(bluetoothDeviceWrapper.getAddress(), false);
	            if (legoBluetoothDevice !== null) {
	                legoBluetoothDevice.updateWrapper(bluetoothDeviceWrapper);
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('deviceWithWrapper returning cached LegoBluetoothDeviceImpl instance: ' + legoBluetoothDevice.toString());
	                }
	            } else {
	                legoBluetoothDevice = new LegoBluetoothDeviceImpl(bluetoothDeviceWrapper, rssi, legoDeviceManager);
	                legoDeviceManager.bluetoothDeviceManager.setDevice(legoBluetoothDevice);
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('deviceWithWrapper returning new LegoBluetoothDeviceImpl instance: ' + legoDeviceManager.getDevice(bluetoothDeviceWrapper.getAddress(), false).toString());
	                }
	            }
	            return legoBluetoothDevice;
	        }
	
	        /**
	         *
	         * @param {ChromeOsBluetoothDeviceWrapper} bluetoothDeviceWrapper
	         * @param {number} rssi
	         * @param {LegoDeviceManagerImpl} legoDeviceManager
	         */
	
	    }]);
	
	    function LegoBluetoothDeviceImpl(bluetoothDeviceWrapper, rssi, legoDeviceManager) {
	        (0, _classCallCheck3.default)(this, LegoBluetoothDeviceImpl);
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, (LegoBluetoothDeviceImpl.__proto__ || (0, _getPrototypeOf2.default)(LegoBluetoothDeviceImpl)).call(this, legoDeviceManager));
	
	        _this.bluetoothDeviceWrapper = null;
	        _this.bluetoothGatt = null;
	        _this.maxRetries = 50;
	        _this.retryCount = new _map2.default();
	        _this.startNotificationsRetryCount = new _map2.default();
	        _this.bluetoothIO = null;
	        _this.ioServiceDefinition = null;
	        _this.deviceServiceDefinition = null;
	        _this.nameCharacteristic = null;
	        _this.ioCharacteristic = null;
	        _this.disconnectCharacteristic = null;
	        _this.buttonCharacteristic = null;
	        _this.lowVoltageAlertCharacteristic = null;
	        _this.batteryServiceDefinition = null;
	        _this.batteryLevelCharacteristic = null;
	        _this.batteryIntervalId = null;
	        _this.deviceInfoServiceDefinition = null;
	        _this.firmwareRevisionCharacteristic = null;
	        _this.hardwareRevisionCharacteristic = null;
	        _this.softwareRevisionCharacteristic = null;
	        _this.manufacturerCharacteristic = null;
	        _this.characteristicListenersRegistered = false;
	        _this.interrogationFinished = false;
	        _this._advertising = false;
	        _this.rssiValues = new _SimpleList2.default();
	        _this.averageRSSI = 0;
	        _this.synchronousOperationsQueue = [];
	        _this.messagesHandled = 0;
	        _this.userInitiatedDisconnect = false;
	        _this.operationExecuting = false;
	        _this._deviceNativeServices = new _map2.default();
	        _this.executeNextOperationQueueTimer = null;
	        _this.characteristicNotifications = new _map2.default();
	
	
	        _LDSDKLogger2.default.info('Constructing LegoBluetoothDeviceImpl for ' + bluetoothDeviceWrapper.getAddress() + ' -' + ' Instance ID:' + ' ' + _this.instanceId);
	        /**
	         * @private
	         */
	        _this.bluetoothDeviceWrapper = bluetoothDeviceWrapper;
	        if (_this.bluetoothDeviceWrapper !== null) {
	            /**
	             * @private
	             */
	            _this.deviceName = _this.bluetoothDeviceWrapper.getName();
	        }
	        _this.resetState();
	        /**
	         * @private
	         */
	        _this.ioServiceDefinition = _BluetoothServiceDefinition2.default.ioServiceDefinition();
	        /**
	         * @private
	         */
	        _this.deviceServiceDefinition = _BluetoothServiceDefinition2.default.deviceServiceDefinition();
	        /**
	         * @private
	         */
	        _this.deviceInfoServiceDefinition = _BluetoothServiceDefinition2.default.deviceInfoServiceDefinition();
	        /**
	         * @private
	         */
	        _this.batteryServiceDefinition = _BluetoothServiceDefinition2.default.batteryServiceDefinition();
	        _this.updateWithAdvertisementDataAndRSSI(rssi);
	        return _this;
	    }
	
	    /**
	     * @param {ChromeOsBluetoothDeviceWrapper} bluetoothDeviceWrapper
	     */
	
	
	    (0, _createClass3.default)(LegoBluetoothDeviceImpl, [{
	        key: 'updateWrapper',
	        value: function updateWrapper(bluetoothDeviceWrapper) {
	            if (this.bluetoothDeviceWrapper !== null) {
	                var cachedWrapper = this.getBluetoothWrapper();
	                cachedWrapper.updateNativeDevice(bluetoothDeviceWrapper.getDevice());
	            } else {
	                /**
	                 * @private
	                 * @type {ChromeOsBluetoothDeviceWrapper}
	                 */
	                this.bluetoothDeviceWrapper = bluetoothDeviceWrapper;
	            }
	        }
	    }, {
	        key: 'updateAdvertising',
	        value: function () {
	            var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
	                var isAdvertising, nativeDevice;
	                return _regenerator2.default.wrap(function _callee$(_context) {
	                    while (1) {
	                        switch (_context.prev = _context.next) {
	                            case 0:
	                                isAdvertising = false;
	                                _context.next = 3;
	                                return this.legoDeviceManager.getBluetoothAdapter().getDevice(this.getAddress());
	
	                            case 3:
	                                nativeDevice = _context.sent;
	
	                                if (nativeDevice !== null) {
	                                    isAdvertising = nativeDevice.hasOwnProperty('inquiryRssi') && nativeDevice.inquiryRssi !== -1;
	                                }
	                                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                    _LDSDKLogger2.default.debug('updateAdvertising: ' + isAdvertising + '. NativeDevice:', nativeDevice);
	                                }
	                                this.setAdvertising(isAdvertising);
	
	                            case 7:
	                            case 'end':
	                                return _context.stop();
	                        }
	                    }
	                }, _callee, this);
	            }));
	
	            function updateAdvertising() {
	                return _ref.apply(this, arguments);
	            }
	
	            return updateAdvertising;
	        }()
	    }, {
	        key: 'resetState',
	        value: function () {
	            var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
	                return _regenerator2.default.wrap(function _callee2$(_context2) {
	                    while (1) {
	                        switch (_context2.prev = _context2.next) {
	                            case 0:
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info('Resetting state for device ' + this.getName() + ' [' + this.getAddress() + ']');
	                                }
	                                /**
	                                 * @private
	                                 * @type {number}
	                                 */
	                                this.advertisingUpdatedTimestamp = 0;
	                                _context2.next = 4;
	                                return this.updateAdvertising();
	
	                            case 4:
	                                this.updateConnectionStateUponConnectionStateChange(null, _LegoDeviceImpl2.StateEnum.DisconnectedAdvertising);
	
	                                _LegoServiceFactory2.default.clearServices(this.getDeviceId());
	
	                                /**
	                                 * @private
	                                 * @type {boolean}
	                                 */
	                                this.interrogationFinished = false;
	                                /**
	                                 * @private
	                                 * @type {SimpleList}
	                                 */
	                                this.rssiValues = new _SimpleList2.default();
	                                /**
	                                 * @private
	                                 * @type {DeviceInfo}
	                                 */
	                                this.deviceInfo = new _DeviceInfo2.default();
	                                /**
	                                 *
	                                 * @type {number}
	                                 */
	                                this.batteryLevel = 0;
	
	                                // this.deviceInfo = new DeviceInfo();
	
	                                /**
	                                 *
	                                 * @type {Map<number, LegoService>}
	                                 */
	
	                                // Clear the queue
	                                this.resetQueue();
	                                if (this.batteryIntervalId !== null) {
	                                    clearInterval(this.batteryIntervalId);
	                                    /**
	                                     * @private
	                                     * @type {null}
	                                     */
	                                    this.batteryIntervalId = null;
	                                }
	
	                                // Do not reset things set in 'advertising' as it is possible to reconnect to a device
	                                // without ever receiving a advertising package (e.g. on automatic reconnect)
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('Device was reset to: ' + this.toString());
	                                }
	
	                            case 13:
	                            case 'end':
	                                return _context2.stop();
	                        }
	                    }
	                }, _callee2, this);
	            }));
	
	            function resetState() {
	                return _ref2.apply(this, arguments);
	            }
	
	            return resetState;
	        }()
	    }, {
	        key: 'resetQueue',
	        value: function resetQueue() {
	            /**
	             * @private
	             * @type {number}
	             */
	            this.synchronousOperationsQueue.length = 0;
	        }
	    }, {
	        key: 'getQueueSize',
	        value: function getQueueSize() {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.getQueueSize();
	                }
	            }
	
	            return this.synchronousOperationsQueue.length;
	        }
	    }, {
	        key: 'getMessagesHandled',
	        value: function getMessagesHandled() {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.getMessagesHandled();
	                }
	            }
	
	            return this.messagesHandled;
	        }
	    }, {
	        key: 'setQueuePollDelay',
	        value: function setQueuePollDelay(delayMs) {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.setQueuePollDelay(delayMs);
	                }
	            }
	
	            _LegoDeviceManagerImpl2.default.getInstance().config.synchronousOperationsQueuePollDelay = delayMs;
	        }
	    }, {
	        key: 'getQueuePollDelay',
	        value: function getQueuePollDelay() {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.getQueuePollDelay();
	                }
	            }
	
	            return _LegoDeviceManagerImpl2.default.getInstance().config.synchronousOperationsQueuePollDelay;
	        }
	    }, {
	        key: 'isAdvertising',
	        value: function isAdvertising() {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.isAdvertising();
	                }
	            }
	
	            return this.advertising;
	        }
	
	        /**
	         *
	         * @param {boolean} advertising
	         * @return {*}
	         */
	
	    }, {
	        key: 'setAdvertising',
	        value: function setAdvertising(advertising) {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.setAdvertising(advertising);
	                }
	            }
	            /**
	             * @private
	             * @type {boolean}
	             */
	            this.advertising = advertising;
	            this.updateConnectionStateUponAdvertisingChange();
	        }
	    }, {
	        key: 'getAddress',
	        value: function getAddress() {
	            return this.getDeviceId();
	        }
	    }, {
	        key: 'getDeviceId',
	        value: function getDeviceId() {
	            return this.bluetoothDeviceWrapper.getAddress();
	        }
	    }, {
	        key: 'setName',
	        value: function () {
	            var _ref3 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(newName) {
	                var cachedDevice, oldName, dataToWrite, nativeDevice, wrappedDevice;
	                return _regenerator2.default.wrap(function _callee3$(_context3) {
	                    while (1) {
	                        switch (_context3.prev = _context3.next) {
	                            case 0:
	                                cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	
	                                if (!(cachedDevice && cachedDevice !== null)) {
	                                    _context3.next = 6;
	                                    break;
	                                }
	
	                                if (!(this.instanceId !== cachedDevice.instanceId)) {
	                                    _context3.next = 6;
	                                    break;
	                                }
	
	                                _context3.next = 5;
	                                return cachedDevice.setName(newName);
	
	                            case 5:
	                                return _context3.abrupt('return', _context3.sent);
	
	                            case 6:
	                                if (!(this.connectState !== _LegoDeviceImpl2.StateEnum.InterrogationFinished)) {
	                                    _context3.next = 9;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                    _LDSDKLogger2.default.warn('Ignoring call to set device name - not connected to device');
	                                }
	                                return _context3.abrupt('return');
	
	                            case 9:
	                                if (!(newName === undefined || newName === null)) {
	                                    _context3.next = 12;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                    _LDSDKLogger2.default.warn('Ignoring call to set device name - newName param is undefined or null');
	                                }
	                                return _context3.abrupt('return');
	
	                            case 12:
	                                oldName = this.deviceName;
	                                /**
	                                 * @private
	                                 */
	
	                                this.deviceName = newName;
	
	                                dataToWrite = Uint8Array.from(this.deviceName.trim() === '' ? [0] : _StringUtils2.default.toUtf8Bytes(this.deviceName));
	
	
	                                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                    _LDSDKLogger2.default.warn('Setting name "' + this.deviceName + '" - bytes: ' + dataToWrite);
	                                }
	
	                                /**
	                                 * We use an optimistic approach when setting the name - we assume that the write is successful. If
	                                 * we get an {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite} with an error, we will revert the value and notify through the callback listener
	                                 */
	                                _context3.next = 18;
	                                return this.addWriteOfCharacteristicToQueue(this.nameCharacteristic, dataToWrite.buffer);
	
	                            case 18:
	
	                                // await this.addReadOfCharacteristicToQueue(this.nameCharacteristic);
	
	                                /**
	                                 * @private
	                                 */
	                                this.getBluetoothDevice().name = newName;
	                                _context3.next = 21;
	                                return this.legoBluetoothDeviceManager.bluetoothAdapter.getDevice(cachedDevice.getAddress());
	
	                            case 21:
	                                nativeDevice = _context3.sent;
	                                // Get the device from the OS adapter.
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info('Got native device from OS ', nativeDevice, ' new name: ' + newName);
	                                }
	                                nativeDevice.name = newName; // Update the name
	                                wrappedDevice = this.legoBluetoothDeviceManager.bluetoothAdapter.getWrappedDevice(nativeDevice); // getWrappedDevice also updates the cache
	
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info('Cache wrapped device after rename: ', wrappedDevice);
	                                }
	
	                                this.legoDeviceManager.bluetoothDeviceManager.setDevice(this);
	
	                                _context3.next = 29;
	                                return this.callbackHelper.performDidChangeNameCallback(this, oldName, newName);
	
	                            case 29:
	                            case 'end':
	                                return _context3.stop();
	                        }
	                    }
	                }, _callee3, this);
	            }));
	
	            function setName(_x3) {
	                return _ref3.apply(this, arguments);
	            }
	
	            return setName;
	        }()
	    }, {
	        key: 'updateWithAdvertisementDataAndRSSI',
	        value: function () {
	            var _ref4 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4(rssi) {
	                var cachedDevice, oldName;
	                return _regenerator2.default.wrap(function _callee4$(_context4) {
	                    while (1) {
	                        switch (_context4.prev = _context4.next) {
	                            case 0:
	                                cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	
	                                if (!(cachedDevice && cachedDevice !== null)) {
	                                    _context4.next = 6;
	                                    break;
	                                }
	
	                                if (!(this.instanceId !== cachedDevice.instanceId)) {
	                                    _context4.next = 6;
	                                    break;
	                                }
	
	                                _context4.next = 5;
	                                return cachedDevice.updateWithAdvertisementDataAndRSSI(rssi);
	
	                            case 5:
	                                return _context4.abrupt('return', _context4.sent);
	
	                            case 6:
	
	                                this.calculateAverageRSSI(rssi);
	
	                                oldName = this.deviceName;
	
	                                if (!(this.deviceName && this.deviceName !== null && this.deviceName !== oldName)) {
	                                    _context4.next = 12;
	                                    break;
	                                }
	
	                                /**
	                                 * @private
	                                 * @type {string}
	                                 */
	                                this.getBluetoothDevice().name = this.deviceName;
	                                _context4.next = 12;
	                                return this.callbackHelper.performDidChangeNameCallback(this, oldName, this.deviceName);
	
	                            case 12:
	                            case 'end':
	                                return _context4.stop();
	                        }
	                    }
	                }, _callee4, this);
	            }));
	
	            function updateWithAdvertisementDataAndRSSI(_x4) {
	                return _ref4.apply(this, arguments);
	            }
	
	            return updateWithAdvertisementDataAndRSSI;
	        }()
	    }, {
	        key: 'updateButtonState',
	        value: function updateButtonState(buttonState) {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.updateButtonState(buttonState);
	                }
	            }
	
	            var oldButtonPressedState = this.buttonPressed;
	            /**
	             * @private
	             * @type {boolean}
	             */
	            this.buttonPressed = buttonState === 1;
	
	            if (this.buttonPressed !== oldButtonPressedState) {
	                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                    _LDSDKLogger2.default.info('Button ' + (this.buttonPressed ? 'pushed' : 'released'));
	                }
	                this.callbackHelper.performDidChangeButtonStateCallback(this, this.buttonPressed);
	            }
	        }
	    }, {
	        key: 'calculateAverageRSSI',
	        value: function calculateAverageRSSI(newRSSI) {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.calculateAverageRSSI(newRSSI);
	                }
	            }
	
	            if (this.rssiValues.length() < LegoBluetoothDeviceImpl.NUMBER_OF_RSSI_VALUES_TO_AVERAGE) {
	                // Until we have reached the first NUMBER_OF_RSSI_VALUES_TO_AVERAGE values, just add them
	                this.rssiValues.push(newRSSI);
	            } else {
	                // After having received the 10 first values, replace existing value at rssiIndex
	                this.rssiValues.push(newRSSI);
	                this.rssiValues.splice(0, 1);
	            }
	
	            if (this.rssiIndex <= LegoBluetoothDeviceImpl.NUMBER_OF_RSSI_VALUES_TO_AVERAGE) {
	                // Sort the values in a list a pick the value in the middle of the list as the average value
	                // which is a simple way to ignore outliers.
	                var sortedRSSIValues = [];
	                sortedRSSIValues.addAll(this.rssiValues);
	                sortedRSSIValues.sort(function (lhs, rhs) {
	                    if (lhs === rhs) {
	                        return 0;
	                    } else if (lhs > rhs) {
	                        return 1;
	                    } else if (lhs < rhs) {
	                        return -1;
	                    }
	                });
	                var middleIndex = sortedRSSIValues.length / 2; // intentionally assign to int, to round down result to
	                // nearest integer
	                /**
	                 * @private
	                 */
	                this.averageRSSI = sortedRSSIValues[middleIndex];
	            }
	
	            if (this.rssiIndex === LegoBluetoothDeviceImpl.NUMBER_OF_RSSI_VALUES_TO_AVERAGE) {
	                /**
	                 * @private
	                 * @type {number}
	                 */
	                this.rssiIndex = 0;
	            }
	        }
	    }, {
	        key: 'updateDeviceState',
	        value: function updateDeviceState(newDeviceState) {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.updateDeviceState(newDeviceState);
	                }
	            }
	
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('DeviceConnectionState updated! New state: ' + newDeviceState);
	            }
	            /**
	             * @private
	             */
	            this.connectState = newDeviceState;
	        }
	    }, {
	        key: 'getRSSIValue',
	        value: function getRSSIValue() {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.getRSSIValue();
	                }
	            }
	
	            return this.averageRSSI;
	        }
	    }, {
	        key: 'getCategory',
	        value: function getCategory() {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.getCategory();
	                }
	            }
	
	            return this.category;
	        }
	    }, {
	        key: 'getSupportedFunctions',
	        value: function getSupportedFunctions() {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.getSupportedFunctions();
	                }
	            }
	
	            return this.supportedFunctions;
	        }
	    }, {
	        key: 'getLastConnectedNetworkId',
	        value: function getLastConnectedNetworkId() {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.getLastConnectedNetworkId();
	                }
	            }
	
	            return this.lastConnectedNetworkId;
	        }
	    }, {
	        key: 'isLowVoltage',
	        value: function isLowVoltage() {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.isLowVoltage();
	                }
	            }
	
	            return this.lowVoltage;
	        }
	
	        /**
	         *
	         * @param {CurrentSensor|GenericService|MotionSensor|PiezoTonePlayer|RGBLight|SimpleMotor|TiltSensor|VoltageSensor} service
	         */
	
	    }, {
	        key: 'addService',
	        value: function addService(service) {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.addService(service);
	                }
	            }
	
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('Adding service [ConnectId: ' + service.getConnectInfo().getConnectId() + ', Type: ' + service.getServiceName() + ']');
	            }
	            _LegoServiceFactory2.default.addService(this.getDeviceId(), service);
	        }
	
	        /**
	         *
	         * @param {CurrentSensor|GenericService|MotionSensor|PiezoTonePlayer|RGBLight|SimpleMotor|TiltSensor|VoltageSensor} service
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'removeService',
	        value: function removeService(service) {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.removeService(service);
	                }
	            }
	
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('Removing service [ConnectId: ' + service.getConnectInfo().getConnectId() + ', Type: ' + service.getServiceName() + ']');
	            }
	            return _LegoServiceFactory2.default.removeService(this.getDeviceId(), service.getConnectInfo().getConnectId());
	        }
	
	        /**
	         * Get the service attached with the given connectId
	         * @param {number} connectId
	         * @return {LegoService}
	         */
	
	    }, {
	        key: 'getService',
	        value: function getService(connectId) {
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                for (var _iterator = (0, _getIterator3.default)(this.services.values()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var service = _step.value;
	
	                    var connectInfo = service.getConnectInfo();
	                    if (connectInfo && connectInfo !== null) {
	                        var cachedConnectId = connectInfo.getConnectId();
	                        if (connectId === cachedConnectId) {
	                            return service;
	                        }
	                    }
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	
	            return null;
	        }
	
	        /**
	         *
	         * @return {Array<LegoService>} Array of LegoService instances
	         */
	
	    }, {
	        key: 'getServices',
	        value: function getServices() {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.getServices();
	                }
	            }
	
	            var servicesArray = [];
	            var _iteratorNormalCompletion2 = true;
	            var _didIteratorError2 = false;
	            var _iteratorError2 = undefined;
	
	            try {
	                for (var _iterator2 = (0, _getIterator3.default)(this.services.values()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                    var service = _step2.value;
	
	                    servicesArray.push(service);
	                }
	            } catch (err) {
	                _didIteratorError2 = true;
	                _iteratorError2 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                        _iterator2.return();
	                    }
	                } finally {
	                    if (_didIteratorError2) {
	                        throw _iteratorError2;
	                    }
	                }
	            }
	
	            servicesArray.sort(function (lhs, rhs) {
	                var lhsConnectID = lhs.getConnectInfo().getConnectId();
	                var rhsConnectID = rhs.getConnectInfo().getConnectId();
	
	                if (lhsConnectID === rhsConnectID) {
	                    return 0;
	                } else if (lhsConnectID > rhsConnectID) {
	                    return 1;
	                } else {
	                    return -1;
	                }
	            });
	            return servicesArray;
	        }
	
	        /**
	         *
	         * @param {bool} autoConnect
	         * @param {BaseBluetoothGattCallback} bluetoothGattCallback
	         */
	
	    }, {
	        key: 'connectGatt',
	        value: function () {
	            var _ref5 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5(autoConnect, bluetoothGattCallback) {
	                var cachedDevice;
	                return _regenerator2.default.wrap(function _callee5$(_context5) {
	                    while (1) {
	                        switch (_context5.prev = _context5.next) {
	                            case 0:
	                                cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	
	                                if (!(cachedDevice && cachedDevice !== null)) {
	                                    _context5.next = 13;
	                                    break;
	                                }
	
	                                if (!(this.instanceId !== cachedDevice.instanceId)) {
	                                    _context5.next = 13;
	                                    break;
	                                }
	
	                                _context5.prev = 3;
	                                _context5.next = 6;
	                                return cachedDevice.connectGatt(autoConnect, bluetoothGattCallback);
	
	                            case 6:
	                                return _context5.abrupt('return', _context5.sent);
	
	                            case 9:
	                                _context5.prev = 9;
	                                _context5.t0 = _context5['catch'](3);
	
	                                _LDSDKLogger2.default.error('cachedDevice.connectGatt failed', _context5.t0);
	                                throw _context5.t0;
	
	                            case 13:
	
	                                this.updateDeviceState(_LegoDeviceImpl2.StateEnum.Connecting);
	                                _context5.prev = 14;
	                                _context5.next = 17;
	                                return this.bluetoothDeviceWrapper.connectGatt(autoConnect, new _BluetoothDeviceCallback2.default(this, bluetoothGattCallback));
	
	                            case 17:
	                                _context5.next = 23;
	                                break;
	
	                            case 19:
	                                _context5.prev = 19;
	                                _context5.t1 = _context5['catch'](14);
	
	                                _LDSDKLogger2.default.error('this.bluetoothDeviceWrapper.connectGatt failed', _context5.t1);
	                                throw _context5.t1;
	
	                            case 23:
	                            case 'end':
	                                return _context5.stop();
	                        }
	                    }
	                }, _callee5, this, [[3, 9], [14, 19]]);
	            }));
	
	            function connectGatt(_x5, _x6) {
	                return _ref5.apply(this, arguments);
	            }
	
	            return connectGatt;
	        }()
	
	        /**
	         * Delegates the call on to the UpdatedInputServiceCharacteristic value handler
	         * @param {NativeCharacteristic} characteristic
	         */
	
	    }, {
	        key: 'handleUpdatedInputServiceCharacteristic',
	        value: function () {
	            var _ref6 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7(characteristic) {
	                var _this2 = this;
	
	                var cachedDevice, characteristicUuid, count;
	                return _regenerator2.default.wrap(function _callee7$(_context7) {
	                    while (1) {
	                        switch (_context7.prev = _context7.next) {
	                            case 0:
	                                if (!(!characteristic || characteristic === null)) {
	                                    _context7.next = 3;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug(this.constructor.name + '.handleUpdatedInputServiceCharacteristic ignoring call -' + ' The characteristic parameter is not set or null');
	                                }
	                                return _context7.abrupt('return');
	
	                            case 3:
	                                cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	
	                                if (!(cachedDevice && cachedDevice !== null)) {
	                                    _context7.next = 9;
	                                    break;
	                                }
	
	                                if (!(this.instanceId !== cachedDevice.instanceId)) {
	                                    _context7.next = 9;
	                                    break;
	                                }
	
	                                _context7.next = 8;
	                                return cachedDevice.handleUpdatedInputServiceCharacteristic(characteristic);
	
	                            case 8:
	                                return _context7.abrupt('return', _context7.sent);
	
	                            case 9:
	                                characteristicUuid = _UuidHelper2.default.getUuid(characteristic);
	
	                                if (!(this.bluetoothIO !== null)) {
	                                    _context7.next = 17;
	                                    break;
	                                }
	
	                                if (characteristicUuid !== null) {
	                                    this.retryCount.delete(characteristicUuid);
	                                }
	                                _context7.next = 14;
	                                return this.bluetoothIO.handleUpdatedInputServiceCharacteristic(characteristic);
	
	                            case 14:
	                                return _context7.abrupt('return');
	
	                            case 17:
	                                count = 1;
	
	                                if (characteristicUuid !== null) {
	                                    if (this.retryCount.has(characteristicUuid)) {
	                                        count = this.retryCount.get(characteristicUuid) + 1;
	                                    }
	                                    this.retryCount.set(characteristicUuid, count);
	                                }
	
	                                if (!(count < this.maxRetries)) {
	                                    _context7.next = 24;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('this.bluetoothIO is null when handling ' + _StringUtils2.default.getCharacteristicString(characteristic) + ' -- Retry count: ' + count + '/' + this.maxRetries);
	                                }
	                                setTimeout((0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6() {
	                                    return _regenerator2.default.wrap(function _callee6$(_context6) {
	                                        while (1) {
	                                            switch (_context6.prev = _context6.next) {
	                                                case 0:
	                                                    _context6.next = 2;
	                                                    return _this2.handleUpdatedInputServiceCharacteristic(characteristic);
	
	                                                case 2:
	                                                case 'end':
	                                                    return _context6.stop();
	                                            }
	                                        }
	                                    }, _callee6, _this2);
	                                })), _LegoDeviceManagerImpl2.default.getInstance().config.handleUpdatedInputRetryDelay);
	                                _context7.next = 25;
	                                break;
	
	                            case 24:
	                                throw new Error('BluetoothIO was not set -- Retry count: ' + count + '/' + this.maxRetries + ' - unable to perform' + ' handleUpdatedInputServiceCharacteristic - ' + _StringUtils2.default.getCharacteristicString(characteristic));
	
	                            case 25:
	                            case 'end':
	                                return _context7.stop();
	                        }
	                    }
	                }, _callee7, this);
	            }));
	
	            function handleUpdatedInputServiceCharacteristic(_x7) {
	                return _ref6.apply(this, arguments);
	            }
	
	            return handleUpdatedInputServiceCharacteristic;
	        }()
	
	        /**
	         * Delegates the call on to the proper characteristic value handler
	         * @param {NativeCharacteristic} characteristic
	         */
	
	    }, {
	        key: 'handleReadOrUpdatedCharacteristic',
	        value: function () {
	            var _ref8 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee8(characteristic) {
	                var cachedDevice, start, characteristicUuid;
	                return _regenerator2.default.wrap(function _callee8$(_context8) {
	                    while (1) {
	                        switch (_context8.prev = _context8.next) {
	                            case 0:
	                                if (!(!characteristic || characteristic === null)) {
	                                    _context8.next = 3;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug(this.constructor.name + '.handleReadOrUpdatedCharacteristic ignoring call -' + ' The characteristic parameter is not set or null');
	                                }
	                                return _context8.abrupt('return');
	
	                            case 3:
	                                cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	
	                                if (!(cachedDevice && cachedDevice !== null)) {
	                                    _context8.next = 9;
	                                    break;
	                                }
	
	                                if (!(this.instanceId !== cachedDevice.instanceId)) {
	                                    _context8.next = 9;
	                                    break;
	                                }
	
	                                _context8.next = 8;
	                                return cachedDevice.handleReadOrUpdatedCharacteristic(characteristic);
	
	                            case 8:
	                                return _context8.abrupt('return', _context8.sent);
	
	                            case 9:
	                                start = new Date().getTime();
	                                characteristicUuid = _UuidHelper2.default.getUuid(characteristic);
	
	                                if (!this.ioServiceDefinition.matchesService(characteristic.service)) {
	                                    _context8.next = 17;
	                                    break;
	                                }
	
	                                _context8.next = 14;
	                                return this.handleUpdatedInputServiceCharacteristic(characteristic);
	
	                            case 14:
	                                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                    _LDSDKLogger2.default.debug('this.bluetoothIO.handleUpdatedInputServiceCharacteristic(' + characteristicUuid + ') executed in ' + (new Date().getTime() - start) + 'ms for ' + _StringUtils2.default.getDeviceString(this));
	                                }
	                                _context8.next = 36;
	                                break;
	
	                            case 17:
	                                if (!this.deviceServiceDefinition.matchesService(characteristic.service)) {
	                                    _context8.next = 23;
	                                    break;
	                                }
	
	                                _context8.next = 20;
	                                return this.handleUpdatedDeviceServiceCharacteristic(characteristic);
	
	                            case 20:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('handleUpdatedDeviceServiceCharacteristic(' + characteristicUuid + ') executed in ' + (new Date().getTime() - start) + 'ms for ' + _StringUtils2.default.getDeviceString(this));
	                                }
	                                _context8.next = 36;
	                                break;
	
	                            case 23:
	                                if (!(characteristic && characteristic !== null && this.deviceInfoServiceDefinition.matchesService(characteristic.service))) {
	                                    _context8.next = 29;
	                                    break;
	                                }
	
	                                _context8.next = 26;
	                                return this.handleUpdatedDeviceInfoServiceCharacteristic(characteristic);
	
	                            case 26:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('handleUpdatedDeviceInfoServiceCharacteristic(' + characteristicUuid + ') executed in ' + (new Date().getTime() - start) + 'ms for ' + _StringUtils2.default.getDeviceString(this));
	                                }
	                                _context8.next = 36;
	                                break;
	
	                            case 29:
	                                if (!(_UuidHelper2.default.getUuid(this.batteryLevelCharacteristic) === characteristicUuid)) {
	                                    _context8.next = 35;
	                                    break;
	                                }
	
	                                _context8.next = 32;
	                                return this.handleUpdatedBatteryLevelCharacteristic(characteristic);
	
	                            case 32:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('handleUpdatedBatteryLevelCharacteristic(' + characteristicUuid + ') executed in ' + (new Date().getTime() - start) + 'ms for ' + _StringUtils2.default.getDeviceString(this));
	                                }
	                                _context8.next = 36;
	                                break;
	
	                            case 35:
	                                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                    _LDSDKLogger2.default.warn('Received update for unknown characteristic: ', characteristic, ' for ' + _StringUtils2.default.getDeviceString(this));
	                                }
	
	                            case 36:
	                            case 'end':
	                                return _context8.stop();
	                        }
	                    }
	                }, _callee8, this);
	            }));
	
	            function handleReadOrUpdatedCharacteristic(_x8) {
	                return _ref8.apply(this, arguments);
	            }
	
	            return handleReadOrUpdatedCharacteristic;
	        }()
	
	        /**
	         *
	         * @return {NativeDevice} The native Bluetooth device object
	         */
	
	    }, {
	        key: 'getBluetoothDevice',
	        value: function getBluetoothDevice() {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.getBluetoothDevice();
	                }
	            }
	            return this.bluetoothDeviceWrapper.getDevice();
	        }
	
	        /**
	         *
	         * @return {ChromeOsBluetoothDeviceWrapper} The device wrapper object
	         */
	
	    }, {
	        key: 'getBluetoothWrapper',
	        value: function getBluetoothWrapper() {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.getBluetoothWrapper();
	                }
	            }
	            return this.bluetoothDeviceWrapper;
	        }
	
	        /**
	         * Disconnect from the hub - by sending a message to the hub telling it to disconnect from the chromebook (since
	         * the Chromebook disconnect is currently broken - up to and including version 50, which is the latest version
	         * currently).
	         *
	         * @param {LegoBluetoothDeviceManagerImpl} bluetoothDeviceManager - .
	         * @param {bool} userInitiated - Boolean specifying if a user initiated this call, or the system initiated it.
	         *
	         * @return {Promise<Void>} Resolves after disconnect completes
	         */
	
	    }, {
	        key: 'disconnectGatt',
	        value: function () {
	            var _ref9 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee9(bluetoothDeviceManager, userInitiated) {
	                var _this3 = this;
	
	                var nativeDevice;
	                return _regenerator2.default.wrap(function _callee9$(_context9) {
	                    while (1) {
	                        switch (_context9.prev = _context9.next) {
	                            case 0:
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info('Calling disconnectGatt for ' + this.getName() + ' [' + this.getAddress() + '], userInitiated: ' + userInitiated);
	                                }
	                                /**
	                                 * @private
	                                 * @type {bool}
	                                 */
	                                this.userInitiatedDisconnect = userInitiated;
	                                this.resetQueue();
	
	                                if (!(this.disconnectCharacteristic !== null)) {
	                                    _context9.next = 16;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('Calling hub disconnect for ' + this.getName() + ' [' + this.getAddress() + ']');
	                                }
	                                _context9.next = 7;
	                                return this.legoDeviceManager.getBluetoothAdapter().getDevice(this.getDeviceId());
	
	                            case 7:
	                                nativeDevice = _context9.sent;
	
	                                if (!(nativeDevice && nativeDevice !== null && nativeDevice.connected === true)) {
	                                    _context9.next = 16;
	                                    break;
	                                }
	
	                                _context9.prev = 9;
	                                _context9.next = 12;
	                                return this.writeCharacteristic({
	                                    characteristic: {
	                                        instanceId: this.disconnectCharacteristic.instanceId
	                                    },
	                                    value: new Uint8Array([0]).buffer
	                                });
	
	                            case 12:
	                                _context9.next = 16;
	                                break;
	
	                            case 14:
	                                _context9.prev = 14;
	                                _context9.t0 = _context9['catch'](9);
	
	                            case 16:
	
	                                // Housekeeping
	                                try {
	                                    this.characteristicNotifications.forEach(function (characteristic, instanceId) {
	                                        if (characteristic && characteristic !== null) {
	                                            try {
	                                                _LDSDKLogger2.default.debug('Disabling characteristic notifications for  ' + _StringUtils2.default.getCharacteristicString(characteristic));
	                                                _this3.setCharacteristicNotification(characteristic, false);
	                                            } catch (err) {
	                                                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                                    _LDSDKLogger2.default.warn('Failed stopping characteristic notification for ' + _StringUtils2.default.getCharacteristicString(characteristic));
	                                                }
	                                            }
	                                        }
	                                    });
	                                } finally {
	                                    this.characteristicNotifications.clear();
	                                }
	                                // Stop the notifications when disconnecting - otherwise they will interfere with the next connect flow
	                                // this.setCharacteristicNotification(this.ioCharacteristic, false);
	                                // this.setCharacteristicNotification(this.buttonCharacteristic, false);
	                                // this.setCharacteristicNotification(this.lowVoltageAlertCharacteristic, false);
	
	                                _context9.prev = 17;
	                                _context9.next = 20;
	                                return this.getBluetoothWrapper().disconnect();
	
	                            case 20:
	                                _context9.next = 25;
	                                break;
	
	                            case 22:
	                                _context9.prev = 22;
	                                _context9.t1 = _context9['catch'](17);
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('Failed disconnecting in wrapper: ' + this.getErrorReason(_context9.t1));
	                                }
	
	                            case 25:
	
	                                this.deviceNativeServices.clear(); // Clear the cached services
	
	                                if (!userInitiated) {
	                                    _context9.next = 29;
	                                    break;
	                                }
	
	                                _context9.next = 29;
	                                return bluetoothDeviceManager.deviceDidDisconnect(this, 0, userInitiated);
	
	                            case 29:
	                                _context9.next = 31;
	                                return this.resetState();
	
	                            case 31:
	                            case 'end':
	                                return _context9.stop();
	                        }
	                    }
	                }, _callee9, this, [[9, 14], [17, 22]]);
	            }));
	
	            function disconnectGatt(_x9, _x10) {
	                return _ref9.apply(this, arguments);
	            }
	
	            return disconnectGatt;
	        }()
	
	        /**
	         *
	         * @param {NativeCharacteristic} characteristic
	         */
	
	    }, {
	        key: 'getCleanCharacteristic',
	        value: function getCleanCharacteristic(characteristic) {
	            if (!characteristic || characteristic === null) {
	                characteristic = {};
	            }
	            // Alternatively delete the 'value' property.
	            return {
	                uuid: characteristic.uuid,
	                instanceId: characteristic.instanceId,
	                properties: characteristic.properties
	            };
	        }
	
	        /**
	         * @ignore
	         *
	         */
	
	    }, {
	        key: 'getErrorReason',
	        value: function getErrorReason() {
	            var err = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	
	            if (err === null) return '';
	
	            if (typeof err === 'string') return err;
	
	            if (err.hasOwnProperty('message') && typeof err.message === 'string') return err.message;
	
	            return (0, _stringify2.default)(err);
	        }
	
	        /**
	         *
	         * @param {NativeCharacteristic} characteristic
	         * @param {number} [retryMaxAttempts = 5]
	         */
	
	    }, {
	        key: 'startCharacteristicNotificationsWithRetries',
	        value: function () {
	            var _ref10 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee11(characteristic) {
	                var _this4 = this;
	
	                var retry, res, retryMax;
	                return _regenerator2.default.wrap(function _callee11$(_context11) {
	                    while (1) {
	                        switch (_context11.prev = _context11.next) {
	                            case 0:
	                                if (!(characteristic === undefined || characteristic === null)) {
	                                    _context11.next = 3;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                    _LDSDKLogger2.default.warn('Illegal argument - startCharacteristicNotificationsWithRetries requires the characteristic parameter - it cannot be null or undefined');
	                                }
	                                return _context11.abrupt('return');
	
	                            case 3:
	                                retry = 1;
	
	                                if (this.startNotificationsRetryCount.has(characteristic.uuid)) {
	                                    retry = this.startNotificationsRetryCount.get(characteristic.uuid) + 1;
	                                }
	                                this.startNotificationsRetryCount.set(characteristic.uuid, retry);
	
	                                _context11.prev = 6;
	                                _context11.next = 9;
	                                return this.startCharacteristicNotifications(characteristic);
	
	                            case 9:
	                                res = _context11.sent;
	
	                                this.startNotificationsRetryCount.delete(characteristic.uuid);
	                                return _context11.abrupt('return', res);
	
	                            case 14:
	                                _context11.prev = 14;
	                                _context11.t0 = _context11['catch'](6);
	                                retryMax = _LegoDeviceManagerImpl2.default.getInstance().config.startCharacteristicNotificationsWhenConnectedRetryMax;
	
	                                if (_context11.t0.endsWith('Error: In progress')) {
	                                    // TODO: Consider retrying this call without increasing retry count since the bt adapter was unable to fulfill the call
	                                }
	
	                                if (!(retry < retryMax)) {
	                                    _context11.next = 23;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('await this.startCharacteristicNotifications(characteristic) failed - scheduling retry #' + retry + '/' + retryMax + ' - error: ' + this.getErrorReason(_context11.t0));
	                                }
	                                setTimeout((0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee10() {
	                                    return _regenerator2.default.wrap(function _callee10$(_context10) {
	                                        while (1) {
	                                            switch (_context10.prev = _context10.next) {
	                                                case 0:
	                                                    _context10.next = 2;
	                                                    return _this4.startCharacteristicNotificationsWithRetries(characteristic);
	
	                                                case 2:
	                                                    return _context10.abrupt('return', _context10.sent);
	
	                                                case 3:
	                                                case 'end':
	                                                    return _context10.stop();
	                                            }
	                                        }
	                                    }, _callee10, _this4);
	                                })), _LegoDeviceManagerImpl2.default.getInstance().config.startCharacteristicNotificationsWhenConnectedRetryDelay);
	                                _context11.next = 24;
	                                break;
	
	                            case 23:
	                                throw 'startCharacteristicNotificationsWithRetries failed all ' + retryMax + ' startCharacteristicNotifications attempts. Last error:  ' + this.getErrorReason(_context11.t0);
	
	                            case 24:
	                            case 'end':
	                                return _context11.stop();
	                        }
	                    }
	                }, _callee11, this, [[6, 14]]);
	            }));
	
	            function startCharacteristicNotificationsWithRetries(_x12) {
	                return _ref10.apply(this, arguments);
	            }
	
	            return startCharacteristicNotificationsWithRetries;
	        }()
	
	        /**
	         *
	         * @param {NativeService} service
	         *
	         * @return {Promise<>}
	         */
	
	    }, {
	        key: 'discoverCharacteristicsForService',
	        value: function () {
	            var _ref12 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee12(service) {
	                var cachedDevice, serviceDefinition;
	                return _regenerator2.default.wrap(function _callee12$(_context12) {
	                    while (1) {
	                        switch (_context12.prev = _context12.next) {
	                            case 0:
	                                if (!(!service || service === null)) {
	                                    _context12.next = 3;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                    _LDSDKLogger2.default.warn('Illegal argument - discoverCharacteristicsForService requires the service parameter, it must not be null or undefined');
	                                }
	                                return _context12.abrupt('return');
	
	                            case 3:
	                                cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	
	                                if (!(cachedDevice && cachedDevice !== null)) {
	                                    _context12.next = 9;
	                                    break;
	                                }
	
	                                if (!(this.instanceId !== cachedDevice.instanceId)) {
	                                    _context12.next = 9;
	                                    break;
	                                }
	
	                                _context12.next = 8;
	                                return cachedDevice.discoverCharacteristicsForService(service);
	
	                            case 8:
	                                return _context12.abrupt('return', _context12.sent);
	
	                            case 9:
	                                serviceDefinition = _BluetoothServiceDefinition2.default.serviceDefinitionWithUUID(_UuidHelper2.default.getUuid(service));
	
	                                if (!(serviceDefinition !== null)) {
	                                    _context12.next = 32;
	                                    break;
	                                }
	
	                                if (!_BluetoothServiceDefinition2.default.deviceInfoServiceDefinition().matchesService(service)) {
	                                    _context12.next = 16;
	                                    break;
	                                }
	
	                                _context12.next = 14;
	                                return this.discoverCharacteristicsForDeviceInfo(serviceDefinition, service);
	
	                            case 14:
	                                _context12.next = 32;
	                                break;
	
	                            case 16:
	                                if (!_BluetoothServiceDefinition2.default.deviceServiceDefinition().matchesService(service)) {
	                                    _context12.next = 21;
	                                    break;
	                                }
	
	                                _context12.next = 19;
	                                return this.discoverCharacteristicsForDevice(serviceDefinition, service);
	
	                            case 19:
	                                _context12.next = 32;
	                                break;
	
	                            case 21:
	                                if (!_BluetoothServiceDefinition2.default.ioServiceDefinition().matchesService(service)) {
	                                    _context12.next = 26;
	                                    break;
	                                }
	
	                                _context12.next = 24;
	                                return this.discoverCharacteristicsForIO(service);
	
	                            case 24:
	                                _context12.next = 32;
	                                break;
	
	                            case 26:
	                                if (!_BluetoothServiceDefinition2.default.batteryServiceDefinition().matchesService(service)) {
	                                    _context12.next = 31;
	                                    break;
	                                }
	
	                                _context12.next = 29;
	                                return this.discoverCharacteristicsForBattery(serviceDefinition, service);
	
	                            case 29:
	                                _context12.next = 32;
	                                break;
	
	                            case 31:
	                                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                    _LDSDKLogger2.default.warn('Discovered characteristics for unknown service with UUID ' + _UuidHelper2.default.getUuid(service));
	                                }
	
	                            case 32:
	                            case 'end':
	                                return _context12.stop();
	                        }
	                    }
	                }, _callee12, this);
	            }));
	
	            function discoverCharacteristicsForService(_x13) {
	                return _ref12.apply(this, arguments);
	            }
	
	            return discoverCharacteristicsForService;
	        }()
	    }, {
	        key: 'discoverCharacteristicsForBattery',
	        value: function () {
	            var _ref13 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee14(serviceDefinition, service) {
	                var _this5 = this;
	
	                var self;
	                return _regenerator2.default.wrap(function _callee14$(_context14) {
	                    while (1) {
	                        switch (_context14.prev = _context14.next) {
	                            case 0:
	                                /**
	                                 * @private
	                                 */
	                                this.batteryServiceDefinition = serviceDefinition;
	                                /**
	                                 * @private
	                                 * @type {NativeCharacteristic}
	                                 */
	                                _context14.next = 3;
	                                return _BluetoothHelper2.default.create(this.batteryServiceDefinition.getBatteryLevel().getUuid(), service);
	
	                            case 3:
	                                this.batteryLevelCharacteristic = _context14.sent;
	
	                                if (!(this.batteryLevelCharacteristic !== null)) {
	                                    _context14.next = 16;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('Battery level characteristic set to: ' + _UuidHelper2.default.getUuid(this.batteryLevelCharacteristic) + ' for device: ' + this.getName() + '[' + this.getAddress() + ']');
	                                }
	
	                                if (!_LegoDeviceManagerImpl2.default.getInstance().config.registerForBatteryLevelNotifications) {
	                                    _context14.next = 11;
	                                    break;
	                                }
	
	                                _context14.next = 9;
	                                return this.setCharacteristicNotification(this.batteryLevelCharacteristic, true);
	
	                            case 9:
	                                _context14.next = 14;
	                                break;
	
	                            case 11:
	                                _context14.next = 13;
	                                return this.addReadOfCharacteristicToQueue(this.batteryLevelCharacteristic);
	
	                            case 13:
	
	                                if (this.batteryIntervalId === null) {
	                                    self = this;
	                                    /**
	                                     * @private
	                                     * @type {*}
	                                     */
	
	                                    this.batteryIntervalId = setInterval((0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee13() {
	                                        return _regenerator2.default.wrap(function _callee13$(_context13) {
	                                            while (1) {
	                                                switch (_context13.prev = _context13.next) {
	                                                    case 0:
	                                                        if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                                            _LDSDKLogger2.default.debug('Scheduling a new read of the battery level');
	                                                        }
	                                                        _context13.next = 3;
	                                                        return _this5.addReadOfCharacteristicToQueue(_this5.batteryLevelCharacteristic);
	
	                                                    case 3:
	                                                    case 'end':
	                                                        return _context13.stop();
	                                                }
	                                            }
	                                        }, _callee13, _this5);
	                                    })), _LegoDeviceManagerImpl2.default.getInstance().config.batteryPollingInterval);
	                                }
	
	                            case 14:
	                                _context14.next = 17;
	                                break;
	
	                            case 16:
	                                _LDSDKLogger2.default.warn('Battery level characteristic is null for device: ' + this.getName() + '[' + this.getAddress() + ']');
	
	                            case 17:
	                            case 'end':
	                                return _context14.stop();
	                        }
	                    }
	                }, _callee14, this);
	            }));
	
	            function discoverCharacteristicsForBattery(_x14, _x15) {
	                return _ref13.apply(this, arguments);
	            }
	
	            return discoverCharacteristicsForBattery;
	        }()
	    }, {
	        key: 'discoverCharacteristicsForIO',
	        value: function () {
	            var _ref15 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee15(service) {
	                return _regenerator2.default.wrap(function _callee15$(_context15) {
	                    while (1) {
	                        switch (_context15.prev = _context15.next) {
	                            case 0:
	                                _LDSDKLogger2.default.info('BluetoothServiceDefinition.ioServiceDefinition() === ' + _StringUtils2.default.getInstanceString(service));
	                                /**
	                                 * @private
	                                 * BluetoothServiceDefinition.ioServiceDefinition() MUST be handled first in the 2nd run of
	                                 * discovering services as this service definition is used to set the BluetoothIO that all the
	                                 * services depend on.
	                                 * @type {BluetoothIO}
	                                 */
	
	                                if (!(this.bluetoothIO === null)) {
	                                    _context15.next = 9;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('Creating BluetoothIO for service: ' + _StringUtils2.default.getInstanceString(service));
	                                }
	                                _context15.next = 5;
	                                return _BluetoothIO2.default.bluetoothIO(service, this);
	
	                            case 5:
	                                this.bluetoothIO = _context15.sent;
	                                // registers for characteristic notifications for updatedInputValueCharacteristic, and updatedInputFormatCharacteristic
	                                if (this.bluetoothIO === null) {
	                                    _LDSDKLogger2.default.error('Failed creating bluetoothIO for IO service: ' + _StringUtils2.default.getInstanceString(service));
	                                } else {
	                                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                        _LDSDKLogger2.default.debug('Created bluetoothIO instance for IO service: ' + _StringUtils2.default.getInstanceString(service));
	                                    }
	                                }
	                                _context15.next = 10;
	                                break;
	
	                            case 9:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('BluetoothIO instance already exists for service: ' + _StringUtils2.default.getInstanceString(service));
	                                }
	
	                            case 10:
	                            case 'end':
	                                return _context15.stop();
	                        }
	                    }
	                }, _callee15, this);
	            }));
	
	            function discoverCharacteristicsForIO(_x16) {
	                return _ref15.apply(this, arguments);
	            }
	
	            return discoverCharacteristicsForIO;
	        }()
	    }, {
	        key: 'discoverCharacteristicsForDevice',
	        value: function () {
	            var _ref16 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee16(serviceDefinition, service) {
	                var _this6 = this;
	
	                return _regenerator2.default.wrap(function _callee16$(_context16) {
	                    while (1) {
	                        switch (_context16.prev = _context16.next) {
	                            case 0:
	                                // LDSDKLogger.warn('Service '+service.uuid+' is a deviceServiceDefinition');
	                                /**
	                                 * @private
	                                 */
	                                this.deviceServiceDefinition = serviceDefinition;
	
	                                /**
	                                 * @private
	                                 */
	                                _context16.next = 3;
	                                return _BluetoothHelper2.default.create(this.deviceServiceDefinition.getDeviceName().getUuid(), service);
	
	                            case 3:
	                                this.nameCharacteristic = _context16.sent;
	                                _context16.next = 6;
	                                return _BluetoothHelper2.default.create(this.deviceServiceDefinition.getAttachedIO().getUuid(), service);
	
	                            case 6:
	                                this.ioCharacteristic = _context16.sent;
	                                _context16.next = 9;
	                                return _BluetoothHelper2.default.create(this.deviceServiceDefinition.getDisconnect().getUuid(), service);
	
	                            case 9:
	                                this.disconnectCharacteristic = _context16.sent;
	                                _context16.next = 12;
	                                return _BluetoothHelper2.default.create(this.deviceServiceDefinition.getDeviceButton().getUuid(), service);
	
	                            case 12:
	                                this.buttonCharacteristic = _context16.sent;
	                                _context16.next = 15;
	                                return _BluetoothHelper2.default.create(this.deviceServiceDefinition.getLowVoltageAlert().getUuid(), service);
	
	                            case 15:
	                                this.lowVoltageAlertCharacteristic = _context16.sent;
	
	                                if (!(this.nameCharacteristic !== null)) {
	                                    _context16.next = 20;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('Succesfully added device "name" characteristic: ' + _UuidHelper2.default.getUuid(this.nameCharacteristic));
	                                }
	                                _context16.next = 20;
	                                return this.addReadOfCharacteristicToQueue(this.nameCharacteristic);
	
	                            case 20:
	                                if (this.ioCharacteristic !== null) {
	                                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                        _LDSDKLogger2.default.debug('Succesfully added device "Attached IO" characteristic: ' + _UuidHelper2.default.getUuid(this.ioCharacteristic));
	                                    }
	                                    this.setCharacteristicNotification(this.ioCharacteristic, true).catch(function (err) {
	                                        if (_LDSDKLogger2.default.isErrorEnabled()) {
	                                            _LDSDKLogger2.default.error('Failed starting "Attached IO" characteristic notifications. Characteristic uuid: ' + _UuidHelper2.default.getUuid(_this6.ioCharacteristic) + ' - error: ', _this6.getErrorReason(err));
	                                        }
	                                        throw err;
	                                    });
	                                }
	                                if (this.disconnectCharacteristic !== null) {
	                                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                        _LDSDKLogger2.default.debug('Succesfully added device "Disconnect" characteristic: ' + _UuidHelper2.default.getUuid(this.disconnectCharacteristic));
	                                    }
	                                }
	                                if (this.buttonCharacteristic !== null) {
	                                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                        _LDSDKLogger2.default.debug('Succesfully added device "Button state" characteristic: ' + _UuidHelper2.default.getUuid(this.buttonCharacteristic));
	                                    }
	                                    this.setCharacteristicNotification(this.buttonCharacteristic, true).catch(function (err) {
	                                        if (_LDSDKLogger2.default.isErrorEnabled()) {
	                                            _LDSDKLogger2.default.error('Failed starting "Button state" characteristic notifications. Characteristic uuid: ' + _UuidHelper2.default.getUuid(_this6.ioCharacteristic) + ' - error: ', _this6.getErrorReason(err));
	                                        }
	                                        throw err;
	                                    });
	                                }
	                                if (this.lowVoltageAlertCharacteristic !== null) {
	                                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                        _LDSDKLogger2.default.debug('Succesfully added device "Low Voltage Alert" characteristic: ' + this.lowVoltageAlertCharacteristic);
	                                    }
	                                    this.setCharacteristicNotification(this.lowVoltageAlertCharacteristic, true).catch(function (err) {
	                                        if (_LDSDKLogger2.default.isErrorEnabled()) {
	                                            _LDSDKLogger2.default.error('Failed starting "Low Voltage Alert" characteristic notifications. Characteristic uuid: ' + _UuidHelper2.default.getUuid(_this6.ioCharacteristic) + ' - error: ', _this6.getErrorReason(err));
	                                        }
	                                        throw err;
	                                    });
	                                }
	
	                            case 24:
	                            case 'end':
	                                return _context16.stop();
	                        }
	                    }
	                }, _callee16, this);
	            }));
	
	            function discoverCharacteristicsForDevice(_x17, _x18) {
	                return _ref16.apply(this, arguments);
	            }
	
	            return discoverCharacteristicsForDevice;
	        }()
	    }, {
	        key: 'discoverCharacteristicsForDeviceInfo',
	        value: function () {
	            var _ref17 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee17(serviceDefinition, service) {
	                return _regenerator2.default.wrap(function _callee17$(_context17) {
	                    while (1) {
	                        switch (_context17.prev = _context17.next) {
	                            case 0:
	
	                                /**
	                                 * @private
	                                 */
	                                this.deviceInfoServiceDefinition = serviceDefinition;
	
	                                /**
	                                 * @private
	                                 */
	                                _context17.next = 3;
	                                return _BluetoothHelper2.default.create(this.deviceInfoServiceDefinition.getFirmwareRevision().getUuid(), service);
	
	                            case 3:
	                                this.firmwareRevisionCharacteristic = _context17.sent;
	                                _context17.next = 6;
	                                return _BluetoothHelper2.default.create(this.deviceInfoServiceDefinition.getHardwareRevision().getUuid(), service);
	
	                            case 6:
	                                this.hardwareRevisionCharacteristic = _context17.sent;
	                                _context17.next = 9;
	                                return _BluetoothHelper2.default.create(this.deviceInfoServiceDefinition.getSoftwareRevision().getUuid(), service);
	
	                            case 9:
	                                this.softwareRevisionCharacteristic = _context17.sent;
	                                _context17.next = 12;
	                                return _BluetoothHelper2.default.create(this.deviceInfoServiceDefinition.getManufacturerName().getUuid(), service);
	
	                            case 12:
	                                this.manufacturerCharacteristic = _context17.sent;
	
	                                if (!(this.firmwareRevisionCharacteristic !== null)) {
	                                    _context17.next = 17;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info('addReadOfCharacteristicToQueue - firmwareRevisionCharacteristic: ', _UuidHelper2.default.getUuid(this.firmwareRevisionCharacteristic));
	                                }
	                                _context17.next = 17;
	                                return this.addReadOfCharacteristicToQueue(this.firmwareRevisionCharacteristic);
	
	                            case 17:
	                                if (!(this.hardwareRevisionCharacteristic !== null)) {
	                                    _context17.next = 21;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info('addReadOfCharacteristicToQueue - hardwareRevisionCharacteristic: ', _UuidHelper2.default.getUuid(this.hardwareRevisionCharacteristic));
	                                }
	                                _context17.next = 21;
	                                return this.addReadOfCharacteristicToQueue(this.hardwareRevisionCharacteristic);
	
	                            case 21:
	                                if (!(this.softwareRevisionCharacteristic !== null)) {
	                                    _context17.next = 25;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info('addReadOfCharacteristicToQueue - softwareRevisionCharacteristic: ', _UuidHelper2.default.getUuid(this.softwareRevisionCharacteristic));
	                                }
	                                _context17.next = 25;
	                                return this.addReadOfCharacteristicToQueue(this.softwareRevisionCharacteristic);
	
	                            case 25:
	                                if (!(this.manufacturerCharacteristic !== null)) {
	                                    _context17.next = 29;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info('addReadOfCharacteristicToQueue - manufacturerCharacteristic: ', _UuidHelper2.default.getUuid(this.manufacturerCharacteristic));
	                                }
	                                _context17.next = 29;
	                                return this.addReadOfCharacteristicToQueue(this.manufacturerCharacteristic);
	
	                            case 29:
	                            case 'end':
	                                return _context17.stop();
	                        }
	                    }
	                }, _callee17, this);
	            }));
	
	            function discoverCharacteristicsForDeviceInfo(_x19, _x20) {
	                return _ref17.apply(this, arguments);
	            }
	
	            return discoverCharacteristicsForDeviceInfo;
	        }()
	
	        /**
	         *
	         * @param {NativeCharacteristic} characteristic
	         *
	         * @return {Promise}
	         */
	
	    }, {
	        key: 'addReadOfCharacteristicToQueue',
	        value: function () {
	            var _ref18 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee18(characteristic) {
	                var cachedDevice, cleanCharacteristic;
	                return _regenerator2.default.wrap(function _callee18$(_context18) {
	                    while (1) {
	                        switch (_context18.prev = _context18.next) {
	                            case 0:
	                                cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	
	                                if (!(cachedDevice && cachedDevice !== null)) {
	                                    _context18.next = 7;
	                                    break;
	                                }
	
	                                if (!(this.instanceId !== cachedDevice.instanceId)) {
	                                    _context18.next = 7;
	                                    break;
	                                }
	
	                                this.resetQueue();
	                                _context18.next = 6;
	                                return cachedDevice.addReadOfCharacteristicToQueue(characteristic);
	
	                            case 6:
	                                return _context18.abrupt('return', _context18.sent);
	
	                            case 7:
	                                cleanCharacteristic = this.getCleanCharacteristic(characteristic);
	                                _context18.next = 10;
	                                return this.addOperationToSynchronousQueue(cleanCharacteristic, null);
	
	                            case 10:
	                            case 'end':
	                                return _context18.stop();
	                        }
	                    }
	                }, _callee18, this);
	            }));
	
	            function addReadOfCharacteristicToQueue(_x21) {
	                return _ref18.apply(this, arguments);
	            }
	
	            return addReadOfCharacteristicToQueue;
	        }()
	
	        /**
	         *
	         * @param {NativeCharacteristic} characteristic
	         * @param {ArrayBuffer} data
	         *
	         * @return {Promise}
	         */
	
	    }, {
	        key: 'addWriteOfCharacteristicToQueue',
	        value: function () {
	            var _ref19 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee19(characteristic, data) {
	                var cachedDevice, cleanCharacteristic;
	                return _regenerator2.default.wrap(function _callee19$(_context19) {
	                    while (1) {
	                        switch (_context19.prev = _context19.next) {
	                            case 0:
	                                cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	
	                                if (!(cachedDevice && cachedDevice !== null)) {
	                                    _context19.next = 7;
	                                    break;
	                                }
	
	                                if (!(this.instanceId !== cachedDevice.instanceId)) {
	                                    _context19.next = 7;
	                                    break;
	                                }
	
	                                this.resetQueue();
	                                _context19.next = 6;
	                                return cachedDevice.addWriteOfCharacteristicToQueue(characteristic, data);
	
	                            case 6:
	                                return _context19.abrupt('return', _context19.sent);
	
	                            case 7:
	                                cleanCharacteristic = this.getCleanCharacteristic(characteristic);
	
	                                cleanCharacteristic.value = data;
	
	                                _context19.next = 11;
	                                return this.addOperationToSynchronousQueue(cleanCharacteristic, null);
	
	                            case 11:
	                            case 'end':
	                                return _context19.stop();
	                        }
	                    }
	                }, _callee19, this);
	            }));
	
	            function addWriteOfCharacteristicToQueue(_x22, _x23) {
	                return _ref19.apply(this, arguments);
	            }
	
	            return addWriteOfCharacteristicToQueue;
	        }()
	
	        /**
	         * Add operation to queue and wait for it to execute (or be queued)
	         * @param {NativeCharacteristic} characteristic
	         * @param {NativeDescriptor} descriptor
	         * @param {function} promise  A function that returns a promise that resolves once completed or rejects if failed
	         */
	
	    }, {
	        key: 'addOperationToSynchronousQueue',
	        value: function () {
	            var _ref20 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee21() {
	                var characteristic = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	
	                var _this7 = this;
	
	                var descriptor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	                var promise = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	                var cachedDevice;
	                return _regenerator2.default.wrap(function _callee21$(_context21) {
	                    while (1) {
	                        switch (_context21.prev = _context21.next) {
	                            case 0:
	                                cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	
	                                if (!(cachedDevice && cachedDevice !== null)) {
	                                    _context21.next = 8;
	                                    break;
	                                }
	
	                                if (!(this.instanceId !== cachedDevice.instanceId)) {
	                                    _context21.next = 8;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                    _LDSDKLogger2.default.warn('Two instances of LegoBluetoothDeviceImpl for ' + this.getDeviceId() + ' detected.' + ' Canceling addOperationToSynchronousQueue for ' + this.instanceId + ', continuing flow with cached instance: ' + cachedDevice.instanceId);
	                                }
	                                this.resetQueue();
	                                _context21.next = 7;
	                                return cachedDevice.addOperationToSynchronousQueue(characteristic, descriptor, promise);
	
	                            case 7:
	                                return _context21.abrupt('return', _context21.sent);
	
	                            case 8:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('addOperationToSynchronousQueue(' + _StringUtils2.default.getCharacteristicString(characteristic) + ', Queue length before add: ' + this.getQueueSize());
	                                }
	                                if (characteristic !== null) {
	                                    this.synchronousOperationsQueue.push(SynchronousQueueElement.fromCharacteristic(characteristic, characteristic.value));
	                                } else if (descriptor !== null) {
	                                    this.synchronousOperationsQueue.push(SynchronousQueueElement.fromDescriptor(descriptor, descriptor.value));
	                                } else if (promise !== null) {
	                                    this.synchronousOperationsQueue.push(SynchronousQueueElement.fromPromise(promise));
	                                } else {
	                                    _LDSDKLogger2.default.warn('None of the operation arguments were set - skipping addOperationToSynchronousQueue');
	                                }
	
	                                if (this.getQueueSize() === 1) {
	                                    setTimeout((0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee20() {
	                                        return _regenerator2.default.wrap(function _callee20$(_context20) {
	                                            while (1) {
	                                                switch (_context20.prev = _context20.next) {
	                                                    case 0:
	                                                        if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                                            _LDSDKLogger2.default.info('Queue size is 1 - start consuming queue asynchronously');
	                                                        }
	                                                        _context20.next = 3;
	                                                        return _this7.executeNextOperationQueue();
	
	                                                    case 3:
	                                                    case 'end':
	                                                        return _context20.stop();
	                                                }
	                                            }
	                                        }, _callee20, _this7);
	                                    })), 0);
	                                }
	
	                            case 11:
	                            case 'end':
	                                return _context21.stop();
	                        }
	                    }
	                }, _callee21, this);
	            }));
	
	            function addOperationToSynchronousQueue() {
	                return _ref20.apply(this, arguments);
	            }
	
	            return addOperationToSynchronousQueue;
	        }()
	
	        /**
	         *
	         * @param {SynchronousQueueElement} element
	         * @return {Promise<Void>}
	         */
	
	    }, {
	        key: 'writeCharacteristic',
	        value: function writeCharacteristic(element) {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.writeCharacteristic(element);
	                }
	            }
	
	            return this.getBluetoothWrapper().writeCharacteristic(element);
	        }
	
	        /**
	         *
	         * @param {SynchronousQueueElement} element
	         * @return {Promise<NativeCharacteristic>} - The result
	         */
	
	    }, {
	        key: 'readCharacteristic',
	        value: function readCharacteristic(element) {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.readCharacteristic(element);
	                }
	            }
	
	            return this.getBluetoothWrapper().readCharacteristic(element);
	        }
	
	        /**
	         * Calling this function will execute the first element in the queue. If an operation is already executing the
	         * queue size is checked, if it is greater than 0 a new poll of the queue is scheduled.
	         * @return {Promise<Void>} Resolves once the operations has been handled. Rejects in case of errors.
	         */
	
	    }, {
	        key: 'executeNextOperationQueue',
	        value: function executeNextOperationQueue() {
	            var _this8 = this;
	
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    this.resetQueue();
	                    return cachedDevice.executeNextOperationQueue();
	                }
	            }
	
	            var self = this;
	            return new _promise2.default(function (resolve, reject) {
	                try {
	                    var _cachedDevice = self.legoDeviceManager.getDevice(self.getDeviceId(), false);
	                    if (_cachedDevice && _cachedDevice !== null) {
	                        if (self.instanceId !== _cachedDevice.instanceId) {
	                            _LDSDKLogger2.default.error(self.instanceId + ' ' + self.getName() + ' [' + self.getDeviceId() + '] - This instance is not the same as the cached instance - abort executeNextOperationQueue');
	                            return resolve();
	                        }
	                    }
	                    if (!self.operationExecuting) {
	                        var element = self.synchronousOperationsQueue.splice(0, 1)[0]; // pops first item from array and stores it in element
	
	                        if (element) {
	                            self.setExecutingFlag(true);
	                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                _LDSDKLogger2.default.debug(self.instanceId + ' ' + self.getName() + ' [' + self.getDeviceId() + '] - Popped element ' + _StringUtils2.default.getCharacteristicString(element.characteristic, element.value) + ' from queue. Queue size: ' + self.getQueueSize());
	                            }
	                            self.messagesHandled++;
	                            if (element.characteristic !== null && element.characteristic !== undefined) {
	                                var props = element.characteristic.properties;
	                                if (props && props !== null && element.value !== null && element.value !== undefined && props.indexOf('write') >= 0) {
	                                    var start = new Date().getTime();
	                                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                        _LDSDKLogger2.default.debug(self.instanceId + ' ' + self.getName() + ' [' + self.getDeviceId() + '] - executeNextOperationQueue element (write): ' + _UuidHelper2.default.getUuid(element.characteristic) + ', Value: ' + new Int8Array(element.value));
	                                    }
	                                    self.writeCharacteristic(element).then(function () {
	                                        if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                            _LDSDKLogger2.default.trace(self.instanceId + ' ' + self.getName() + ' [' + self.getDeviceId() + '] - executeNextOperationQueue writeCharacteristic completed in ' + (new Date().getTime() - start) + ' ms');
	                                        }
	                                    }).then(function () {
	                                        self.setExecutingFlag(false);
	                                        return resolve();
	                                    }).catch(function (err) {
	                                        if (_LDSDKLogger2.default.isErrorEnabled()) {
	                                            _LDSDKLogger2.default.error(self.instanceId + ' ' + self.getName() + ' [' + self.getDeviceId() + '] - executeNextOperationQueue writeCharacteristic (' + _StringUtils2.default.getCharacteristicString(element.characteristic, element.value) + ')  Failed after ' + (new Date().getTime() - start) + ' ms. Reason: ' + _this8.getErrorReason(err));
	                                        }
	                                        self.setExecutingFlag(false);
	                                        return reject(err);
	                                    });
	                                } else if (!props || props === null || props.indexOf('read') >= 0) {
	                                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                        _LDSDKLogger2.default.debug(self.instanceId + ' ' + self.getName() + ' [' + self.getDeviceId() + '] - executeNextOperationQueue element (read): ' + _UuidHelper2.default.getUuid(element.characteristic) + ' - characteristic properties: ' + props);
	                                    }
	                                    var _start = new Date().getTime();
	                                    self.readCharacteristic(element).then(function (result) {
	                                        if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                            _LDSDKLogger2.default.trace(self.instanceId + ' ' + self.getName() + ' [' + self.getDeviceId() + '] - executeNextOperationQueue readCharacteristic completed in ' + (new Date().getTime() - _start) + ' ms');
	                                        }
	                                        self.handleReadOrUpdatedCharacteristic(result);
	                                    }).then(function () {
	                                        self.setExecutingFlag(false);
	                                        return resolve();
	                                    }).catch(function (err) {
	                                        if (_LDSDKLogger2.default.isErrorEnabled()) {
	                                            _LDSDKLogger2.default.error(self.instanceId + ' ' + self.getName() + ' [' + self.getDeviceId() + '] - executeNextOperationQueue readCharacteristic Failed after ' + (new Date().getTime() - _start) + ' ms');
	                                            _LDSDKLogger2.default.error(_this8.getErrorReason(err));
	                                        }
	                                        self.setExecutingFlag(false);
	                                        return reject(err);
	                                    });
	                                } else {
	                                    if (_LDSDKLogger2.default.isErrorEnabled()) {
	                                        _LDSDKLogger2.default.error('Neither a write nor a read - operation cannot be executed. Dumping element to log', element);
	                                    }
	                                }
	                            } else if (element.descriptor !== undefined && element.descriptor !== null) {
	                                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                    _LDSDKLogger2.default.warn('TODO :: Descriptor call not yet implemented');
	                                }
	                                if (element.value !== null) {
	                                    element.descriptor.setValue(element.value);
	                                    // self.bluetoothGatt.writeDescriptor(element.descriptor); //TODO implement using
	                                    // chrome.bluetoothLowEnergy
	                                } else {
	                                        // self.bluetoothGatt.readDescriptor(element.descriptor); // TODO implement using
	                                        // chrome.bluetoothLowEnergy
	                                    }
	                                self.setExecutingFlag(false);
	                                return resolve();
	                            } else if (element.promise !== undefined && element.promise !== null) {
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('executeNextOperationQueue - start executing promise in Queue');
	                                }
	                                return element.promise().then(function () {
	                                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                        _LDSDKLogger2.default.debug('executeNextOperationQueue - completed executing promise in Queue');
	                                    }
	                                    self.setExecutingFlag(false);
	                                    return resolve();
	                                }).catch(function (err) {
	                                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                        _LDSDKLogger2.default.debug('executeNextOperationQueue - failed executing promise in Queue - error: ' + _this8.getErrorReason(err));
	                                    }
	                                    self.setExecutingFlag(false);
	                                    return reject(err);
	                                });
	                            }
	                        } else {
	                            self.setExecutingFlag(false);
	                        }
	                    } else {
	                        if (self.getQueueSize() > 0) {
	                            if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                _LDSDKLogger2.default.debug('Operation executing -- Queue size: ' + self.getQueueSize());
	                            }
	                            self.schedulePollQueueIfNotEmpty();
	                        }
	                        return resolve();
	                    }
	                } catch (err) {
	                    self.setExecutingFlag(false);
	                    return reject(self.instanceId + ' ' + self.getName() + ' [' + self.getDeviceId() + '] - executeNextOperationQueue failed: ' + _this8.getErrorReason(err));
	                }
	            });
	        }
	    }, {
	        key: 'schedulePollQueueIfNotEmpty',
	        value: function schedulePollQueueIfNotEmpty() {
	            var _this9 = this;
	
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return;
	                }
	            }
	
	            if (this.executeNextOperationQueueTimer !== null) {
	                clearTimeout(this.executeNextOperationQueueTimer);
	            }
	            if (this.getQueueSize() > 0) {
	                /**
	                 * @private
	                 */
	                this.executeNextOperationQueueTimer = setTimeout((0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee22() {
	                    return _regenerator2.default.wrap(function _callee22$(_context22) {
	                        while (1) {
	                            switch (_context22.prev = _context22.next) {
	                                case 0:
	                                    /**
	                                     * @private
	                                     */
	                                    _this9.executeNextOperationQueueTimer = null;
	                                    _this9.executeNextOperationQueue();
	
	                                case 2:
	                                case 'end':
	                                    return _context22.stop();
	                            }
	                        }
	                    }, _callee22, _this9);
	                })), _LegoDeviceManagerImpl2.default.getInstance().config.synchronousOperationsQueuePollDelay);
	            }
	        }
	    }, {
	        key: 'setExecutingFlag',
	
	
	        /**
	         * @param {bool} executing
	         */
	        value: function setExecutingFlag(executing) {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return;
	                }
	            }
	
	            if (_LDSDKLogger2.default.isTraceEnabled()) {
	                _LDSDKLogger2.default.debug('Set operation executing = ' + executing);
	            }
	            /**
	             * @private
	             */
	            this.operationExecuting = executing;
	            this.schedulePollQueueIfNotEmpty();
	        }
	    }, {
	        key: 'registerOnCharacteristicListeners',
	        value: function registerOnCharacteristicListeners() {
	            this.legoDeviceManager.getBluetoothAdapter().registerOnCharacteristicValueChangedListener();
	        }
	    }, {
	        key: 'startCharacteristicNotifications',
	
	        /**
	         *
	         * @param {NativeCharacteristic} characteristic
	         * @return {Promise} - Resolves when the BLE adapter acknowledges that characteristic notifications has
	         * been started. Rejects in case of errors.
	         */
	        value: function startCharacteristicNotifications(characteristic) {
	            var _this10 = this;
	
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.startCharacteristicNotifications(characteristic);
	                }
	            }
	
	            var self = this;
	            return new _promise2.default(function (resolve, reject) {
	                if (characteristic.service && characteristic.service.deviceAddress && characteristic.service.deviceAddress !== _this10.getDeviceId()) {
	                    if (_LDSDKLogger2.default.isInfoEnabled()) {
	                        _LDSDKLogger2.default.info('The characteristic is not attached to the current device - ignoring it');
	                    }
	                    return resolve();
	                }
	
	                var timerId = _TimerUtil2.default.startTimer();
	                if (!self.characteristicNotifications.has(characteristic.instanceId)) {
	                    if (_LDSDKLogger2.default.isInfoEnabled()) {
	                        _LDSDKLogger2.default.info('startCharacteristicNotifications for ' + _StringUtils2.default.getCharacteristicString(characteristic) + ' --- ' + self.toString());
	                    }
	                    return _this10.getBluetoothWrapper().startCharacteristicNotification(characteristic).then(function () {
	                        self.characteristicNotifications.set(characteristic.instanceId, characteristic);
	                        if (_LDSDKLogger2.default.isDebugEnabled()) {
	                            _LDSDKLogger2.default.debug('Completed startCharacteristicNotification in ' + _TimerUtil2.default.stopTimer(timerId) + 'ms');
	                        }
	                        return resolve();
	                    }).catch(function (err) {
	                        if (_LDSDKLogger2.default.isErrorEnabled()) {
	                            _LDSDKLogger2.default.error(err);
	                        }
	                        self.characteristicNotifications.delete(characteristic.instanceId);
	                        // TODO: Consider rescheduling a call to startCharacteristicNotifications after a delay
	                        return reject(err);
	                    });
	                } else {
	                    if (_LDSDKLogger2.default.isInfoEnabled()) {
	                        _LDSDKLogger2.default.info('startCharacteristicNotifications already registered for ' + _StringUtils2.default.getCharacteristicString(characteristic) + ' --- ' + self.toString());
	                    }
	                    return resolve();
	                }
	            });
	        }
	
	        /**
	         *
	         * @param {NativeCharacteristic} characteristic
	         * @param {bool} enable
	         * @return {Promise.<void>} - Resolves when the BLE adapter acknowledges that characteristic notifications has
	         * been enable- or disabled. Rejects in case of errors.
	         */
	
	    }, {
	        key: 'setCharacteristicNotification',
	        value: function setCharacteristicNotification(characteristic, enable) {
	            var _this11 = this;
	
	            if (characteristic === undefined || characteristic === null) {
	                if (_LDSDKLogger2.default.isErrorEnabled()) {
	                    _LDSDKLogger2.default.error('setCharacteristicNotification got characteristic that is null or undefined, unable to set notifications=' + enable);
	                }
	                return _promise2.default.reject('setCharacteristicNotification got characteristic that is null or undefined, unable to set notifications=' + enable);
	            }
	
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.setCharacteristicNotification(characteristic, enable);
	                }
	            }
	
	            var self = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                    _LDSDKLogger2.default.info((enable ? 'Starting' : 'Stopping') + ' notifications for ' + _StringUtils2.default.getCharacteristicString(characteristic));
	                }
	                var start = new Date().getTime();
	                if (enable) {
	                    var _cachedDevice2 = _this11.legoDeviceManager.getDevice(_this11.getDeviceId(), false);
	                    if (_cachedDevice2 && _cachedDevice2 !== null) {
	                        if (_this11.instanceId !== _cachedDevice2.instanceId) {
	                            _LDSDKLogger2.default.error(_this11.instanceId + ' ' + _this11.getName() + ' [' + _this11.getDeviceId() + '] - This instance is not the same as the cached instance - Abort enabling characteristic notification');
	                            return;
	                        }
	                    }
	                    if (characteristic.properties.indexOf('notify') < 0) {
	                        return reject('Characteristic does not support property \'notify\' - properties:' + characteristic.properties);
	                    }
	
	                    self.registerOnCharacteristicListeners(); // Only registers a characteristic listener if there is not already a listener registered
	
	                    return self.startCharacteristicNotificationsWithRetries(characteristic).then(function () {
	                        if (_LDSDKLogger2.default.isInfoEnabled()) {
	                            _LDSDKLogger2.default.info('Done startCharacteristicNotificationsWithRetries ' + _StringUtils2.default.getCharacteristicString(characteristic) + ' in ' + (new Date().getTime() - start) + ' ms');
	                        }
	                        return resolve();
	                    }).catch(function (err) {
	                        var msg = 'Failed starting characteristic notification for ' + _StringUtils2.default.getCharacteristicString(characteristic) + ' Error: ' + _this11.getErrorReason(err);
	                        if (_LDSDKLogger2.default.isErrorEnabled()) {
	                            _LDSDKLogger2.default.error(msg);
	                        }
	                        return reject(msg);
	                    }).then(function () {
	                        if (characteristic.properties.indexOf('read') >= 0) {
	                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                _LDSDKLogger2.default.debug('Adding read of characteristic to queue - ' + _StringUtils2.default.getCharacteristicString(characteristic));
	                            }
	                            return self.addOperationToSynchronousQueue(characteristic, null, null);
	                            // Trigger a first read of the characteristic we have just subscribed to notifications for
	                        } else {
	                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                _LDSDKLogger2.default.debug('No "read" property found for characteristic - ' + _StringUtils2.default.getCharacteristicString(characteristic));
	                            }
	                            return resolve();
	                        }
	                    }).catch(function (err) {
	                        return reject('Failed adding read operation to queue after starting notification for characteristic - ' + _StringUtils2.default.getCharacteristicString(characteristic) + '. Error: ' + _this11.getErrorReason(err));
	                    });
	
	                    // // Add promise to queue that starts characteristic notification for
	                    // this.addOperationToSynchronousQueue(null, null, () => {
	                    //     return new Promise((resolve, reject) => {
	                    //
	                    //     })
	                    // })
	                    // .then(() => {
	                    //     return resolve();
	                    // })
	                    // .catch(err => {
	                    //     return reject('Failed adding startCharacteristicNotifications promise to synchronous queue for characteristic ' + StringUtils.getCharacteristicString(characteristic) + '. Error: ' + this.getErrorReason(err));
	                    // });
	                } else {
	                    if (_LDSDKLogger2.default.isInfoEnabled()) {
	                        _LDSDKLogger2.default.info('stopCharacteristicNotifications for ' + _StringUtils2.default.getCharacteristicString(characteristic) + ' --- ' + self.toString());
	                    }
	                    var stopCharacteristicTimer = _TimerUtil2.default.startTimer();
	                    return _this11.getBluetoothWrapper().stopCharacteristicNotification(characteristic).then(function () {
	                        self.characteristicNotifications.delete(characteristic.instanceId);
	                        if (_LDSDKLogger2.default.isDebugEnabled()) {
	                            _LDSDKLogger2.default.debug('Completed stopCharacteristicNotification for ' + _StringUtils2.default.getCharacteristicString(characteristic) + ' in ' + _TimerUtil2.default.stopTimer(stopCharacteristicTimer) + 'ms');
	                        }
	                        return resolve();
	                    }).catch(function (err) {
	                        return reject(err);
	                    });
	                }
	                // return resolve();
	            }).catch(function (err) {
	                _LDSDKLogger2.default.error('setCharacteristicNotification failure. Enable: ' + enable + '. ' + _StringUtils2.default.getCharacteristicString(characteristic) + '. Error reason: \'' + _this11.getErrorReason(err) + '\'');
	            });
	        }
	    }, {
	        key: 'getScanRecord',
	        value: function getScanRecord() {
	            return this.scanRecord;
	        }
	
	        /**
	         *
	         * @param {string} error
	         * @param {number} newState - One of the constants defined in StateEnum
	         */
	
	    }, {
	        key: 'updateConnectionStateUponConnectionStateChange',
	        value: function updateConnectionStateUponConnectionStateChange(error, newState) {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    cachedDevice.updateConnectionStateUponConnectionStateChange(error, newState);
	                    return;
	                }
	            }
	            if (error && error !== null) {
	                this.updateDeviceState(_LegoDeviceImpl2.StateEnum.DisconnectedNotAdvertising);
	                return;
	            }
	
	            switch (newState) {
	                case _LegoDeviceImpl2.StateEnum.Interrogating:
	                    this.updateDeviceState(_LegoDeviceImpl2.StateEnum.Interrogating);
	                    break;
	                case _LegoDeviceImpl2.StateEnum.Connecting:
	                    this.updateDeviceState(_LegoDeviceImpl2.StateEnum.Connecting);
	                    break;
	                case _LegoDeviceImpl2.StateEnum.DisconnectedAdvertising:
	                    if (this.isAdvertising()) {
	                        this.updateDeviceState(_LegoDeviceImpl2.StateEnum.DisconnectedAdvertising);
	                    } else {
	                        this.updateDeviceState(_LegoDeviceImpl2.StateEnum.DisconnectedNotAdvertising);
	                    }
	                    break;
	                case _LegoDeviceImpl2.StateEnum.DisconnectedNotAdvertising:
	                    this.updateDeviceState(_LegoDeviceImpl2.StateEnum.DisconnectedNotAdvertising);
	                    break;
	                default:
	                    _LDSDKLogger2.default.e('Reached default case when trying to determine new LegeBluetoothDevice state. Unknown state was: ' + newState);
	            }
	        }
	    }, {
	        key: 'updateConnectionStateUponServicesDiscovered',
	        value: function updateConnectionStateUponServicesDiscovered() {
	            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                _LDSDKLogger2.default.info('updateConnectionStateUponServicesDiscovered for ' + this.getAddress());
	            }
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    cachedDevice.updateConnectionStateUponServicesDiscovered();
	                    return;
	                }
	            }
	            if (this.connectState !== _LegoDeviceImpl2.StateEnum.DisconnectedNotAdvertising) {
	                this.updateDeviceState(_LegoDeviceImpl2.StateEnum.InterrogationFinished);
	            }
	        }
	    }, {
	        key: 'updateConnectionStateUponAdvertisingChange',
	        value: function updateConnectionStateUponAdvertisingChange() {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    cachedDevice.updateConnectionStateUponAdvertisingChange();
	                    return;
	                }
	            }
	
	            if (this.connectState === _LegoDeviceImpl2.StateEnum.DisconnectedNotAdvertising && this.isAdvertising()) {
	                this.updateDeviceState(_LegoDeviceImpl2.StateEnum.DisconnectedAdvertising);
	            } else if (this.connectState === _LegoDeviceImpl2.StateEnum.DisconnectedAdvertising && !this.isAdvertising()) {
	                this.updateDeviceState(_LegoDeviceImpl2.StateEnum.DisconnectedNotAdvertising);
	            }
	        }
	
	        /**
	         *
	         * @param {NativeCharacteristic} characteristic
	         */
	
	    }, {
	        key: 'handleUpdatedDeviceServiceCharacteristic',
	        value: function handleUpdatedDeviceServiceCharacteristic(characteristic) {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    cachedDevice.handleUpdatedDeviceServiceCharacteristic(characteristic);
	                    return;
	                }
	            }
	            if (this.deviceServiceDefinition.getDeviceName().matchesCharacteristic(characteristic)) {
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('handleUpdatedDeviceServiceCharacteristic DeviceName - (' + _StringUtils2.default.getCharacteristicString(characteristic) + ')');
	                }
	
	                var oldName = this.getName();
	                var newName = _StringUtils2.default.decodeUtf8(characteristic.value);
	
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('Received new device name: ' + newName);
	                }
	
	                /**
	                 * @private
	                 */
	                this.deviceName = newName;
	
	                if (newName !== oldName) {
	                    /**
	                     * @private
	                     */
	                    this.getBluetoothDevice().name = newName;
	                    this.callbackHelper.performDidChangeNameCallback(this, oldName, newName);
	                }
	            } else if (this.deviceServiceDefinition.getAttachedIO().matchesCharacteristic(characteristic)) {
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('handleUpdatedDeviceServiceCharacteristic AttachedIO - (' + _StringUtils2.default.getCharacteristicString(characteristic) + ')');
	                }
	                this.handleAttachedIOData(characteristic.value);
	            } else if (this.deviceServiceDefinition.getDeviceButton().matchesCharacteristic(characteristic)) {
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('handleUpdatedDeviceServiceCharacteristic DeviceButton - (' + _StringUtils2.default.getCharacteristicString(characteristic) + ')');
	                }
	                if (characteristic.value.byteLength !== 1) {
	                    _LDSDKLogger2.default.error('Unexpected length of button state characteristic, expected 1 but was ' + characteristic.value.byteLength);
	                    return;
	                }
	                var newStateInt = new DataView(characteristic.value).getUint8(0);
	                this.updateButtonState(newStateInt);
	            } else if (this.deviceServiceDefinition.getLowVoltageAlert().matchesCharacteristic(characteristic)) {
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('handleUpdatedDeviceServiceCharacteristic LowVoltageAlert - (' + _StringUtils2.default.getCharacteristicString(characteristic) + ')');
	                }
	                this.handleUpdatedLowVoltageAlertCharacteristic(characteristic);
	            } else {
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('Received updated value for unknown characteristic ', characteristic, 'Value: ', new Int8Array(characteristic.value));
	                }
	            }
	        }
	
	        /**
	         *
	         * @param {ArrayBuffer} data
	         */
	
	    }, {
	        key: 'handleAttachedIOData',
	        value: function handleAttachedIOData(data) {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    cachedDevice.handleAttachedIOData(data);
	                    return;
	                }
	            }
	
	            // Format for attach: {0: deviceId, 1: attached|detached, 2: hubIndex, 3: ioType, 4-8: hwVersion, 8-12:
	            // fwVersion}
	            // Format for detach: {0: deviceId, 1: attached|detached }
	            if (data.byteLength < 2) {
	                var errorMessage = 'Did receive IO attached/detached notification from Device with size ' + data.byteLength + ', must be size ' + LegoBluetoothDeviceImpl.SIZE_OF_ATTACHED_IO_DATA + ' for attached and size 2 for detached';
	
	                _LDSDKLogger2.default.error(errorMessage);
	
	                var error = _LDSDKError2.default.deviceError(_LDSDKError2.default.ErrorCode.INTERNAL_ERROR, errorMessage);
	                this.callbackHelper.performDidFailToAddServiceWithErrorCallback(this, error);
	                return;
	            }
	
	            var dataView = new DataView(data);
	            var connectID = dataView.getUint8(0); // Arrays.copyOfRange(data, 0, 1)[0];
	            var attached = dataView.getUint8(1); // Arrays.copyOfRange(data, 1, 2)[0];
	
	            if (attached === 0) {
	                var service = this.serviceWithConnectID(connectID);
	                if (service !== null) {
	                    this.removeService(service);
	                    this.callbackHelper.performDidRemoveServiceCallback(this, service);
	                    if (_LDSDKLogger2.default.isInfoEnabled()) {
	                        _LDSDKLogger2.default.info('Removed input/output: ' + service.getConnectInfo(), ' - new service count:' + this.services.size);
	                    }
	                } else {
	                    if (_LDSDKLogger2.default.isWarnEnabled()) {
	                        _LDSDKLogger2.default.warn('Received notification for detached IO with unknown connect id ' + connectID);
	                    }
	                }
	            } else {
	                if (data.byteLength !== LegoBluetoothDeviceImpl.SIZE_OF_ATTACHED_IO_DATA) {
	                    var _errorMessage = 'Did receive IO attached notification from Device with size ' + data.byteLength + ', must be size ' + LegoBluetoothDeviceImpl.SIZE_OF_ATTACHED_IO_DATA;
	
	                    _LDSDKLogger2.default.error(_errorMessage);
	
	                    var _error = _LDSDKError2.default.deviceError(_LDSDKError2.default.ErrorCode.INTERNAL_ERROR, _errorMessage);
	                    this.callbackHelper.performDidFailToAddServiceWithErrorCallback(this, _error);
	                    return;
	                }
	
	                var typedDataArray = new Int8Array(data);
	
	                var hubIndex = dataView.getUint8(2); // Arrays.copyOfRange(data, 2, 3)[0];
	                var ioType = dataView.getUint8(3); // Arrays.copyOfRange(data, 3, 4)[0];
	
	                var hwRevision = typedDataArray.slice(4, 8); // Arrays.copyOfRange(data, 4, 8);
	                var fwRevision = typedDataArray.slice(8, 12); // Arrays.copyOfRange(data, 8, 12);
	
	                var connectInfo = new _ConnectInfo2.default(connectID, hubIndex, ioType, _Revision2.default.createFromData(hwRevision), _Revision2.default.createFromData(fwRevision));
	
	                var createdService = _LegoServiceFactory2.default.create(connectInfo, this.bluetoothIO, this);
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('Created service - bluetoothIO is set: ' + (this.bluetoothIO && this.bluetoothIO !== null ? 'True' : 'False') + ' --- ' + createdService.toString() + ', Services: ' + this.services.size);
	                }
	                if (createdService !== null) {
	                    this.addService(createdService);
	                    if (_LDSDKLogger2.default.isInfoEnabled()) {
	                        _LDSDKLogger2.default.info('Added input/output ' + createdService.getConnectInfo().toString(), createdService.getServiceName(), ' - new service count:' + this.services.size);
	                    }
	                    this.callbackHelper.performDidAddServiceCallback(this, createdService);
	                }
	            }
	        }
	    }, {
	        key: 'performUpdateDeviceInfo',
	        value: function () {
	            var _ref23 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee23() {
	                var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	                return _regenerator2.default.wrap(function _callee23$(_context23) {
	                    while (1) {
	                        switch (_context23.prev = _context23.next) {
	                            case 0:
	                                if (!(this.callbackHelper && this.callbackHelper !== null)) {
	                                    _context23.next = 5;
	                                    break;
	                                }
	
	                                _context23.next = 3;
	                                return this.callbackHelper.performDidUpdateDeviceInfoCallback(this, this.getBluetoothDevice().deviceInfo, error);
	
	                            case 3:
	                                _context23.next = 6;
	                                break;
	
	                            case 5:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug(this.constructor.name + '. performUpdateDeviceInfo has no callbackhelper' + ' registered - unable to forward the call to performDidUpdateDeviceInfoCallback');
	                                }
	
	                            case 6:
	                            case 'end':
	                                return _context23.stop();
	                        }
	                    }
	                }, _callee23, this);
	            }));
	
	            function performUpdateDeviceInfo() {
	                return _ref23.apply(this, arguments);
	            }
	
	            return performUpdateDeviceInfo;
	        }()
	
	        /**
	         * A call to this function is triggered for each of the characteristics in DeviceInfoServiceDefinition
	         * when we do discoverCharacteristicsForService where service is the DeviceInfoService
	         * @param {NativeCharacteristic} characteristic
	         * @return {Promise}
	         */
	
	    }, {
	        key: 'handleUpdatedDeviceInfoServiceCharacteristic',
	        value: function () {
	            var _ref24 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee25(characteristic) {
	                var _this12 = this;
	
	                var cachedDevice, valueString, error, firmwareRevisionTestedWithSDK, deviceFirmwareRevision;
	                return _regenerator2.default.wrap(function _callee25$(_context25) {
	                    while (1) {
	                        switch (_context25.prev = _context25.next) {
	                            case 0:
	                                if (!(!characteristic || characteristic === null)) {
	                                    _context25.next = 3;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                    _LDSDKLogger2.default.warn('Illegal argument - handleUpdatedDeviceInfoServiceCharacteristic requires the characteristic parameter to be set');
	                                }
	                                return _context25.abrupt('return');
	
	                            case 3:
	                                cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	
	                                if (!(cachedDevice && cachedDevice !== null)) {
	                                    _context25.next = 9;
	                                    break;
	                                }
	
	                                if (!(this.instanceId !== cachedDevice.instanceId)) {
	                                    _context25.next = 9;
	                                    break;
	                                }
	
	                                _context25.next = 8;
	                                return cachedDevice.handleUpdatedDeviceInfoServiceCharacteristic(characteristic);
	
	                            case 8:
	                                return _context25.abrupt('return', _context25.sent);
	
	                            case 9:
	                                valueString = _StringUtils2.default.decodeUtf8(characteristic.value);
	
	                                if (this.deviceInfoServiceDefinition.getFirmwareRevision().matchesCharacteristic(characteristic)) {
	                                    this.deviceInfo.setFirmwareRevisionString(valueString);
	                                } else if (this.deviceInfoServiceDefinition.getHardwareRevision().matchesCharacteristic(characteristic)) {
	                                    this.deviceInfo.setHardwareRevisionString(valueString);
	                                } else if (this.deviceInfoServiceDefinition.getSoftwareRevision().matchesCharacteristic(characteristic)) {
	                                    this.deviceInfo.setSoftwareRevisionString(valueString);
	                                } else if (this.deviceInfoServiceDefinition.getManufacturerName().matchesCharacteristic(characteristic)) {
	                                    this.deviceInfo.setManufacturerName(valueString);
	                                }
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('handleUpdatedDeviceInfoServiceCharacteristic for uuid: ' + _UuidHelper2.default.getUuid(characteristic) + ': ' + valueString + ' --- DeviceInfo complete: ' + this.deviceInfo.isComplete());
	                                }
	                                // We have received values for all required device info characteristics
	                                error = null;
	
	                                if (this.deviceInfo.isComplete()) {
	                                    /* BuildConfig.BLUETOOTH_DEVICE_FIRMWARE_VERSION */
	                                    firmwareRevisionTestedWithSDK = _Revision2.default.createFromString('1.0.9.0');
	                                    deviceFirmwareRevision = this.deviceInfo.getFirmwareRevision();
	
	
	                                    if (deviceFirmwareRevision.getMajorVersion() <= firmwareRevisionTestedWithSDK.getMajorVersion()) {
	                                        if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                            _LDSDKLogger2.default.info('Device has firmware supported by SDK - querying characteristics for remaining services');
	                                        }
	
	                                        setTimeout((0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee24() {
	                                            var services, i, service, serviceDef, serviceDefName;
	                                            return _regenerator2.default.wrap(function _callee24$(_context24) {
	                                                while (1) {
	                                                    switch (_context24.prev = _context24.next) {
	                                                        case 0:
	                                                            _context24.prev = 0;
	
	                                                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                                                _LDSDKLogger2.default.debug('discoverServices 2nd time');
	                                                            }
	                                                            services = [];
	
	                                                            if (!(_this12.deviceNativeServices.size >= 5)) {
	                                                                _context24.next = 8;
	                                                                break;
	                                                            }
	
	                                                            _this12.deviceNativeServices.forEach(function (value, key, map) {
	                                                                services.push(value);
	                                                            });
	                                                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                                                _LDSDKLogger2.default.debug('Found ' + services.length + ' deviceServices for device ' + _this12.getAddress());
	                                                            }
	                                                            _context24.next = 12;
	                                                            break;
	
	                                                        case 8:
	                                                            _context24.next = 10;
	                                                            return _this12.getBluetoothWrapper().discoverServices();
	
	                                                        case 10:
	                                                            services = _context24.sent;
	
	                                                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                                                _LDSDKLogger2.default.debug('Found ' + services.length + ' services using discoverServices for device ' + _this12.getAddress());
	                                                            }
	
	                                                        case 12:
	                                                            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                                                _LDSDKLogger2.default.info('DeviceInfo complete: Discovered ' + services.length + ' service characteristics');
	                                                            }
	                                                            services.sort(function (lhs, rhs) {
	                                                                // Make sure that the ioService is handled first as that creates the bluetoothIO that is
	                                                                // needed by the LegoServices created by the deviceService.
	                                                                var ioServiceDef = _BluetoothServiceDefinition2.default.ioServiceDefinition();
	                                                                if (ioServiceDef.matchesService(lhs) && !ioServiceDef.matchesService(rhs)) {
	                                                                    return -10;
	                                                                }
	                                                                if (!ioServiceDef.matchesService(lhs) && ioServiceDef.matchesService(rhs)) {
	                                                                    return 10;
	                                                                }
	                                                                if (ioServiceDef.matchesService(lhs) && ioServiceDef.matchesService(rhs)) {
	                                                                    return 0;
	                                                                }
	                                                                if (!ioServiceDef.matchesService(lhs) && !ioServiceDef.matchesService(rhs)) {
	                                                                    if (lhs && lhs !== null && lhs.uuid && rhs) {
	                                                                        return lhs.uuid.localeCompare(rhs.uuid);
	                                                                    }
	                                                                }
	                                                            });
	
	                                                            // The Device Firmware is supported - query for characteristics for all remaining discovered
	                                                            // services
	                                                            i = 0;
	
	                                                        case 15:
	                                                            if (!(i < services.length)) {
	                                                                _context24.next = 28;
	                                                                break;
	                                                            }
	
	                                                            service = services[i];
	
	                                                            if (!(service === undefined || service === null)) {
	                                                                _context24.next = 20;
	                                                                break;
	                                                            }
	
	                                                            _LDSDKLogger2.default.error('Service not initialized - (characteristic: ' + _StringUtils2.default.getCharacteristicString(characteristic) + ')');
	                                                            return _context24.abrupt('continue', 25);
	
	                                                        case 20:
	                                                            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                                                serviceDef = _BluetoothServiceDefinition2.default.serviceDefinitionWithUUID(_UuidHelper2.default.getUuid(service));
	                                                                serviceDefName = 'N/A';
	
	                                                                if (serviceDef !== null) {
	                                                                    serviceDefName = serviceDef.serviceName;
	                                                                }
	                                                                _LDSDKLogger2.default.info('Got service type ' + serviceDefName + ' from device ' + _this12.getName() + '. Native service: ' + _StringUtils2.default.getInstanceString(service));
	                                                            }
	
	                                                            if (_DeviceInfoServiceDefinition2.default.getInstance().matchesService(service)) {
	                                                                _context24.next = 25;
	                                                                break;
	                                                            }
	
	                                                            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                                                _LDSDKLogger2.default.info('Doing characteristics discovery for service ' + _StringUtils2.default.getInstanceString(service));
	                                                            }
	                                                            _context24.next = 25;
	                                                            return _this12.discoverCharacteristicsForService(service);
	
	                                                        case 25:
	                                                            i++;
	                                                            _context24.next = 15;
	                                                            break;
	
	                                                        case 28:
	
	                                                            if (!_this12.interrogationFinished) {
	                                                                /**
	                                                                 * @private
	                                                                 * @type {boolean}
	                                                                 */
	                                                                _this12.interrogationFinished = true;
	                                                                _this12.updateConnectionStateUponServicesDiscovered();
	                                                            }
	
	                                                            _context24.next = 34;
	                                                            break;
	
	                                                        case 31:
	                                                            _context24.prev = 31;
	                                                            _context24.t0 = _context24['catch'](0);
	
	                                                            _LDSDKLogger2.default.error('Failed service lookup:', _this12.getErrorReason(_context24.t0));
	                                                            // this.onServicesDiscovered(e, null);
	
	                                                        case 34:
	                                                        case 'end':
	                                                            return _context24.stop();
	                                                    }
	                                                }
	                                            }, _callee24, _this12, [[0, 31]]);
	                                        })), 0);
	
	                                        if (deviceFirmwareRevision.getMajorVersion() === firmwareRevisionTestedWithSDK.getMajorVersion() && deviceFirmwareRevision.getMinorVersion() > firmwareRevisionTestedWithSDK.getMinorVersion()) {
	                                            _LDSDKLogger2.default.warn('SDK is tested to work with Device Firmware version ' + firmwareRevisionTestedWithSDK + ' but is connected to a Device with Firmware version ' + deviceFirmwareRevision + '.\n All Device features may not be supported by SDK.');
	                                        }
	                                    } else {
	                                        _LDSDKLogger2.default.error('Did connect to Device with firmware version ' + deviceFirmwareRevision + ' where minimum required major version is ' + firmwareRevisionTestedWithSDK.getMajorVersion());
	
	                                        error = _LDSDKError2.default.deviceError(_LDSDKError.ErrorCode.BLUETOOTH_UNSUPPORTED_FIRMWARE_VERSION, 'Device firmware version ' + deviceFirmwareRevision + ' not supported by SDK, SDK requires firmware major version ' + firmwareRevisionTestedWithSDK.getMajorVersion());
	                                    }
	                                    this.callbackHelper.performDidUpdateDeviceInfoCallback(this, this.getBluetoothDevice().deviceInfo, error);
	                                }
	
	                            case 14:
	                            case 'end':
	                                return _context25.stop();
	                        }
	                    }
	                }, _callee25, this);
	            }));
	
	            function handleUpdatedDeviceInfoServiceCharacteristic(_x28) {
	                return _ref24.apply(this, arguments);
	            }
	
	            return handleUpdatedDeviceInfoServiceCharacteristic;
	        }()
	    }, {
	        key: 'handleUpdatedBatteryLevelCharacteristic',
	        value: function handleUpdatedBatteryLevelCharacteristic(characteristic) {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    cachedDevice.handleUpdatedBatteryLevelCharacteristic(characteristic);
	                    return;
	                }
	            }
	
	            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                _LDSDKLogger2.default.info('Received new batterylevel ' + new Uint8Array(characteristic.value) + ' for ' + _StringUtils2.default.getDeviceString(this));
	            }
	            if (characteristic.value.byteLength === 1) {
	                /**
	                 * @private
	                 */
	                this.batteryLevel = new DataView(characteristic.value).getUint8(0);
	                // characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT8, 0);
	                this.callbackHelper.performDidUpdateBatteryLevelCallback(this, this.batteryLevel);
	            }
	        }
	    }, {
	        key: 'handleUpdatedLowVoltageAlertCharacteristic',
	        value: function handleUpdatedLowVoltageAlertCharacteristic(characteristic) {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    cachedDevice.handleUpdatedLowVoltageAlertCharacteristic(characteristic);
	                    return;
	                }
	            }
	
	            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                _LDSDKLogger2.default.info('Received new low voltage alert ' + new Uint8Array(characteristic.value));
	            }
	            if (characteristic.value.byteLength === 1) {
	                /**
	                 * @private
	                 */
	                this.lowVoltage = new DataView(characteristic.value).getUint8(0) === 1;
	                // characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT8, 0) === 1;
	                this.callbackHelper.performDidUpdateLowVoltageStateCallback(this, this.lowVoltage);
	            }
	        }
	
	        /**
	         *
	         * @param {number} connectID
	         * @return {CurrentSensor|GenericService|MotionSensor|PiezoTonePlayer|RGBLight|SimpleMotor|TiltSensor|VoltageSensor} - Returns a @see {@link LegoService} implementation or null if no service found for that connectID
	         */
	
	    }, {
	        key: 'serviceWithConnectID',
	        value: function serviceWithConnectID(connectID) {
	            var cachedDevice = this.legoDeviceManager.getDevice(this.getDeviceId(), false);
	            if (cachedDevice && cachedDevice !== null) {
	                if (this.instanceId !== cachedDevice.instanceId) {
	                    return cachedDevice.serviceWithConnectID(connectID);
	                }
	            }
	
	            var idToFind = parseInt(connectID);
	            var cachedService = this.services.get(idToFind);
	            if (cachedService && cachedService !== null) {
	                return cachedService;
	            } else {
	                this.services.forEach(function (service, serviceConnectId) {
	                    if (idToFind === serviceConnectId) {
	                        return service;
	                    }
	                });
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('No service found for connectId: ' + idToFind + ' - dumping list of services to debug' + ' log:');
	                    this.services.forEach(function (service, serviceConnectId) {
	                        _LDSDKLogger2.default.debug('Service [connectId: ' + serviceConnectId + ', Type: ' + service.getServiceName() + ']');
	                    });
	                }
	            }
	            return null;
	        }
	    }, {
	        key: 'cleanUp',
	        value: function () {
	            var _ref26 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee26() {
	                return _regenerator2.default.wrap(function _callee26$(_context26) {
	                    while (1) {
	                        switch (_context26.prev = _context26.next) {
	                            case 0:
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info('Cleaning up device ' + this.getName());
	                                }
	                                _context26.next = 3;
	                                return this.resetState();
	
	                            case 3:
	                            case 'end':
	                                return _context26.stop();
	                        }
	                    }
	                }, _callee26, this);
	            }));
	
	            function cleanUp() {
	                return _ref26.apply(this, arguments);
	            }
	
	            return cleanUp;
	        }()
	    }, {
	        key: 'closeGatt',
	        value: function closeGatt() {
	            if (this.bluetoothGatt === null) {
	                return;
	            }
	
	            try {
	                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                    _LDSDKLogger2.default.info('Closing BluetoothGatt');
	                }
	                this.bluetoothGatt.close();
	            } catch (e) {
	                _LDSDKLogger2.default.error('An exception has occurred while closing BluetoothGatt: ', this.getErrorReason(e));
	            }
	        }
	    }, {
	        key: 'hasUserInitiatedDisconnect',
	        value: function hasUserInitiatedDisconnect() {
	            return this.userInitiatedDisconnect;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var nativeDeviceString = 'NativeDevice[paired: ' + this.getBluetoothDevice().paired + ', connectable: ' + this.getBluetoothDevice().connectable + ', connected: ' + this.getBluetoothDevice().connected + ', connecting: ' + this.getBluetoothDevice().connecting + ', inquiryRssi: ' + this.getBluetoothDevice().inquiryRssi + ']';
	            return 'Name: ' + this.getName() + ', [InstanceId: \'' + this.instanceId + '\', Address: ' + this.getAddress() + ', State: ' + this.getConnectState() + ', Services: ' + this.services.size + '] - ' + nativeDeviceString;
	        }
	    }, {
	        key: 'advertising',
	        get: function get() {
	            return this._advertising;
	        },
	        set: function set(value) {
	            var checkedValue = value === true;
	            var now = new Date().getTime();
	            var diff = now - this.advertisingUpdatedTimestamp;
	            if (this.isAdvertising() && !checkedValue && diff < _LegoDeviceManagerImpl2.default.getInstance().config.disableAdvertisingWindowSizeMillis) {
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('Ignoring setAdvertising(' + checkedValue + ') for ' + this.getName() + ' [' + this.getAddress() + '] since it was enabled ' + diff + 'ms ago. (Window size: ' + _LegoDeviceManagerImpl2.default.getInstance().config.disableAdvertisingWindowSizeMillis + 'ms)');
	                }
	                return;
	            }
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('Setting advertising = ' + checkedValue + ' for ' + this.getName() + ' [' + this.getAddress() + ']');
	            }
	            /**
	             * @private
	             * @type {*}
	             */
	            this.advertisingUpdatedTimestamp = now;
	            /**
	             * @private
	             * @type {boolean}
	             * @private
	             */
	            this._advertising = checkedValue;
	        }
	    }]);
	    return LegoBluetoothDeviceImpl;
	}(_LegoDeviceImpl3.default);
	
	LegoBluetoothDeviceImpl.CHARACTERISTIC_UPDATE_NOTIFICATION_DESCRIPTOR_UUID = _UuidHelper2.default.getSpecUuid('2902');
	LegoBluetoothDeviceImpl.NUMBER_OF_RSSI_VALUES_TO_AVERAGE = 10;
	LegoBluetoothDeviceImpl.SIZE_OF_ATTACHED_IO_DATA = 12;
	exports.default = LegoBluetoothDeviceImpl;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _Revision = __webpack_require__(61);
	
	var _Revision2 = _interopRequireDefault(_Revision);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var DeviceInfo = function () {
	    function DeviceInfo() {
	        (0, _classCallCheck3.default)(this, DeviceInfo);
	
	        this.firmwareRevision = null;
	        this.hardwareRevision = null;
	        this.softwareRevision = null;
	        this.manufacturerName = null;
	    }
	
	    (0, _createClass3.default)(DeviceInfo, [{
	        key: 'getFirmwareRevision',
	        value: function getFirmwareRevision() {
	            return this.firmwareRevision;
	        }
	    }, {
	        key: 'getHardwareRevision',
	        value: function getHardwareRevision() {
	            return this.hardwareRevision;
	        }
	    }, {
	        key: 'getSoftwareRevision',
	        value: function getSoftwareRevision() {
	            return this.softwareRevision;
	        }
	    }, {
	        key: 'getManufacturerName',
	        value: function getManufacturerName() {
	            return this.manufacturerName;
	        }
	    }, {
	        key: 'setFirmwareRevisionString',
	        value: function setFirmwareRevisionString(firmwareRevision) {
	            this.firmwareRevision = _Revision2.default.createFromString(firmwareRevision);
	        }
	    }, {
	        key: 'setHardwareRevisionString',
	        value: function setHardwareRevisionString(hardwareRevision) {
	            this.hardwareRevision = _Revision2.default.createFromString(hardwareRevision);
	        }
	    }, {
	        key: 'setSoftwareRevisionString',
	        value: function setSoftwareRevisionString(softwareRevision) {
	            this.softwareRevision = _Revision2.default.createFromString(softwareRevision);
	        }
	    }, {
	        key: 'setManufacturerName',
	        value: function setManufacturerName(manufacturerName) {
	            this.manufacturerName = manufacturerName;
	        }
	    }, {
	        key: 'isComplete',
	        value: function isComplete() {
	            // Hardware revision is not mandatory
	            return this.firmwareRevision !== null && /* this.hardwareRevision != null && */this.softwareRevision !== null && this.manufacturerName !== null;
	        }
	
	        /**
	         * Get simple version of the device info
	         * @return {{firmwareRevision: string, hardwareRevision: string, softwareRevision: string, manufacturerName: string}}
	         */
	
	    }, {
	        key: 'getSimpleDeviceInfo',
	        value: function getSimpleDeviceInfo() {
	            return {
	                firmwareRevision: this.getFirmwareRevision(),
	                hardwareRevision: this.getHardwareRevision(),
	                softwareRevision: this.getSoftwareRevision(),
	                manufacturerName: this.getManufacturerName()
	            };
	        }
	    }]);
	    return DeviceInfo;
	}(); /**
	      * Created by frj on 12/02/16.
	      */
	
	
	exports.default = DeviceInfo;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by frj on 12/02/16.
	 */
	
	var Revision = function () {
	    (0, _createClass3.default)(Revision, null, [{
	        key: 'createFromString',
	        value: function createFromString(revisionString) {
	            return new Revision(revisionString);
	        }
	    }, {
	        key: 'createFromData',
	        value: function createFromData(revisionDataBuffer) {
	            return new Revision(revisionDataBuffer);
	        }
	    }]);
	
	    function Revision(revisionStringOrBuffer) {
	        (0, _classCallCheck3.default)(this, Revision);
	
	        if (typeof revisionStringOrBuffer === 'string') {
	            this.parseRevision(revisionStringOrBuffer);
	        } else if (revisionStringOrBuffer instanceof Int8Array || revisionStringOrBuffer instanceof Uint8Array || revisionStringOrBuffer instanceof ArrayBuffer) {
	            this.parseRevisionBuffer(revisionStringOrBuffer);
	        } else {
	            _LDSDKLogger2.default.error('Cannot parse argument: ', revisionStringOrBuffer);
	        }
	    }
	
	    (0, _createClass3.default)(Revision, [{
	        key: 'parseRevisionBuffer',
	        value: function parseRevisionBuffer(bufferOrTypedArray) {
	            if (bufferOrTypedArray instanceof Int8Array || bufferOrTypedArray instanceof Uint8Array) {
	                if (bufferOrTypedArray.byteLength >= 1) {
	                    this.majorVersion = bufferOrTypedArray[0];
	                }
	                if (bufferOrTypedArray.byteLength >= 2) {
	                    this.minorVersion = bufferOrTypedArray[1];
	                }
	                if (bufferOrTypedArray.byteLength >= 3) {
	                    this.bugFixVersion = bufferOrTypedArray[2];
	                }
	                if (bufferOrTypedArray.byteLength >= 4) {
	                    this.buildNumber = bufferOrTypedArray[3];
	                }
	            } else if (bufferOrTypedArray instanceof ArrayBuffer) {
	                var view = new DataView(bufferOrTypedArray);
	                if (bufferOrTypedArray.byteLength >= 1) {
	                    this.majorVersion = view.getInt8(0);
	                }
	                if (bufferOrTypedArray.byteLength >= 2) {
	                    this.minorVersion = view.getInt8(1);
	                }
	                if (bufferOrTypedArray.byteLength >= 3) {
	                    this.bugFixVersion = view.getInt8(2);
	                }
	                if (bufferOrTypedArray.byteLength >= 4) {
	                    this.buildNumber = view.getInt8(3);
	                }
	            }
	        }
	    }, {
	        key: 'parseRevision',
	        value: function parseRevision(revisionString) {
	            var matches = revisionString.match(/(^\d+(\.\d+){0,3}$)/);
	            if (matches) {
	                var versionComponents = revisionString.split('.');
	                if (versionComponents.length >= 1) {
	                    this.majorVersion = versionComponents[0];
	                }
	                if (versionComponents.length >= 2) {
	                    this.minorVersion = versionComponents[1];
	                }
	                if (versionComponents.length >= 3) {
	                    this.bugFixVersion = versionComponents[2];
	                }
	                if (versionComponents.length >= 4) {
	                    this.buildNumber = versionComponents[3];
	                }
	            } else {
	                // If string contains anything but numbers and '.' then set all properties to zero
	                this.majorVersion = 0;
	                this.minorVersion = 0;
	                this.bugFixVersion = 0;
	                this.buildNumber = 0;
	            }
	        }
	    }, {
	        key: 'getMajorVersion',
	        value: function getMajorVersion() {
	            return this.majorVersion;
	        }
	    }, {
	        key: 'getMinorVersion',
	        value: function getMinorVersion() {
	            return this.minorVersion;
	        }
	    }, {
	        key: 'getBugFixVersion',
	        value: function getBugFixVersion() {
	            return this.bugFixVersion;
	        }
	    }, {
	        key: 'getBuildNumber',
	        value: function getBuildNumber() {
	            return this.buildNumber;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return this.majorVersion + '.' + this.minorVersion + '.' + this.bugFixVersion + '.' + this.buildNumber;
	        }
	    }, {
	        key: 'toBytes',
	        value: function toBytes() {
	            return new Uint8Array(this.toBuffer());
	        }
	    }, {
	        key: 'equals',
	        value: function equals(o) {
	            if (this === o) return true;
	            if (o === null || this.constructor.name !== o.constructor.name) return false;
	
	            if (this.bugFixVersion !== o.bugFixVersion) return false;
	            if (this.buildNumber !== o.buildNumber) return false;
	            if (this.majorVersion !== o.majorVersion) return false;
	            if (this.minorVersion !== o.minorVersion) return false;
	
	            return true;
	        }
	    }, {
	        key: 'toBuffer',
	        value: function toBuffer() {
	            var bufferView = new DataView(new ArrayBuffer(4));
	            bufferView.setUint8(0, this.majorVersion);
	            bufferView.setUint8(1, this.minorVersion);
	            bufferView.setUint8(2, this.bugFixVersion);
	            bufferView.setUint8(3, this.buildNumber);
	            return bufferView.buffer;
	        }
	
	        /**
	         * Get a simple revision representation of this instance
	         * @return {{majorVersion: number, minorVersion: number, bugFixVersion: number, buildNumber: number, toString: toString}}
	         */
	
	    }, {
	        key: 'getSimpleRevision',
	        value: function getSimpleRevision() {
	            return {
	                majorVersion: this.getMajorVersion(),
	                minorVersion: this.getMinorVersion(),
	                bugFixVersion: this.getBugFixVersion(),
	                buildNumber: this.getBuildNumber(),
	                toString: function toString() {
	                    return this.toString();
	                }
	            };
	        }
	    }]);
	    return Revision;
	}();
	
	// export Revision as Revision;
	
	
	exports.default = Revision;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _map = __webpack_require__(9);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _stringify = __webpack_require__(19);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _promise = __webpack_require__(12);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	var _UuidHelper = __webpack_require__(11);
	
	var _UuidHelper2 = _interopRequireDefault(_UuidHelper);
	
	var _ChromeOsBluetoothDeviceWrapper = __webpack_require__(58);
	
	var _ChromeOsBluetoothDeviceWrapper2 = _interopRequireDefault(_ChromeOsBluetoothDeviceWrapper);
	
	var _StringUtils = __webpack_require__(21);
	
	var _StringUtils2 = _interopRequireDefault(_StringUtils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @ignore Internal use only
	 * Created by frj on 29/02/16.
	 */
	var BluetoothHelper = function () {
	    function BluetoothHelper() {
	        (0, _classCallCheck3.default)(this, BluetoothHelper);
	    }
	
	    (0, _createClass3.default)(BluetoothHelper, null, [{
	        key: 'create',
	
	
	        /**
	         * Gets the characteristic with the given characteristicUUID from a service
	         *
	         * @param {string} characteristicUUID
	         * @param {NativeService} service
	         * @return {Promise.<NativeCharacteristic>} Will either resolve to the found characteristic, or resolve null if
	         * the characteristic uuid is not found in the service.
	         */
	        value: function create(characteristicUUID, service) {
	            if (service === undefined || service === null || service.instanceId === undefined || service.instanceId === null) {
	                if (_LDSDKLogger2.default.isErrorEnabled()) {
	                    _LDSDKLogger2.default.error('Service argument or service.instanceId is not set - unable to find characteristic with uuid: ' + characteristicUUID);
	                }
	                return _promise2.default.resolve(null);
	            }
	            return new _promise2.default(function (resolve, reject) {
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('Getting characteristics for service: ' + _UuidHelper2.default.getUuid(service) + ' ( ' + service.instanceId + ')');
	                }
	                if (BluetoothHelper.characteristicsForService.has(service.instanceId)) {
	                    var characteristics = BluetoothHelper.characteristicsForService.get(service.instanceId);
	                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                        _LDSDKLogger2.default.debug('Returning ' + characteristics.length + ' cached native characteristics for service ' + _StringUtils2.default.getInstanceString(service));
	                    }
	                    return resolve(characteristics);
	                }
	                // TODO: Use implementation in ChromeOsBluetoothDeviceWrapper
	                chrome.bluetoothLowEnergy.getCharacteristics(service.instanceId, function (characteristics) {
	                    if (chrome.runtime.lastError) {
	                        var msg = 'chrome.bluetoothLowEnergy.getCharacteristics failed lookup of service instance id: "' + service.instanceId + '". Original message: ' + chrome.runtime.lastError.message;
	                        return reject(msg);
	                    }
	                    if (characteristics.length > 0) {
	                        if (_LDSDKLogger2.default.isInfoEnabled()) {
	                            _LDSDKLogger2.default.info('Caching ' + characteristics.length + ' characteristics for service ' + _StringUtils2.default.getInstanceString(service));
	                        }
	                        BluetoothHelper.characteristicsForService.set(service.instanceId, characteristics);
	                    }
	                    return resolve(characteristics);
	                });
	            }).then(function (characteristics) {
	                if (!characteristics || characteristics === null || Array.isArray(characteristics) && characteristics.length === 0) {
	                    if (_LDSDKLogger2.default.isWarnEnabled()) {
	                        _LDSDKLogger2.default.warn('No characteristics found for ' + _UuidHelper2.default.getUuid(service) + ' - unable to search for characteristic uuid: ' + characteristicUUID);
	                    }
	                } else {
	                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                        _LDSDKLogger2.default.debug('Searching service ' + _UuidHelper2.default.getUuid(service) + ' for characteristic uuid: ', characteristicUUID);
	                    }
	                    for (var i = 0; i < characteristics.length; i++) {
	                        var characteristic = characteristics[i];
	                        if (characteristicUUID === _UuidHelper2.default.getUuid(characteristic)) {
	                            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                _LDSDKLogger2.default.info('Found matching characteristic for characteristic uuid: ', _UuidHelper2.default.getUuid(characteristic), ' in service ' + _UuidHelper2.default.getUuid(service));
	                            }
	                            return _promise2.default.resolve(characteristic);
	                        }
	                    }
	                }
	                return _promise2.default.resolve(null);
	            }).catch(function (err) {
	                _promise2.default.reject(err);
	            });
	        }
	
	        /**
	         * @private
	         * @type {Map}
	         */
	
	    }, {
	        key: 'arrayOfStringsFromCharacteristicProperties',
	        value: function arrayOfStringsFromCharacteristicProperties(properties) {
	            return (0, _stringify2.default)(properties);
	        }
	    }]);
	    return BluetoothHelper;
	}();
	
	BluetoothHelper.characteristicsForService = new _map2.default();
	exports.default = BluetoothHelper;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _map = __webpack_require__(9);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _ConnectInfo = __webpack_require__(43);
	
	var _MotionSensor = __webpack_require__(92);
	
	var _MotionSensor2 = _interopRequireDefault(_MotionSensor);
	
	var _TiltSensor = __webpack_require__(96);
	
	var _TiltSensor2 = _interopRequireDefault(_TiltSensor);
	
	var _SimpleMotor = __webpack_require__(95);
	
	var _SimpleMotor2 = _interopRequireDefault(_SimpleMotor);
	
	var _CurrentSensor = __webpack_require__(90);
	
	var _CurrentSensor2 = _interopRequireDefault(_CurrentSensor);
	
	var _VoltageSensor = __webpack_require__(97);
	
	var _VoltageSensor2 = _interopRequireDefault(_VoltageSensor);
	
	var _PiezoTonePlayer = __webpack_require__(93);
	
	var _PiezoTonePlayer2 = _interopRequireDefault(_PiezoTonePlayer);
	
	var _RGBLight = __webpack_require__(94);
	
	var _RGBLight2 = _interopRequireDefault(_RGBLight);
	
	var _GenericService = __webpack_require__(91);
	
	var _GenericService2 = _interopRequireDefault(_GenericService);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @ignore
	 * The LEGO Service Factory is used for creating, initializing and keeping track of the services connected to the hub
	 * Created by frj on 11/02/16.
	 */
	var LegoServiceFactory = function () {
	    function LegoServiceFactory() {
	        (0, _classCallCheck3.default)(this, LegoServiceFactory);
	    }
	
	    (0, _createClass3.default)(LegoServiceFactory, null, [{
	        key: 'create',
	
	
	        /**
	         * @ignore
	         * Create a service instance
	         *
	         * @param {ConnectInfo} connectInfo
	         * @param {BluetoothIO} io
	         * @param {LegoBluetoothDeviceImpl} device
	         * @return {CurrentSensor|GenericService|MotionSensor|PiezoTonePlayer|RGBLight|SimpleMotor|TiltSensor|VoltageSensor} - An implementation of @see {@link LegoService}
	         */
	        value: function create(connectInfo, io, device) {
	            if (io === null || connectInfo === null) {
	                _LDSDKLogger2.default.error('Cannot instantiate service with null IO object or ConnectInfo. ConnectInfo:' + connectInfo + ', IO: ' + io + ', device: ' + device);
	                return null;
	            }
	
	            var servicesForDeviceMap = LegoServiceFactory.getServiceInstances(device.getDeviceId());
	            if (servicesForDeviceMap.has(connectInfo.getConnectId())) {
	                var service = servicesForDeviceMap.get(connectInfo.getConnectId());
	                if (service.getConnectInfo().getTypeEnum() === connectInfo.getTypeEnum()) {
	                    if (_LDSDKLogger2.default.isInfoEnabled()) {
	                        _LDSDKLogger2.default.info('Factory returning cached LegoService: ' + service.getSimpleService());
	                    }
	                    io.getCallbackHelper().checkOrRegisterAsCallbackListener(service);
	                    // If this is a new BluetoothIO instance the callbackHelper instance will have an empty map. So even
	                    // though the service is cached, we need to ensure that the service itself is registered as a
	                    // listener if it is not already.
	                    return service;
	                }
	            }
	
	            var result = void 0;
	            switch (connectInfo.getTypeEnum()) {
	                case _ConnectInfo.IOType.IO_TYPE_GENERIC:
	                    result = _GenericService2.default.createService(connectInfo, io);
	                    break;
	                case _ConnectInfo.IOType.IO_TYPE_MOTION_SENSOR:
	                    result = _MotionSensor2.default.createService(connectInfo, io);
	                    break;
	                case _ConnectInfo.IOType.IO_TYPE_TILT_SENSOR:
	                    result = _TiltSensor2.default.createService(connectInfo, io);
	                    break;
	                case _ConnectInfo.IOType.IO_TYPE_PIEZO_TONE_PLAYER:
	                    result = _PiezoTonePlayer2.default.createService(connectInfo, io);
	                    break;
	                case _ConnectInfo.IOType.IO_TYPE_MOTOR:
	                    result = _SimpleMotor2.default.createService(connectInfo, io);
	                    break;
	                case _ConnectInfo.IOType.IO_TYPE_CURRENT:
	                    result = _CurrentSensor2.default.createService(connectInfo, io);
	                    break;
	                case _ConnectInfo.IOType.IO_TYPE_VOLTAGE:
	                    result = _VoltageSensor2.default.createService(connectInfo, io);
	                    break;
	                case _ConnectInfo.IOType.IO_TYPE_RGB_LIGHT:
	                    result = _RGBLight2.default.createService(connectInfo, io);
	                    break;
	                default:
	                    result = _GenericService2.default.createService(connectInfo, io);
	                    break;
	            }
	
	            result.setDevice(device);
	            servicesForDeviceMap.set(connectInfo.getConnectId(), result);
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('Factory returning new LegoService: ' + result.getSimpleService());
	            }
	
	            return result;
	        }
	
	        /**
	         * Get the service instances for the device with the deviceId address.
	         *
	         * @param {string} deviceId - The mac address of the device.
	         * @return {Map<number,LegoService>} - Returns a map with connectId as key and the LegoService as value. The LegoService returned will be one of {@link CurrentSensor}, {@link GenericService}, {@link MotionSensor}, {@link PiezoTonePlayer}, {@link RGBLight}, {@link SimpleMotor}, {@link TiltSensor}, {@link VoltageSensor}
	         */
	
	
	        /**
	         * @private
	         * @type {Map<string, LegoService>}
	         */
	
	    }, {
	        key: 'getServiceInstances',
	        value: function getServiceInstances(deviceId) {
	            var servicesMap = LegoServiceFactory.deviceToServices.get(deviceId);
	            if (servicesMap && servicesMap !== null) {
	                return servicesMap;
	            }
	            LegoServiceFactory.deviceToServices.set(deviceId, new _map2.default());
	            return LegoServiceFactory.deviceToServices.get(deviceId);
	        }
	
	        /**
	         * @ignore
	         * Add a service for the given deviceId
	         *
	         * @param {string} deviceId - The mac address of the device.
	         * @param {CurrentSensor|GenericService|MotionSensor|PiezoTonePlayer|RGBLight|SimpleMotor|TiltSensor|VoltageSensor} service
	         */
	
	    }, {
	        key: 'addService',
	        value: function addService(deviceId, service) {
	            var servicesMap = LegoServiceFactory.getServiceInstances(deviceId);
	            if (servicesMap.has(service.getConnectInfo().getConnectId())) {
	                var oldServiceInstance = servicesMap.get(service.getConnectInfo().getConnectId());
	                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                    _LDSDKLogger2.default.info('Replacing service for connectId' + service.getConnectInfo().getConnectId() + ' for device: ' + deviceId + '. Old service: ' + oldServiceInstance.toString() + ', New service: ' + service.toString());
	                }
	                if (service.callbackHelper.callbackListeners.size === 0 && oldServiceInstance.callbackHelper.callbackListeners.size > 0) {
	                    if (_LDSDKLogger2.default.isInfoEnabled()) {
	                        _LDSDKLogger2.default.info('Transferring ' + oldServiceInstance.callbackHelper.callbackListeners.size + ' callback listeners to new service instance for connectId ' + service.getConnectInfo().getConnectId() + ' for device: ' + deviceId);
	                    }
	                    oldServiceInstance.callbackHelper.callbackListeners.forEach(function (value, key, map) {
	                        service.callbackHelper.callbackListeners.set(key, value);
	                    });
	                }
	            }
	            servicesMap.set(service.getConnectInfo().getConnectId(), service);
	        }
	
	        /**
	         * Remove a service with connectId from the given device with the deviceId
	         *
	         * @param {string} deviceId - The mac address of the device.
	         * @param {number} connectId - The connectId of the service.
	         * @return {boolean} Returns true if a service was found and deleted, false otherwise.
	         */
	
	    }, {
	        key: 'removeService',
	        value: function removeService(deviceId, connectId) {
	            var services = LegoServiceFactory.getServiceInstances(deviceId);
	            if (services.has(connectId)) {
	                var service = services.get(connectId);
	                if (service && service !== null && typeof service.getIo === 'function') {
	                    var io = service.getIo();
	                    if (io && io !== null && typeof io.getCallbackHelper === 'function') {
	                        io.getCallbackHelper().unregisterCallbackListener(null, service);
	                    } else {
	                        if (io && io !== null && typeof io.getCallbackHelper !== 'function') {
	                            if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                _LDSDKLogger2.default.warn('Invalid IO response for service ' + UuidHelper.getUuid(service) + ' found for connectId: ' + connectId + ', deviceId: ' + deviceId + ' - IO does not have a getCallbackHelper function');
	                            }
	                        }
	                    }
	                } else {
	                    if (!service || service === null) {
	                        if (_LDSDKLogger2.default.isInfoEnabled()) {
	                            _LDSDKLogger2.default.info('Service not found for connectId: ' + connectId + ' no callback will be unregistered');
	                        }
	                    } else if (typeof service.getIo !== 'function') {
	                        if (_LDSDKLogger2.default.isWarnEnabled()) {
	                            _LDSDKLogger2.default.warn('Invalid service ' + UuidHelper.getUuid(service) + ' found for connectId: ' + connectId + ', deviceId: ' + deviceId + ' - Service does not have a getIo function');
	                        }
	                    }
	                }
	            }
	            return services.delete(connectId);
	        }
	
	        /**
	         * Clears the cached services for the given deviceId. Should be called upon disconnecting from the hub.
	         * @param {string} deviceId
	         */
	
	    }, {
	        key: 'clearServices',
	        value: function clearServices(deviceId) {
	            LegoServiceFactory.getServiceInstances(deviceId).forEach(function (service, connectId) {
	                LegoServiceFactory.removeService(deviceId, connectId);
	            });
	        }
	    }]);
	    return LegoServiceFactory;
	}();
	
	LegoServiceFactory.deviceToServices = new _map2.default();
	exports.default = LegoServiceFactory;

/***/ }),
/* 64 */
/***/ (function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ }),
/* 65 */
/***/ (function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(25)
	  , document = __webpack_require__(10).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ }),
/* 67 */
/***/ (function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(53)
	  , $export        = __webpack_require__(16)
	  , redefine       = __webpack_require__(109)
	  , hide           = __webpack_require__(24)
	  , has            = __webpack_require__(30)
	  , Iterators      = __webpack_require__(35)
	  , $iterCreate    = __webpack_require__(158)
	  , setToStringTag = __webpack_require__(40)
	  , getPrototypeOf = __webpack_require__(106)
	  , ITERATOR       = __webpack_require__(8)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(57)('meta')
	  , isObject = __webpack_require__(25)
	  , has      = __webpack_require__(30)
	  , setDesc  = __webpack_require__(17).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(34)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(71)
	  , createDesc     = __webpack_require__(56)
	  , toIObject      = __webpack_require__(26)
	  , toPrimitive    = __webpack_require__(78)
	  , has            = __webpack_require__(30)
	  , IE8_DOM_DEFINE = __webpack_require__(100)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(15) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ }),
/* 71 */
/***/ (function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	var hide = __webpack_require__(24);
	module.exports = function(target, src, safe){
	  for(var key in src){
	    if(safe && target[key])target[key] = src[key];
	    else hide(target, key, src[key]);
	  } return target;
	};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(74)('keys')
	  , uid    = __webpack_require__(57);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(10)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ }),
/* 75 */
/***/ (function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(75)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(51);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(25);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(10)
	  , core           = __webpack_require__(4)
	  , LIBRARY        = __webpack_require__(53)
	  , wksExt         = __webpack_require__(80)
	  , defineProperty = __webpack_require__(17).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(8);

/***/ }),
/* 81 */
/***/ (function(module, exports) {



/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _regenerator = __webpack_require__(14);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(13);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	var _BluetoothServiceDefinition = __webpack_require__(37);
	
	var _BluetoothServiceDefinition2 = _interopRequireDefault(_BluetoothServiceDefinition);
	
	var _DeviceInfoServiceDefinition = __webpack_require__(32);
	
	var _DeviceInfoServiceDefinition2 = _interopRequireDefault(_DeviceInfoServiceDefinition);
	
	var _LegoDeviceImpl = __webpack_require__(27);
	
	var _UuidHelper = __webpack_require__(11);
	
	var _UuidHelper2 = _interopRequireDefault(_UuidHelper);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @ignore For internal use
	 * Callback implementation used internally for receiving connection state changes, service discovered, and
	 * characteristic read events
	 */
	var BluetoothDeviceCallback = function () {
	    /**
	     *
	     * @param {LegoBluetoothDeviceImpl} legoBluetoothDevice
	     * @param {BluetoothDeviceCallback} bluetoothGattCallback
	     */
	    function BluetoothDeviceCallback(legoBluetoothDevice) {
	        var bluetoothGattCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	        (0, _classCallCheck3.default)(this, BluetoothDeviceCallback);
	
	        /**
	         * @private
	         * @type {LegoBluetoothDeviceImpl}
	         */
	        this.legoBluetoothDevice = legoBluetoothDevice;
	        /**
	         * @private
	         * @type {BluetoothDeviceCallback}
	         */
	        this.bluetoothGattCallback = bluetoothGattCallback;
	    }
	
	    /**
	     * Updates the connectState for the legoBluetoothDevice to newState
	     * @param {string|null} error If set an error was received instead of a new state.
	     * @param {number} newState The new state for the legoBluetoothDevice - the valid states are defined in {@link StateEnum}
	     *
	     * @return {Promise} Resolves once the bluetoothGattCallback has been notified about the connection state change
	     * - @see {@link BluetoothDeviceCallback#onConnectionStateChange}. Rejects if an error occurs.
	     */
	
	
	    (0, _createClass3.default)(BluetoothDeviceCallback, [{
	        key: 'onConnectionStateChange',
	        value: function () {
	            var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(error, newState) {
	                return _regenerator2.default.wrap(function _callee$(_context) {
	                    while (1) {
	                        switch (_context.prev = _context.next) {
	                            case 0:
	                                this.legoBluetoothDevice.updateConnectionStateUponConnectionStateChange(error, newState);
	
	                                if (!(this.legoBluetoothDevice.connectState === _LegoDeviceImpl.StateEnum.DisconnectedAdvertising || this.legoBluetoothDevice.connectState === _LegoDeviceImpl.StateEnum.DisconnectedNotAdvertising)) {
	                                    _context.next = 7;
	                                    break;
	                                }
	
	                                _context.next = 4;
	                                return this.legoBluetoothDevice.closeGatt();
	
	                            case 4:
	                                /**
	                                 * @private
	                                 * @type {boolean}
	                                 */
	                                this.legoBluetoothDevice.userInitiatedDisconnect = false;
	                                _context.next = 8;
	                                break;
	
	                            case 7:
	                                if (!error && this.legoBluetoothDevice.connectState === _LegoDeviceImpl.StateEnum.Interrogating) {
	                                    if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                        _LDSDKLogger2.default.info('Interrogating services for device \'' + this.legoBluetoothDevice.getName() + '\'');
	                                    }
	                                }
	
	                            case 8:
	                                if (!(this.bluetoothGattCallback !== null)) {
	                                    _context.next = 13;
	                                    break;
	                                }
	
	                                _context.next = 11;
	                                return this.bluetoothGattCallback.onConnectionStateChange(error, newState);
	
	                            case 11:
	                                _context.next = 14;
	                                break;
	
	                            case 13:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('this.bluetoothGattCallback is null in ' + this.constructor.name + ' - not calling' + ' onConnectionStateChange');
	                                }
	
	                            case 14:
	                            case 'end':
	                                return _context.stop();
	                        }
	                    }
	                }, _callee, this);
	            }));
	
	            function onConnectionStateChange(_x2, _x3) {
	                return _ref.apply(this, arguments);
	            }
	
	            return onConnectionStateChange;
	        }()
	
	        /**
	         * Receives services discovered event, notifies the bluetoothGattCallback (if set) and updates the
	         * LegoBluetoothDeviceImpl by calling its discoverCharacteristicsForService function.
	         *
	         * @param {string} error If error is set the service discovery failed
	         * @param {Array<NativeService>} services
	         *
	         * @return {Promise} Resolves once all the LegoBluetoothDevice#discoverCharacteristicsForService finishes.
	         */
	
	    }, {
	        key: 'onServicesDiscovered',
	        value: function () {
	            var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(error, services) {
	                var i, service, serviceDefinition, discoverCharacteristicsForServiceStart;
	                return _regenerator2.default.wrap(function _callee2$(_context2) {
	                    while (1) {
	                        switch (_context2.prev = _context2.next) {
	                            case 0:
	                                if (!(this.bluetoothGattCallback !== null)) {
	                                    _context2.next = 3;
	                                    break;
	                                }
	
	                                _context2.next = 3;
	                                return this.bluetoothGattCallback.onServicesDiscovered(error, services);
	
	                            case 3:
	                                if (error) {
	                                    _context2.next = 21;
	                                    break;
	                                }
	
	                                if (services.length === 0) {
	                                    _LDSDKLogger2.default.error('Did not find any services for device ' + this.legoBluetoothDevice.getName());
	                                } else {
	                                    if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                        _LDSDKLogger2.default.info('Did discover services (' + services.length + ') for device: ' + this.legoBluetoothDevice.getName());
	                                    }
	                                }
	
	                                // Loop through the newly filled services array, just in case there's more than one.
	                                i = 0;
	
	                            case 6:
	                                if (!(i < services.length)) {
	                                    _context2.next = 21;
	                                    break;
	                                }
	
	                                service = services[i];
	
	                                if (!(!service || service === null)) {
	                                    _context2.next = 11;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                    _LDSDKLogger2.default.warn('Service not initialized - continuing');
	                                }
	                                return _context2.abrupt('continue', 18);
	
	                            case 11:
	                                serviceDefinition = _BluetoothServiceDefinition2.default.serviceDefinitionWithUUID(_UuidHelper2.default.getUuid(service));
	
	                                if (serviceDefinition === null) {
	                                    if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                        _LDSDKLogger2.default.info('Did discover service with unsupported UUID ' + _UuidHelper2.default.getUuid(service) + '. For' + ' details about this service - see' + ' https://developer.bluetooth.org/gatt/services/Pages/ServicesHome.aspx for list of service uuids that are part of the BLE spec. Note: Only a subset of' + ' services in the BLE spec are supported by this SDK');
	                                    }
	                                }
	
	                                // We start by only discovering the Bluetooth Device Info service. Once we are sure that we are talking
	                                // to a Device with a supported firmware version, we discover characteristics for the remaining services
	
	                                if (!_DeviceInfoServiceDefinition2.default.getInstance().matchesService(service)) {
	                                    _context2.next = 18;
	                                    break;
	                                }
	
	                                discoverCharacteristicsForServiceStart = new Date().getTime();
	                                _context2.next = 17;
	                                return this.legoBluetoothDevice.discoverCharacteristicsForService(service);
	
	                            case 17:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('discoverCharacteristicsForService completed. Discovery took ' + (discoverCharacteristicsForServiceStart - new Date().getTime()) + ' ms');
	                                }
	
	                            case 18:
	                                i++;
	                                _context2.next = 6;
	                                break;
	
	                            case 21:
	                            case 'end':
	                                return _context2.stop();
	                        }
	                    }
	                }, _callee2, this);
	            }));
	
	            function onServicesDiscovered(_x4, _x5) {
	                return _ref2.apply(this, arguments);
	            }
	
	            return onServicesDiscovered;
	        }()
	
	        /**
	         * Receives the characteristic read notification and calls the {@link LegoBluetoothDeviceImpl#handleReadOrUpdatedCharacteristic}
	         * and schedules an execute next operation.
	         *
	         * @param {NativeCharacteristic} characteristic
	         * @param {*} status
	         */
	
	    }, {
	        key: 'onCharacteristicRead',
	        value: function () {
	            var _ref3 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(characteristic, status) {
	                return _regenerator2.default.wrap(function _callee3$(_context3) {
	                    while (1) {
	                        switch (_context3.prev = _context3.next) {
	                            case 0:
	                                if (!(this.bluetoothGattCallback !== null)) {
	                                    _context3.next = 5;
	                                    break;
	                                }
	
	                                _context3.next = 3;
	                                return this.bluetoothGattCallback.onCharacteristicRead(characteristic, status);
	
	                            case 3:
	                                _context3.next = 6;
	                                break;
	
	                            case 5:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('this.bluetoothGattCallback is null in ' + this.constructor.name + ' - not calling' + ' onCharacteristicRead');
	                                }
	
	                            case 6:
	                                _context3.next = 8;
	                                return this.legoBluetoothDevice.handleReadOrUpdatedCharacteristic(characteristic);
	
	                            case 8:
	                                _context3.next = 10;
	                                return this.legoBluetoothDevice.executeNextOperationQueue();
	
	                            case 10:
	                            case 'end':
	                                return _context3.stop();
	                        }
	                    }
	                }, _callee3, this);
	            }));
	
	            function onCharacteristicRead(_x6, _x7) {
	                return _ref3.apply(this, arguments);
	            }
	
	            return onCharacteristicRead;
	        }()
	    }]);
	    return BluetoothDeviceCallback;
	}();
	
	exports.default = BluetoothDeviceCallback;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _stringify = __webpack_require__(19);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _regenerator = __webpack_require__(14);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(13);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _promise = __webpack_require__(12);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _map = __webpack_require__(9);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	var _ChromeOsBluetoothDeviceWrapper = __webpack_require__(58);
	
	var _ChromeOsBluetoothDeviceWrapper2 = _interopRequireDefault(_ChromeOsBluetoothDeviceWrapper);
	
	var _LegoDeviceManagerImpl = __webpack_require__(31);
	
	var _LegoDeviceManagerImpl2 = _interopRequireDefault(_LegoDeviceManagerImpl);
	
	var _DeviceInfoServiceDefinition = __webpack_require__(32);
	
	var _DeviceInfoServiceDefinition2 = _interopRequireDefault(_DeviceInfoServiceDefinition);
	
	var _LegoDeviceImpl = __webpack_require__(27);
	
	var _StringUtils = __webpack_require__(21);
	
	var _StringUtils2 = _interopRequireDefault(_StringUtils);
	
	var _UuidHelper = __webpack_require__(11);
	
	var _UuidHelper2 = _interopRequireDefault(_UuidHelper);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @ignore For internal use
	 * This class wraps the chrome.bluetooth operations for scanning, getting a device details, getting known devices,
	 * and registers listeners for the callbacks fired when devices are detected/removed or changed.
	 */
	var ChromeOsBluetoothAdapterWrapper = function () {
	    function ChromeOsBluetoothAdapterWrapper() {
	        (0, _classCallCheck3.default)(this, ChromeOsBluetoothAdapterWrapper);
	        this.listener = null;
	        this.wrappers = new _map2.default();
	    }
	    /**
	     * @private
	     * @type {ChromeOsBluetoothAdapterWrapper}
	     */
	
	
	    /**
	     * @private
	     * @type {object}
	     */
	
	
	    /**
	     * @private
	     * @type {Map}
	     */
	
	
	    (0, _createClass3.default)(ChromeOsBluetoothAdapterWrapper, [{
	        key: 'getName',
	
	
	        /**
	         * Get the constructor name
	         * @return {string}
	         */
	        value: function getName() {
	            return this.constructor.name;
	        }
	
	        /**
	         *
	         * Promise implementation of the chrome.bluetooth.startDiscovery.
	         *
	         * Before starting the discovery it fires the DeviceAddedForExistingDevices event for all the known LEGO devices
	         * (that is previously paired or seen).
	         *
	         * @return {Promise} Resolves when the discovery has been started. Rejects if startDiscovery fails.
	         */
	
	    }, {
	        key: 'startLeScan',
	        value: function startLeScan() {
	            var _this = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                _this.isScanning().then(function (scanning) {
	                    if (!scanning) {
	                        chrome.bluetooth.startDiscovery(function () {
	                            if (chrome.runtime.lastError) {
	                                if (chrome.runtime.lastError.message !== 'Already discovering') {
	                                    _LDSDKLogger2.default.error('Failed to start discovery: ' + chrome.runtime.lastError.message);
	                                    reject(chrome.runtime.lastError);
	                                }
	                            }
	                            if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                _LDSDKLogger2.default.debug('Discovery started');
	                            }
	                            resolve();
	                        });
	                    } else {
	                        if (_LDSDKLogger2.default.isTraceEnabled()) {
	                            _LDSDKLogger2.default.debug('Discovery already running');
	                        }
	                        resolve();
	                    }
	                });
	            }).catch(function (err) {
	                _LDSDKLogger2.default.error('startLeScan :: Failed starting discovery', err);
	                return _promise2.default.reject(err);
	            });
	        }
	
	        /**
	         * Get device for the MAC address
	         * @param {string} address
	         * @return {Promise<NativeDevice>} The promise resolves a {@link Device}
	         */
	
	    }, {
	        key: 'getDevice',
	        value: function getDevice(address) {
	            return new _promise2.default(function (resolve, reject) {
	                chrome.bluetooth.getDevice(address, function (device) {
	                    if (chrome.runtime.lastError) {
	                        return reject(chrome.runtime.lastError);
	                    }
	                    return resolve(device);
	                });
	            });
	        }
	
	        /**
	         * Get a {@link ChromeOsBluetoothDeviceWrapper} for the native device. If a cached instance is found, it will be updated with the data
	         * in the nativeDevice - if no cached instance is found a new instance is added to the cache.
	         * @param {NativeDevice} nativeDevice
	         * @return {ChromeOsBluetoothDeviceWrapper}
	         */
	
	    }, {
	        key: 'getWrappedDevice',
	        value: function getWrappedDevice(nativeDevice) {
	            var wrappedDevice = void 0;
	            if (this.wrappers.has(nativeDevice.address)) {
	                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                    _LDSDKLogger2.default.trace('Cached ChromeOsBluetoothDeviceWrapper found for ' + nativeDevice.address);
	                }
	                wrappedDevice = this.wrappers.get(nativeDevice.address);
	                wrappedDevice.updateNativeDevice(nativeDevice);
	            } else {
	                wrappedDevice = new _ChromeOsBluetoothDeviceWrapper2.default(nativeDevice);
	                if (wrappedDevice.isLegoDevice()) {
	                    if (_LDSDKLogger2.default.isInfoEnabled()) {
	                        _LDSDKLogger2.default.info('Created and cached ChromeOsBluetoothDeviceWrapper for ' + nativeDevice.address);
	                    }
	                    this.wrappers.set(wrappedDevice.getAddress(), wrappedDevice);
	                }
	            }
	            return wrappedDevice;
	        }
	
	        /**
	         * Add listeners to receive newly found devices and updates to the previously known devices.
	         */
	
	    }, {
	        key: 'registerOnDeviceListeners',
	        value: function registerOnDeviceListeners() {
	            var _this2 = this;
	
	            if (!this.listenerRegistered || this.listenerRegistered === null) {
	                chrome.bluetooth.onDeviceAdded.addListener(function () {
	                    var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(device) {
	                        var wrappedDevice;
	                        return _regenerator2.default.wrap(function _callee$(_context) {
	                            while (1) {
	                                switch (_context.prev = _context.next) {
	                                    case 0:
	                                        wrappedDevice = _this2.getWrappedDevice(device);
	
	                                        if (wrappedDevice.isLegoDevice()) {
	                                            _context.next = 4;
	                                            break;
	                                        }
	
	                                        if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                            _LDSDKLogger2.default.debug('onDeviceAdded !isLegoDevice - Device "' + device.name + '" added', device);
	                                        }
	                                        return _context.abrupt('return');
	
	                                    case 4:
	                                        if (!(_this2.listener !== null)) {
	                                            _context.next = 10;
	                                            break;
	                                        }
	
	                                        if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                            _LDSDKLogger2.default.debug('onDeviceAdded - Invoking listener onDeviceAdded - Device "' + device.name + '" added', device);
	                                        }
	                                        _context.next = 8;
	                                        return _this2.listener.onDeviceAdded(wrappedDevice);
	
	                                    case 8:
	                                        _context.next = 11;
	                                        break;
	
	                                    case 10:
	                                        if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                            _LDSDKLogger2.default.debug('onDeviceAdded - Listener NOT set', device);
	                                        }
	
	                                    case 11:
	                                    case 'end':
	                                        return _context.stop();
	                                }
	                            }
	                        }, _callee, _this2);
	                    }));
	
	                    return function (_x) {
	                        return _ref.apply(this, arguments);
	                    };
	                }());
	                chrome.bluetooth.onDeviceChanged.addListener(function () {
	                    var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(device) {
	                        var wrappedDevice;
	                        return _regenerator2.default.wrap(function _callee2$(_context2) {
	                            while (1) {
	                                switch (_context2.prev = _context2.next) {
	                                    case 0:
	                                        wrappedDevice = _this2.getWrappedDevice(device);
	
	                                        if (wrappedDevice.isLegoDevice()) {
	                                            _context2.next = 4;
	                                            break;
	                                        }
	
	                                        if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                            _LDSDKLogger2.default.debug('onDeviceChanged !isLegoDevice - Device "' + device.name + '" changed', device);
	                                        }
	                                        return _context2.abrupt('return');
	
	                                    case 4:
	                                        if (!(_this2.listener !== null)) {
	                                            _context2.next = 10;
	                                            break;
	                                        }
	
	                                        if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                            _LDSDKLogger2.default.debug('onDeviceChanged - Invoking listener onDeviceChanged - Device "' + device.name + '" changed', device);
	                                        }
	                                        _context2.next = 8;
	                                        return _this2.listener.onDeviceChanged(wrappedDevice);
	
	                                    case 8:
	                                        _context2.next = 11;
	                                        break;
	
	                                    case 10:
	                                        if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                            _LDSDKLogger2.default.debug('onDeviceChanged - Listener NOT set', device);
	                                        }
	
	                                    case 11:
	                                    case 'end':
	                                        return _context2.stop();
	                                }
	                            }
	                        }, _callee2, _this2);
	                    }));
	
	                    return function (_x2) {
	                        return _ref2.apply(this, arguments);
	                    };
	                }());
	                chrome.bluetooth.onDeviceRemoved.addListener(function () {
	                    var _ref3 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(device) {
	                        var wrappedDevice;
	                        return _regenerator2.default.wrap(function _callee3$(_context3) {
	                            while (1) {
	                                switch (_context3.prev = _context3.next) {
	                                    case 0:
	                                        wrappedDevice = _this2.getWrappedDevice(device);
	
	                                        if (wrappedDevice.isLegoDevice()) {
	                                            _context3.next = 4;
	                                            break;
	                                        }
	
	                                        if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                            _LDSDKLogger2.default.debug('onDeviceRemoved !isLegoDevice - Device "' + device.name + '" removed', device);
	                                        }
	                                        return _context3.abrupt('return');
	
	                                    case 4:
	                                        if (!(_this2.listener !== null)) {
	                                            _context3.next = 10;
	                                            break;
	                                        }
	
	                                        if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                            _LDSDKLogger2.default.debug('onDeviceRemoved - Invoking listener onDeviceRemoved - Device "' + device.name + '" removed', device);
	                                        }
	                                        _context3.next = 8;
	                                        return _this2.listener.onDeviceRemoved(wrappedDevice);
	
	                                    case 8:
	                                        _context3.next = 11;
	                                        break;
	
	                                    case 10:
	                                        if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                            _LDSDKLogger2.default.debug('onDeviceRemoved - Listener NOT set', device);
	                                        }
	
	                                    case 11:
	                                    case 'end':
	                                        return _context3.stop();
	                                }
	                            }
	                        }, _callee3, _this2);
	                    }));
	
	                    return function (_x3) {
	                        return _ref3.apply(this, arguments);
	                    };
	                }());
	                /**
	                 * @private
	                 * @type {boolean}
	                 */
	                this.listenerRegistered = true;
	            }
	        }
	
	        /**
	         * Register for onService* callbacks when connecting to a device
	         */
	
	    }, {
	        key: 'registerOnServiceListener',
	        value: function registerOnServiceListener() {
	            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                _LDSDKLogger2.default.info('Registering onServiceAdded listener on adapter');
	            }
	            if (typeof this.onServiceListenerRegistered === 'undefined' || this.onServiceListenerRegistered === null) {
	
	                chrome.bluetoothLowEnergy.onServiceAdded.addListener(function (service) {
	                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                        _LDSDKLogger2.default.debug('chrome.bluetoothLowEnergy.onServiceAdded called with service ' + _StringUtils2.default.getInstanceString(service));
	                    }
	                    var bluetoothDevice = _LegoDeviceManagerImpl2.default.getInstance().getDevice(service.deviceAddress, false);
	                    if (bluetoothDevice && bluetoothDevice !== null) {
	                        if (!bluetoothDevice.deviceNativeServices.has(_UuidHelper2.default.getUuid(service))) {
	                            bluetoothDevice.deviceNativeServices.set(_UuidHelper2.default.getUuid(service), service);
	                            if (bluetoothDevice.deviceNativeServices.size >= 5) {
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('handleService onServiceAdded completed successfully - constructing services array for firing onServicesDiscovered. Service uuid: ' + _UuidHelper2.default.getUuid(service) + ', device address: ' + service.deviceAddress);
	                                }
	                                var services = [];
	                                bluetoothDevice.deviceNativeServices.forEach(function (value, key, map) {
	                                    services.push(value);
	                                });
	                                bluetoothDevice.getBluetoothWrapper().getConnectCallback().onServicesDiscovered(null, services);
	                            }
	                        }
	                    } else {
	                        if (_LDSDKLogger2.default.isWarnEnabled()) {
	                            _LDSDKLogger2.default.warn('No bluetooth device found for service ', (0, _stringify2.default)(service));
	                        }
	                    }
	                });
	
	                chrome.bluetoothLowEnergy.onServiceChanged.addListener(function (service) {
	                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                        _LDSDKLogger2.default.debug('chrome.bluetoothLowEnergy.onServiceChanged called with service', service);
	                    }
	                });
	
	                chrome.bluetoothLowEnergy.onServiceRemoved.addListener(function (service) {
	                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                        _LDSDKLogger2.default.debug('chrome.bluetoothLowEnergy.onServiceRemoved called with service', service);
	                    }
	                    var bluetoothDevice = _LegoDeviceManagerImpl2.default.getInstance().getDevice(service.deviceAddress, false);
	                    if (!bluetoothDevice || bluetoothDevice === null) return;
	
	                    if (bluetoothDevice.deviceNativeServices.has(service.uuid)) {
	                        bluetoothDevice.deviceNativeServices.delete(service.uuid);
	                    }
	                });
	
	                /**
	                 * @private
	                 * @type {boolean}
	                 */
	                this.onServiceListenerRegistered = true;
	            }
	        }
	
	        /**
	         * Register for characteristic value changes
	         */
	
	    }, {
	        key: 'registerOnCharacteristicValueChangedListener',
	        value: function registerOnCharacteristicValueChangedListener() {
	            if (!this.onCharacteristicValueChangedListenerRegistered || this.onCharacteristicValueChangedListenerRegistered === null) {
	                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                    _LDSDKLogger2.default.info('Registering onCharacteristicValueChanged listener on adapter');
	                }
	                /*
	                This code will only be called if startCharacteristicNotifications has been enabled for a
	                 characteristicId (device specific id)
	                 */
	                chrome.bluetoothLowEnergy.onCharacteristicValueChanged.addListener(function (characteristic) {
	                    if (chrome.runtime.lastError) {
	                        if (_LDSDKLogger2.default.isErrorEnabled()) {
	                            _LDSDKLogger2.default.error('Failed onCharacteristicValueChanged for ' + _StringUtils2.default.getCharacteristicString(characteristic) + '. chrome.runtime.lastError.message: ' + chrome.runtime.lastError.message);
	                        }
	                        return;
	                    }
	
	                    var cachedDevice = _LegoDeviceManagerImpl2.default.getInstance().getDevice(characteristic.service.deviceAddress, false);
	                    if (cachedDevice && cachedDevice !== null) {
	                        if (_LDSDKLogger2.default.isTraceEnabled()) {
	                            _LDSDKLogger2.default.debug('Got result for onCharacteristicValueChanged for address: ' + characteristic.service.deviceAddress + ', Characteristic: ' + _StringUtils2.default.getCharacteristicString(characteristic));
	                        }
	                        cachedDevice.handleReadOrUpdatedCharacteristic(characteristic);
	                    } else {
	                        if (_LDSDKLogger2.default.isDebugEnabled()) {
	                            _LDSDKLogger2.default.debug('The characteristic event received is meant for device address: ' + characteristic.service.deviceAddress + ', but no connected device was found for that address. Characteristic: ', characteristic, ' - Ignoring event');
	                        }
	                        return;
	                    }
	                });
	                /**
	                 * @private
	                 * @type {boolean}
	                 */
	                this.onCharacteristicValueChangedListenerRegistered = true;
	            } else {
	                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                    _LDSDKLogger2.default.info('onCharacteristicValueChangedListenerRegistered is already set - returning');
	                }
	            }
	        }
	
	        /**
	         * Checks if the adapter is discovering and calls chrome.bluetooth.stopDiscovery if it is.
	         * @return {Promise} The promise resolves once scanning stops, and rejects if chrome.runtime.lastError is set.
	         */
	
	    }, {
	        key: 'stopLeScan',
	        value: function stopLeScan() {
	            var _this3 = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                _this3.isScanning().then(function (scanning) {
	                    if (scanning) {
	                        chrome.bluetooth.stopDiscovery(function () {
	                            if (chrome.runtime.lastError) {
	                                if (chrome.runtime.lastError.message !== 'Failed to stop discovery') {
	                                    _LDSDKLogger2.default.error('Failed stopping discovery: \'' + chrome.runtime.lastError.message + '\'');
	                                    return reject(chrome.runtime.lastError);
	                                }
	                            }
	                            if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                _LDSDKLogger2.default.debug('Discovery stopped');
	                            }
	                            return resolve();
	                        });
	                    } else {
	                        if (_LDSDKLogger2.default.isTraceEnabled()) {
	                            _LDSDKLogger2.default.debug('Discovery already stopped');
	                        }
	                        return resolve();
	                    }
	                }).catch(function (err) {
	                    _LDSDKLogger2.default.error('Failed stopping discovery (catch): ', err);
	                    return reject(err);
	                });
	            });
	        }
	
	        /**
	         *
	         * @return {Promise.<bool>} resolves a boolean true if bluetooth is available and turned on, resolves a
	         * boolean false if bluetooth is not available, or the adapter is turned off. In case of errors, it rejects the
	         * promise with an error message.
	         */
	
	    }, {
	        key: 'isBluetoothAvailable',
	        value: function isBluetoothAvailable() {
	            return new _promise2.default(function (resolve, reject) {
	                chrome.bluetooth.getAdapterState(function (adapter) {
	                    if (chrome.runtime.lastError) {
	                        _LDSDKLogger2.default.error('Failed getting adapter state', chrome.runtime.lastError);
	                        return reject(chrome.runtime.lastError);
	                    }
	                    return resolve(adapter.available);
	                });
	            }).catch(function (err) {
	                _LDSDKLogger2.default.error('Failed getting adapter state', err);
	                return reject(err);
	            });
	        }
	
	        /**
	         * If Bluetooth is enabled this function returns whether the adapter is scanning for devices or not. If
	         * Bluetooth is not enabled it will return false;
	         *
	         * @return {Promise.<bool>} - Result is a boolean returned as a promise
	         */
	
	    }, {
	        key: 'isScanning',
	        value: function isScanning() {
	            var _this4 = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                return _this4.isBluetoothEnabledOnDevice().then(function (enabled) {
	                    if (enabled) {
	                        chrome.bluetooth.getAdapterState(function (adapter) {
	                            if (chrome.runtime.lastError) {
	                                _LDSDKLogger2.default.error('Failed getting adapter state', chrome.runtime.lastError);
	                                return reject(chrome.runtime.lastError);
	                            }
	                            return resolve(adapter.discovering);
	                        });
	                    } else {
	                        return resolve(false);
	                    }
	                }).catch(function (err) {
	                    _LDSDKLogger2.default.error('Failed getting adapter state', err);
	                    return reject(err);
	                });
	            });
	        }
	
	        /**
	         * Checks if Bluetooth is enabled
	         *
	         * @return {Promise.<bool>} Resolves to true if enabled, false if it is not enabled. Rejects if any errors
	         * occur.
	         */
	
	    }, {
	        key: 'isBluetoothEnabledOnDevice',
	        value: function isBluetoothEnabledOnDevice() {
	            return new _promise2.default(function (resolve, reject) {
	                chrome.bluetooth.getAdapterState(function (adapter) {
	                    if (chrome.runtime.lastError) {
	                        _LDSDKLogger2.default.error('Failed getting adapter state: ', chrome.runtime.lastError);
	                        return reject(chrome.runtime.lastError);
	                    }
	                    return resolve(adapter.powered && adapter.available);
	                });
	            }).catch(function (err) {
	                _LDSDKLogger2.default.error('Failed getting adapter state', err);
	                return _promise2.default.reject(err);
	            });
	        }
	
	        /**
	         * Connects the listener that should receive deviceAdded, deviceChanged, and deviceRemoved callbacks.
	         *
	         * @param {DeviceCallbackListener} listener
	         */
	
	    }, {
	        key: 'connectCallbackListener',
	        value: function connectCallbackListener(listener) {
	            /**
	             * @private
	             * @type {object}
	             */
	            this.listener = listener;
	        }
	    }], [{
	        key: 'getInstance',
	
	
	        /**
	         * Get the adapter wrapper instance
	         * @return {ChromeOsBluetoothAdapterWrapper}
	         */
	        value: function getInstance() {
	            if (ChromeOsBluetoothAdapterWrapper.instance === null) {
	                ChromeOsBluetoothAdapterWrapper.instance = new ChromeOsBluetoothAdapterWrapper();
	                ChromeOsBluetoothAdapterWrapper.instance.registerOnDeviceListeners();
	                ChromeOsBluetoothAdapterWrapper.instance.registerOnServiceListener();
	            }
	            return ChromeOsBluetoothAdapterWrapper.instance;
	        }
	    }]);
	    return ChromeOsBluetoothAdapterWrapper;
	}();
	
	ChromeOsBluetoothAdapterWrapper.instance = null;
	exports.default = ChromeOsBluetoothAdapterWrapper;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.DeviceCallbackListener = exports.BaseBluetoothGattCallback = exports.BluetoothDeviceManagerCallbackHelper = undefined;
	
	var _regenerator = __webpack_require__(14);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(13);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _getPrototypeOf = __webpack_require__(5);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _possibleConstructorReturn2 = __webpack_require__(7);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get2 = __webpack_require__(23);
	
	var _get3 = _interopRequireDefault(_get2);
	
	var _inherits2 = __webpack_require__(6);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _promise = __webpack_require__(12);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _map = __webpack_require__(9);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _LegoDeviceManagerImpl = __webpack_require__(31);
	
	var _LegoDeviceManagerImpl2 = _interopRequireDefault(_LegoDeviceManagerImpl);
	
	var _BluetoothServiceDefinition = __webpack_require__(37);
	
	var _BluetoothServiceDefinition2 = _interopRequireDefault(_BluetoothServiceDefinition);
	
	var _SimpleList = __webpack_require__(45);
	
	var _SimpleList2 = _interopRequireDefault(_SimpleList);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	var _LegoDeviceImpl = __webpack_require__(27);
	
	var _LDSDKError = __webpack_require__(44);
	
	var _LDSDKError2 = _interopRequireDefault(_LDSDKError);
	
	var _LegoBluetoothDeviceImpl = __webpack_require__(59);
	
	var _LegoBluetoothDeviceImpl2 = _interopRequireDefault(_LegoBluetoothDeviceImpl);
	
	var _UuidHelper = __webpack_require__(11);
	
	var _UuidHelper2 = _interopRequireDefault(_UuidHelper);
	
	var _BluetoothDeviceCallback = __webpack_require__(82);
	
	var _BluetoothDeviceCallback2 = _interopRequireDefault(_BluetoothDeviceCallback);
	
	var _IdHelper = __webpack_require__(28);
	
	var _IdHelper2 = _interopRequireDefault(_IdHelper);
	
	var _StringUtils = __webpack_require__(21);
	
	var _StringUtils2 = _interopRequireDefault(_StringUtils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * This class can be used to offload the main thread and execute the callbacks on a different thread (currently
	 * however all the callbacks are simply postponed slightly using setTimeout(callback, timeInMillis).
	 *
	 * As a user of the SDK you are not supposed to use this class directly, instead you should use the
	 * registerCallbackListener and unregisterCallbackListener methods of the {@link LegoBluetoothDeviceManagerImpl} class
	 *
	 * Created by frj on 18/02/16.
	 */
	var BluetoothDeviceManagerCallbackHelper = exports.BluetoothDeviceManagerCallbackHelper = function () {
	    function BluetoothDeviceManagerCallbackHelper() {
	        (0, _classCallCheck3.default)(this, BluetoothDeviceManagerCallbackHelper);
	
	        this.callbackListeners = new _map2.default();
	
	        var requiredCallbackFunctions = [];
	        requiredCallbackFunctions.push('onDeviceDidAppear');
	        requiredCallbackFunctions.push('onDeviceDidDisappear');
	        requiredCallbackFunctions.push('onWillStartConnectingToDevice');
	        requiredCallbackFunctions.push('onDidStartInterrogatingDevice');
	        requiredCallbackFunctions.push('onDidFinishInterrogatingDevice');
	        requiredCallbackFunctions.push('onDidDisconnectFromDevice');
	        requiredCallbackFunctions.push('onDidFailToConnectToDevice');
	
	        this.requiredCallbackFunctions = requiredCallbackFunctions;
	    }
	
	    /**
	     * Registers a callback
	     * @param {object} callback
	     * @returns {string} A unique callback id that can be used to unregister the callback later.s
	     */
	
	
	    (0, _createClass3.default)(BluetoothDeviceManagerCallbackHelper, [{
	        key: 'registerCallbackListener',
	        value: function registerCallbackListener(callback) {
	            this.checkCallbackListener(callback);
	            var callbackIdKey = 'generatedCallbackId';
	            var callbackId = void 0;
	            if (callback.hasOwnProperty(callbackIdKey)) {
	                callbackId = callback[callbackIdKey];
	                if (!this.callbackListeners.has(callbackId)) {
	                    this.callbackListeners.set(callbackId, callback);
	                }
	            } else {
	                callbackId = _IdHelper2.default.generateID();
	                while (this.callbackListeners.has(callbackId)) {
	                    // in case the map already has a key === callbackId we generate a new one
	                    callbackId = _IdHelper2.default.generateID();
	                }
	                callback.generatedCallbackId = callbackId;
	                this.callbackListeners.set(callbackId, callback);
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug(this.constructor.name + ' - Registered callback listener with id ' + callbackId + ' - new' + ' callbacklisteners size: ' + this.callbackListeners.size + ' listeners');
	                }
	            }
	
	            return callbackId;
	        }
	
	        /**
	         *  Unregisters a callback
	         *
	         * @param {string} callbackId - A unique callback id that was returned when registering the listener.
	         * @returns {boolean} - Returns true if a callback existed with that id, or false if no callback was found with
	         * that id.
	         */
	
	    }, {
	        key: 'unregisterCallbackListener',
	        value: function unregisterCallbackListener(callbackId) {
	            var result = this.callbackListeners.delete(callbackId);
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug(this.constructor.name + ' - Unregistered callback listener - new' + ' callbacklisteners size: ' + this.callbackListeners.size + ' listeners');
	            }
	            return result;
	        }
	
	        /**
	         * @ignore
	         *
	         * @param {LegoBluetoothDeviceImpl} legoBluetoothDevice
	         * @return {Promise}
	         */
	
	    }, {
	        key: 'performDeviceDidAppearCallback',
	        value: function performDeviceDidAppearCallback(legoBluetoothDevice) {
	            return new _promise2.default(function (resolve) {
	                _LegoDeviceManagerImpl2.default.getInstance().onDeviceDidAppear(legoBluetoothDevice);
	                return resolve();
	            });
	        }
	
	        /**
	         * @ignore
	         *
	         * @param {LegoBluetoothDeviceImpl} legoBluetoothDevice
	         * @return {Promise}
	         */
	
	    }, {
	        key: 'performDeviceDidChangeCallback',
	        value: function performDeviceDidChangeCallback(legoBluetoothDevice) {
	            return new _promise2.default(function (resolve) {
	                var nativeDevice = legoBluetoothDevice.getBluetoothWrapper().getDevice();
	                if (nativeDevice.hasOwnProperty('inquiryRssi') && nativeDevice.inquiryRssi !== -1) {
	                    _LegoDeviceManagerImpl2.default.getInstance().onDeviceDidAppear(legoBluetoothDevice);
	                }
	                return resolve();
	            });
	        }
	
	        /**
	         * @ignore
	         *
	         * @param {LegoBluetoothDeviceImpl} legoBluetoothDevice
	         * @return {Promise}
	         */
	
	    }, {
	        key: 'performDeviceDidDisappearCallback',
	        value: function performDeviceDidDisappearCallback(legoBluetoothDevice) {
	            return new _promise2.default(function (resolve) {
	                _LegoDeviceManagerImpl2.default.getInstance().onDeviceDidDisappear(legoBluetoothDevice);
	                return resolve();
	            });
	        }
	
	        /**
	         * @ignore
	         *
	         * @param {LegoBluetoothDeviceImpl} legoBluetoothDevice
	         * @return {Promise}
	         */
	
	    }, {
	        key: 'performWillStartConnectingToDeviceCallback',
	        value: function performWillStartConnectingToDeviceCallback(legoBluetoothDevice) {
	            return new _promise2.default(function (resolve) {
	                _LegoDeviceManagerImpl2.default.getInstance().onWillStartConnectingToDevice(legoBluetoothDevice);
	                return resolve();
	            });
	        }
	
	        /**
	         * @ignore
	         *
	         * @param {LegoBluetoothDeviceImpl} legoBluetoothDevice
	         * @return {Promise}
	         */
	
	    }, {
	        key: 'performDidStartInterrogatingDeviceCallback',
	        value: function performDidStartInterrogatingDeviceCallback(legoBluetoothDevice) {
	            return new _promise2.default(function (resolve) {
	                _LegoDeviceManagerImpl2.default.getInstance().onDidStartInterrogatingDevice(legoBluetoothDevice);
	                return resolve();
	            });
	        }
	
	        /**
	         * @ignore
	         *
	         * @param {LegoBluetoothDeviceImpl} legoBluetoothDevice
	         * @return {Promise}
	         */
	
	    }, {
	        key: 'performDidFinishInterrogatingDeviceCallback',
	        value: function performDidFinishInterrogatingDeviceCallback(legoBluetoothDevice) {
	            return new _promise2.default(function (resolve) {
	                _LegoDeviceManagerImpl2.default.getInstance().onDidFinishInterrogatingDevice(legoBluetoothDevice);
	                return resolve();
	            });
	        }
	
	        /**
	         *
	         * @param {LegoBluetoothDeviceImpl} legoBluetoothDevice
	         * @param {boolean} autoReconnect
	         * @param {string|null} error
	         * @return {Promise}
	         */
	
	    }, {
	        key: 'performDidDisconnectFromDeviceCallback',
	        value: function performDidDisconnectFromDeviceCallback(legoBluetoothDevice, autoReconnect, error) {
	            return new _promise2.default(function (resolve) {
	                _LegoDeviceManagerImpl2.default.getInstance().onDidDisconnectFromDevice(legoBluetoothDevice, autoReconnect, error);
	                return resolve();
	            });
	        }
	    }, {
	        key: 'performDidFailToConnectToDeviceCallback',
	        value: function performDidFailToConnectToDeviceCallback(legoBluetoothDevice, autoReconnect, error) {
	            return new _promise2.default(function (resolve) {
	                _LegoDeviceManagerImpl2.default.getInstance().onDidFailToConnectToDevice(legoBluetoothDevice, autoReconnect, error);
	                return resolve();
	            });
	        }
	    }, {
	        key: 'checkCallbackListener',
	        value: function checkCallbackListener(callbackListener) {
	            if (callbackListener === null || callbackListener === undefined) {
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('Attempt to add undefined callback listener to ' + this.constructor.name + ' ignored');
	                }
	                return;
	            }
	
	            for (var i = 0; i < this.requiredCallbackFunctions.length; i++) {
	                var requiredFuncName = this.requiredCallbackFunctions[i];
	                var requiredFunc = callbackListener[requiredFuncName];
	                if (typeof requiredFunc !== 'function') {
	                    if (_LDSDKLogger2.default.isInfoEnabled()) {
	                        _LDSDKLogger2.default.info('The added callbacklistener of type ' + callbackListener.constructor.name + ' does not have an implementation of the required callback method ' + requiredFuncName);
	                    }
	                }
	            }
	        }
	    }]);
	    return BluetoothDeviceManagerCallbackHelper;
	}(); /**
	      * Created by frj on 22/02/16.
	      */
	
	
	var BaseBluetoothGattCallback = exports.BaseBluetoothGattCallback = function (_BluetoothDeviceCallb) {
	    (0, _inherits3.default)(BaseBluetoothGattCallback, _BluetoothDeviceCallb);
	
	    /**
	     *
	     * @param {LegoBluetoothDeviceImpl} legoBluetoothDevice
	     * @param {LegoBluetoothDeviceManagerImpl} deviceManagerImpl
	     */
	    function BaseBluetoothGattCallback(legoBluetoothDevice, deviceManagerImpl) {
	        (0, _classCallCheck3.default)(this, BaseBluetoothGattCallback);
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, (BaseBluetoothGattCallback.__proto__ || (0, _getPrototypeOf2.default)(BaseBluetoothGattCallback)).call(this, legoBluetoothDevice));
	
	        _this.retries = 0;
	        _this.connected = false;
	        _this.pollGetServicesRetry = 1;
	
	        _this.deviceManagerImpl = deviceManagerImpl;
	        return _this;
	    }
	
	    /**
	     * Gets the services for the device asynchronously and calls back on the callback param once they have been
	     * acquired.
	     *
	     * @param {function(services: Array<NativeService>)} callback
	     * @param {function(error: LDSDKError)} errorCallback
	     */
	
	
	    (0, _createClass3.default)(BaseBluetoothGattCallback, [{
	        key: 'lookupServicesWhenConnected',
	        value: function () {
	            var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(callback, errorCallback) {
	                var _this2 = this;
	
	                var address, nativeDevice, cachedNativeDevice, services, error, msg;
	                return _regenerator2.default.wrap(function _callee2$(_context2) {
	                    while (1) {
	                        switch (_context2.prev = _context2.next) {
	                            case 0:
	                                address = this.legoBluetoothDevice.getAddress();
	                                _context2.next = 3;
	                                return _LegoDeviceManagerImpl2.default.getInstance().getBluetoothAdapter().getDevice(address);
	
	                            case 3:
	                                nativeDevice = _context2.sent;
	                                _context2.next = 6;
	                                return this.deviceManagerImpl.getLegoBluetoothDeviceWithAddress(address);
	
	                            case 6:
	                                cachedNativeDevice = _context2.sent;
	
	                                if (!(nativeDevice.connected && !nativeDevice.connecting)) {
	                                    _context2.next = 23;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info('Device ' + nativeDevice.name + ' is connected (cached device isConnected: ' + (cachedNativeDevice !== null ? cachedNativeDevice.getBluetoothWrapper().isConnected() : 'null') + '). Looking up services for ' + this.legoBluetoothDevice.getBluetoothDevice().name);
	                                }
	
	                                _context2.next = 11;
	                                return this.legoBluetoothDevice.getBluetoothWrapper().discoverServices();
	
	                            case 11:
	                                services = _context2.sent;
	
	                                if (!(services.length > 0)) {
	                                    _context2.next = 18;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info('Looked up services for ' + this.legoBluetoothDevice.getBluetoothDevice().name + ' - found ' + services.length);
	                                }
	                                callback(services);
	                                return _context2.abrupt('return');
	
	                            case 18:
	                                if (!(this.retries >= _LegoDeviceManagerImpl2.default.getInstance().config.lookupServicesWhenConnectedRetryMaxCount)) {
	                                    _context2.next = 23;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isErrorEnabled()) {
	                                    _LDSDKLogger2.default.error('No services found for ' + nativeDevice.name + ' in retry #' + this.retries + '/' + _LegoDeviceManagerImpl2.default.getInstance().config.lookupServicesWhenConnectedRetryMaxCount);
	                                }
	                                error = _LDSDKError2.default.deviceError(_LDSDKError.ErrorCode.BLUETOOTH_CONNECTION_TIMEOUT, 'Unable to get services list from hub: ' + nativeDevice.name + ' [' + address + '] in ' + this.retries + ' attempts');
	
	                                errorCallback(error);
	                                return _context2.abrupt('return');
	
	                            case 23:
	                                if (this.retries < _LegoDeviceManagerImpl2.default.getInstance().config.lookupServicesWhenConnectedRetryMaxCount) {
	                                    if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                        msg = 'Device "' + address + ' [' + nativeDevice.name + ']"';
	
	                                        if (nativeDevice.connected && !nativeDevice.connecting) {
	                                            msg += ' is in connected state - but returning empty list of services. Retry service discovery #' + this.retries + ' scheduled in ' + _LegoDeviceManagerImpl2.default.getInstance().config.lookupServicesWhenConnectedRetryDelay + ' ms';
	                                        } else {
	                                            msg += ' is not yet in connected condition [paired: ' + nativeDevice.paired + ', connectable: ' + nativeDevice.connectable + ', connected: ' + nativeDevice.connected + ', connecting: ' + nativeDevice.connecting + ', nativeDevice.isConnected: ' + (cachedNativeDevice !== null ? cachedNativeDevice.getBluetoothWrapper().isConnected() : 'null') + ']. Retry service discovery #' + this.retries;
	                                        }
	                                        _LDSDKLogger2.default.info(msg);
	                                    }
	
	                                    if (cachedNativeDevice && cachedNativeDevice !== null && cachedNativeDevice.getBluetoothWrapper() && cachedNativeDevice.getBluetoothWrapper() !== null && cachedNativeDevice.getBluetoothWrapper().isConnected() === true) {
	                                        this.retries++;
	                                        setTimeout((0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
	                                            return _regenerator2.default.wrap(function _callee$(_context) {
	                                                while (1) {
	                                                    switch (_context.prev = _context.next) {
	                                                        case 0:
	                                                            _context.next = 2;
	                                                            return _this2.lookupServicesWhenConnected(callback, errorCallback);
	
	                                                        case 2:
	                                                        case 'end':
	                                                            return _context.stop();
	                                                    }
	                                                }
	                                            }, _callee, _this2);
	                                        })), _LegoDeviceManagerImpl2.default.getInstance().config.lookupServicesWhenConnectedRetryDelay);
	                                    } else {
	                                        if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                            _LDSDKLogger2.default.isDebugEnabled('Device ' + this.legoBluetoothDevice.getName() + ' [' + this.legoBluetoothDevice.getAddress() + '] is no longer connected - aborting lookupServicesWhenConnected retries');
	                                        }
	                                    }
	                                }
	
	                            case 24:
	                            case 'end':
	                                return _context2.stop();
	                        }
	                    }
	                }, _callee2, this);
	            }));
	
	            function lookupServicesWhenConnected(_x, _x2) {
	                return _ref.apply(this, arguments);
	            }
	
	            return lookupServicesWhenConnected;
	        }()
	    }, {
	        key: 'onConnectionStateChange',
	        value: function () {
	            var _ref3 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5(error, newState) {
	                var _this3 = this;
	
	                var config, startTs, awaitOnServiceAdded;
	                return _regenerator2.default.wrap(function _callee5$(_context5) {
	                    while (1) {
	                        switch (_context5.prev = _context5.next) {
	                            case 0:
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info(this.constructor.name + '.onConnectionStateChange(' + error + ', ' + newState + ')');
	                                }
	                                _context5.next = 3;
	                                return (0, _get3.default)(BaseBluetoothGattCallback.prototype.__proto__ || (0, _getPrototypeOf2.default)(BaseBluetoothGattCallback.prototype), 'onConnectionStateChange', this).call(this, error, newState);
	
	                            case 3:
	                                if (!error) {
	                                    _context5.next = 7;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info('onConnectionStateChange, not success');
	                                }
	                                this.bailOut('Unable to connect. Failed with status: ' + error.message, error);
	                                return _context5.abrupt('return');
	
	                            case 7:
	                                if (!(newState === _LegoDeviceImpl.StateEnum.Interrogating)) {
	                                    _context5.next = 38;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug(this.constructor.name + '.onConnectionStateChange - in if (newState' + ' === Interrogating) section.' + ' State value: ' + newState + ' - calling deviceDidConnect');
	                                }
	
	                                this.connected = true;
	                                _context5.next = 12;
	                                return this.deviceManagerImpl.deviceDidConnect(this.legoBluetoothDevice);
	
	                            case 12:
	                                // fires Interrogating callback
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('onConnectionStateChange - DeviceDidConnect - waiting for onServiceAdded to be called for ' + this.legoBluetoothDevice.getName() + ' [' + this.legoBluetoothDevice.getAddress() + ']');
	                                }
	
	                                config = _LegoDeviceManagerImpl2.default.getInstance().config;
	                                // At this point we must wait for onServiceAdded to be called 5 times - there is no onServicesAdded :)
	                                // Once all the services have been discovered we need to invoke await this.onServicesDiscovered(null, services);
	
	                                startTs = new Date().getTime();
	
	                                awaitOnServiceAdded = function () {
	                                    var _ref4 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
	                                        return _regenerator2.default.wrap(function _callee4$(_context4) {
	                                            while (1) {
	                                                switch (_context4.prev = _context4.next) {
	                                                    case 0:
	
	                                                        setTimeout((0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3() {
	                                                            return _regenerator2.default.wrap(function _callee3$(_context3) {
	                                                                while (1) {
	                                                                    switch (_context3.prev = _context3.next) {
	                                                                        case 0:
	                                                                            if (!(_this3.legoBluetoothDevice.deviceNativeServices.size < config.serviceCountComplete)) {
	                                                                                _context3.next = 10;
	                                                                                break;
	                                                                            }
	
	                                                                            if (!(new Date().getTime() - startTs < config.waitForAddServicesBeforePollingMillis)) {
	                                                                                _context3.next = 7;
	                                                                                break;
	                                                                            }
	
	                                                                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                                                                _LDSDKLogger2.default.debug('Waiting ' + config.lookupServicesWhenConnectedRetryDelay + 'ms before checking if deviceNativeServices >= ' + config.serviceCountComplete + ' again');
	                                                                            }
	                                                                            _context3.next = 5;
	                                                                            return awaitOnServiceAdded();
	
	                                                                        case 5:
	                                                                            _context3.next = 8;
	                                                                            break;
	
	                                                                        case 7:
	                                                                            if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                                                                _LDSDKLogger2.default.warn('Did not get ' + config.serviceCountComplete + ' services from onServiceAdded callbacks before ' + config.waitForAddServicesBeforePollingMillis + 'ms timeout (deviceServices: ' + _this3.legoBluetoothDevice.deviceNativeServices.size + ')');
	                                                                            }
	
	                                                                        case 8:
	                                                                            _context3.next = 11;
	                                                                            break;
	
	                                                                        case 10:
	                                                                            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                                                                _LDSDKLogger2.default.info('onConnectionStateChange - DeviceDidConnect - got ' + _this3.legoBluetoothDevice.deviceNativeServices.size + ' services for ' + _this3.legoBluetoothDevice.getName() + ' [' + _this3.legoBluetoothDevice.getAddress() + ']');
	                                                                            }
	
	                                                                        case 11:
	                                                                        case 'end':
	                                                                            return _context3.stop();
	                                                                    }
	                                                                }
	                                                            }, _callee3, _this3);
	                                                        })), config.lookupServicesWhenConnectedRetryDelay);
	
	                                                    case 1:
	                                                    case 'end':
	                                                        return _context4.stop();
	                                                }
	                                            }
	                                        }, _callee4, _this3);
	                                    }));
	
	                                    return function awaitOnServiceAdded() {
	                                        return _ref4.apply(this, arguments);
	                                    };
	                                }();
	
	                                _context5.prev = 16;
	
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info('Waiting up to ' + config.waitForAddServicesBeforePollingMillis + 'ms for onServiceAdded to be called ' + config.serviceCountComplete + ' times');
	                                }
	                                _context5.next = 20;
	                                return awaitOnServiceAdded();
	
	                            case 20:
	                                _context5.next = 25;
	                                break;
	
	                            case 22:
	                                _context5.prev = 22;
	                                _context5.t0 = _context5['catch'](16);
	
	                                if (_LDSDKLogger2.default.isErrorEnabled()) {
	                                    _LDSDKLogger2.default.error(_context5.t0);
	                                }
	
	                            case 25:
	                                ;
	
	                                if (!(this.legoBluetoothDevice.deviceNativeServices.size < config.serviceCountComplete)) {
	                                    _context5.next = 36;
	                                    break;
	                                }
	
	                                _context5.prev = 27;
	
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info('DeviceNativeServices is still empty, onServiceAdded not called within ' + config.waitForAddServicesBeforePollingMillis + 'ms of the connection. Polling getServices up to ' + config.lookupServicesWhenConnectedRetryMaxCount() + ' times ');
	                                }
	                                _context5.next = 31;
	                                return this.pollGetServices();
	
	                            case 31:
	                                _context5.next = 36;
	                                break;
	
	                            case 33:
	                                _context5.prev = 33;
	                                _context5.t1 = _context5['catch'](27);
	
	                                if (_LDSDKLogger2.default.isErrorEnabled()) {
	                                    _LDSDKLogger2.default.error(_context5.t1);
	                                }
	
	                            case 36:
	                                _context5.next = 39;
	                                break;
	
	                            case 38:
	                                if (newState !== _LegoDeviceImpl.StateEnum.InterrogationFinished) {
	                                    if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                        _LDSDKLogger2.default.info('newState !== StateEnum.InterrogationFinished', newState, _LegoDeviceImpl.StateEnum.InterrogationFinished);
	                                    }
	                                    if (newState === _LegoDeviceImpl.StateEnum.Connecting || newState === _LegoDeviceImpl.StateEnum.DisconnectedAdvertising) {
	                                        if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                            _LDSDKLogger2.default.info('onConnectionStateChange, ignoring transient state, newState is ' + newState, ' Looking up services');
	                                        }
	                                    } else {
	                                        if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                            _LDSDKLogger2.default.info('onConnectionStateChange, not connected, newState is ' + newState);
	                                        }
	                                        this.bailOut('Disconnected from device', error);
	                                    }
	                                    if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                        _LDSDKLogger2.default.info('onConnectionStateChange, returning :: NewState is ' + newState);
	                                    }
	                                }
	
	                            case 39:
	                            case 'end':
	                                return _context5.stop();
	                        }
	                    }
	                }, _callee5, this, [[16, 22], [27, 33]]);
	            }));
	
	            function onConnectionStateChange(_x3, _x4) {
	                return _ref3.apply(this, arguments);
	            }
	
	            return onConnectionStateChange;
	        }()
	    }, {
	        key: 'pollGetServices',
	        value: function pollGetServices() {
	            var _this4 = this;
	
	            if (this.hasOwnProperty('retries')) return new _promise2.default(function (resolve, reject) {
	                var config = _LegoDeviceManagerImpl2.default.getInstance().config;
	                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                    _LDSDKLogger2.default.info('pollGetServices called for ' + _StringUtils2.default.getDeviceString(_this4.legoBluetoothDevice));
	                }
	                _this4.legoBluetoothDevice.getBluetoothWrapper().discoverServices().then(function (services) {
	                    if (_LDSDKLogger2.default.isInfoEnabled()) {
	                        _LDSDKLogger2.default.info('pollGetServices got ' + services.length + ' services');
	                    }
	                    for (var idx = 0; idx < services.length; idx++) {
	                        var service = services[idx];
	                        if (!_this4.legoBluetoothDevice.deviceNativeServices.has(_UuidHelper2.default.getUuid(service))) {
	                            _this4.legoBluetoothDevice.deviceNativeServices.set(_UuidHelper2.default.getUuid(service), service);
	                        }
	                    }
	                    return resolve(services);
	                }).then(function (services) {
	                    if (_this4.legoBluetoothDevice.deviceNativeServices.size < config.serviceCountComplete) {
	                        if (_this4.pollGetServicesRetry < config.lookupServicesWhenConnectedRetryMaxCount) {
	                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                _LDSDKLogger2.default.debug('pollGetServices got 0 services and retry ' + _this4.pollGetServicesRetry + ' < ' + config.lookupServicesWhenConnectedRetryMaxCount + ' - scheduling retry');
	                            }
	                            _this4.pollGetServicesRetry++;
	                            setTimeout(function () {
	                                return _this4.pollGetServices();
	                            }, config.lookupServicesWhenConnectedRetryDelay);
	                        } else {
	                            if (_LDSDKLogger2.default.isErrorEnabled()) {
	                                _LDSDKLogger2.default.error('pollGetServices got 0 services in ' + _this4.pollGetServicesRetry + ' retries - It is not possible to use this hub in the current state - aborting hub connection');
	                            }
	                            _this4.cancelDeviceConnection(_this4.legoBluetoothDevice.getAddress());
	
	                            var error = _LDSDKError2.default.deviceError(_LDSDKError.ErrorCode.BLUETOOTH_CONNECTION_TIMEOUT, 'Connect request timed out');
	                            _this4.callbackHelper.performDidFailToConnectToDeviceCallback(_this4.legoBluetoothDevice, false, error);
	                            _this4.bailOut('Discovering services failed with error: ' + error.message, error);
	                            return reject('Discovering services failed with error: ' + error.message);
	                        }
	                    } else {
	                        if (_LDSDKLogger2.default.isInfoEnabled()) {
	                            _LDSDKLogger2.default.info('pollGetServices got ' + _this4.legoBluetoothDevice.deviceNativeServices.size + ' services');
	                        }
	                        var discoveredServices = [];
	                        _this4.legoBluetoothDevice.deviceNativeServices.forEach(function (value, key, map) {
	                            discoveredServices.push(value);
	                        });
	                        return _this4.onServicesDiscovered(null, discoveredServices);
	                    }
	                }).catch(function (err) {
	                    // Failed discovery
	                    return resolve([]);
	                });
	            });
	        }
	
	        /**
	         * @param {string} error If error is set the service discovery failed
	         * @param {Array<NativeService>} services
	         *
	         * @return {Promise} Resolves once all the LegoBluetoothDevice#discoverCharacteristicsForService finishes.
	         */
	
	    }, {
	        key: 'onServicesDiscovered',
	        value: function () {
	            var _ref6 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6(error, services) {
	                return _regenerator2.default.wrap(function _callee6$(_context6) {
	                    while (1) {
	                        switch (_context6.prev = _context6.next) {
	                            case 0:
	                                _context6.next = 2;
	                                return (0, _get3.default)(BaseBluetoothGattCallback.prototype.__proto__ || (0, _getPrototypeOf2.default)(BaseBluetoothGattCallback.prototype), 'onServicesDiscovered', this).call(this, error, services);
	
	                            case 2:
	                                if (!error) {
	                                    _context6.next = 6;
	                                    break;
	                                }
	
	                                this.bailOut('Fetching services failed: ', error);
	                                _context6.next = 10;
	                                break;
	
	                            case 6:
	                                if (_LDSDKLogger2.default.isDebugEnabled) {
	                                    _LDSDKLogger2.default.debug(this.constructor.name + ' - Services discovered, calling deviceInterrogationFinished' + ' for device', this.legoBluetoothDevice.getName());
	                                }
	                                _context6.next = 9;
	                                return this.deviceManagerImpl.deviceInterrogationFinished(this.legoBluetoothDevice);
	
	                            case 9:
	                                if (_LDSDKLogger2.default.isDebugEnabled) {
	                                    _LDSDKLogger2.default.debug(this.constructor.name + ' - : Completed deviceInterrogationFinished' + ' for device', this.legoBluetoothDevice.getName());
	                                }
	
	                            case 10:
	                            case 'end':
	                                return _context6.stop();
	                        }
	                    }
	                }, _callee6, this);
	            }));
	
	            function onServicesDiscovered(_x5, _x6) {
	                return _ref6.apply(this, arguments);
	            }
	
	            return onServicesDiscovered;
	        }()
	    }, {
	        key: 'bailOut',
	        value: function bailOut(message, error) {
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('bailOut(', message, ' - error: ', error);
	            }
	            if (this.connected) {
	                this.deviceManagerImpl.deviceDidDisconnect(this.legoBluetoothDevice, error);
	            } else {
	                this.deviceManagerImpl.deviceDidFailToConnect(this.legoBluetoothDevice, error);
	            }
	        }
	    }]);
	    return BaseBluetoothGattCallback;
	}(_BluetoothDeviceCallback2.default);
	
	BaseBluetoothGattCallback.MAX_RETRIES = 20;
	
	var DeviceConnectTimeoutCountDownTimer = function () {
	    function DeviceConnectTimeoutCountDownTimer(legoBluetoothDevice, legoBluetoothDeviceManagerImplRef, millisInFuture) {
	        var _this5 = this;
	
	        (0, _classCallCheck3.default)(this, DeviceConnectTimeoutCountDownTimer);
	        this.legoBluetoothDevice = null;
	        this.legoBluetoothDeviceManagerImplRef = null;
	        this.timerId = -1;
	
	        this.legoBluetoothDevice = legoBluetoothDevice;
	        this.legoBluetoothDeviceManagerImplRef = legoBluetoothDeviceManagerImplRef;
	
	        this.timerId = setTimeout(function () {
	            _this5.onFinish();
	        }, millisInFuture);
	    }
	
	    (0, _createClass3.default)(DeviceConnectTimeoutCountDownTimer, [{
	        key: 'cancel',
	        value: function cancel() {
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('Invoking ' + this.constructor.name + '.cancel() - clearing connect timerId: ' + this.timerId + ' for ' + this.legoBluetoothDevice.getAddress());
	            }
	            clearTimeout(this.timerId);
	            this.timerId = -1;
	        }
	    }, {
	        key: 'onFinish',
	        value: function onFinish() {
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('Invoking ' + this.constructor.name + '.onFinish() - Connect timed out for ' + this.legoBluetoothDevice.getAddress() + ' - timerId: ' + this.timerId);
	            }
	            if (this.legoBluetoothDevice === null) {
	                _LDSDKLogger2.default.error('Received a connection time out but could not find device to cancel connect request for');
	                return;
	            }
	            if (_LDSDKLogger2.default.isWarnEnabled()) {
	                _LDSDKLogger2.default.warn('Connect request timed out for device: ' + this.legoBluetoothDevice.getName());
	            }
	            this.legoBluetoothDeviceManagerImplRef.removeConnectTimeoutTimerForDevice(this.legoBluetoothDevice);
	            this.legoBluetoothDeviceManagerImplRef.cancelDeviceConnection(this.legoBluetoothDevice.getAddress());
	
	            var error = _LDSDKError2.default.deviceError(_LDSDKError.ErrorCode.BLUETOOTH_CONNECTION_TIMEOUT, 'Connect request timed out');
	            this.legoBluetoothDeviceManagerImplRef.callbackHelper.performDidFailToConnectToDeviceCallback(this.legoBluetoothDevice, false, error);
	        }
	    }]);
	    return DeviceConnectTimeoutCountDownTimer;
	}();
	
	var DeviceCallbackListener = exports.DeviceCallbackListener = function () {
	    /**
	     *
	     * @param {LegoBluetoothDeviceManagerImpl} legoBluetoothDeviceManager
	     */
	    function DeviceCallbackListener(legoBluetoothDeviceManager) {
	        (0, _classCallCheck3.default)(this, DeviceCallbackListener);
	
	        this.legoBluetoothDeviceManager = legoBluetoothDeviceManager;
	    }
	
	    /**
	     *
	     * @param {string} deviceAddress - The mac address of the device
	     */
	
	
	    (0, _createClass3.default)(DeviceCallbackListener, [{
	        key: 'onDevice',
	        value: function () {
	            var _ref7 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7(deviceAddress) {
	                var nativeDevice, wrappedDevice, newDevice, legoBluetoothDevice, oldName, newName, connectCallback;
	                return _regenerator2.default.wrap(function _callee7$(_context7) {
	                    while (1) {
	                        switch (_context7.prev = _context7.next) {
	                            case 0:
	                                _context7.next = 2;
	                                return this.legoBluetoothDeviceManager.bluetoothAdapter.getDevice(deviceAddress);
	
	                            case 2:
	                                nativeDevice = _context7.sent;
	                                wrappedDevice = this.legoBluetoothDeviceManager.bluetoothAdapter.getWrappedDevice(nativeDevice);
	
	                                if (!wrappedDevice.isLegoDevice()) {
	                                    _context7.next = 64;
	                                    break;
	                                }
	
	                                newDevice = !this.legoBluetoothDeviceManager.devices.has(deviceAddress);
	                                legoBluetoothDevice = _LegoBluetoothDeviceImpl2.default.deviceWithWrapper(wrappedDevice, wrappedDevice.getRssi(), _LegoDeviceManagerImpl2.default.getInstance());
	
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('onDevice (performDeviceDidAppearCallback): ', legoBluetoothDevice, 'newDevice', newDevice);
	                                }
	                                legoBluetoothDevice.setAdvertising(true);
	                                _context7.next = 11;
	                                return this.legoBluetoothDeviceManager.callbackHelper.performDeviceDidAppearCallback(legoBluetoothDevice);
	
	                            case 11:
	                                if (!(legoBluetoothDevice.advertising === false)) {
	                                    _context7.next = 18;
	                                    break;
	                                }
	
	                                // if (newDevice) {
	                                // await legoBluetoothDevice.updateAdvertising();
	                                legoBluetoothDevice.setAdvertising(true);
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info('onDevice (new device) - Setting device in devices map. Key: [' + legoBluetoothDevice.getDeviceId() + '] => ' + legoBluetoothDevice.toString());
	                                }
	                                _context7.next = 16;
	                                return this.legoBluetoothDeviceManager.callbackHelper.performDeviceDidAppearCallback(legoBluetoothDevice);
	
	                            case 16:
	                                _context7.next = 51;
	                                break;
	
	                            case 18:
	                                if (!(wrappedDevice.getName() !== legoBluetoothDevice.getName())) {
	                                    _context7.next = 25;
	                                    break;
	                                }
	
	                                oldName = legoBluetoothDevice.getName();
	                                newName = wrappedDevice.getName();
	
	                                legoBluetoothDevice.deviceName = wrappedDevice.getName();
	                                this.legoBluetoothDeviceManager.setDevice(legoBluetoothDevice);
	
	                                _context7.next = 25;
	                                return legoBluetoothDevice.callbackHelper.performDidChangeNameCallback(this, oldName, newName);
	
	                            case 25:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('onDevice - State: ' + legoBluetoothDevice.getConnectState() + ' - ' + wrappedDevice.getName() + ' [' + wrappedDevice.getAddress() + '] - pairing: ' + wrappedDevice.isPairing() + ', paired: ' + wrappedDevice.getPaired() + ', connecting: ' + wrappedDevice.getConnecting() + ', connected: ' + wrappedDevice.getConnected());
	                                }
	
	                                _context7.t0 = legoBluetoothDevice.getConnectState();
	                                _context7.next = _context7.t0 === _LegoDeviceImpl.StateEnum.InterrogationFinished ? 29 : _context7.t0 === _LegoDeviceImpl.StateEnum.Interrogating ? 34 : _context7.t0 === _LegoDeviceImpl.StateEnum.DisconnectedAdvertising ? 38 : _context7.t0 === _LegoDeviceImpl.StateEnum.Connecting ? 41 : _context7.t0 === _LegoDeviceImpl.StateEnum.DisconnectedNotAdvertising ? 43 : 46;
	                                break;
	
	                            case 29:
	                                if (wrappedDevice.getConnected()) {
	                                    _context7.next = 33;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('State=InterrogationFinished but connected flag=false => disconnecting. NativeDevice (adapter): ', nativeDevice);
	                                }
	                                _context7.next = 33;
	                                return this.legoBluetoothDeviceManager.deviceDidDisconnect(legoBluetoothDevice);
	
	                            case 33:
	                                return _context7.abrupt('break', 47);
	
	                            case 34:
	                                if (!(!wrappedDevice.isPairing() && !wrappedDevice.getConnecting() && !wrappedDevice.getConnected())) {
	                                    _context7.next = 37;
	                                    break;
	                                }
	
	                                _context7.next = 37;
	                                return this.legoBluetoothDeviceManager.deviceDidFailToConnect(legoBluetoothDevice);
	
	                            case 37:
	                                return _context7.abrupt('break', 47);
	
	                            case 38:
	                                // onDeviceChanged events when discovering that has an rssi of -1 seem to be irrelevant
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('State=DisconnectedAdvertising - NativeDevice: ', wrappedDevice.toString());
	                                }
	                                if (!nativeDevice.connecting && !nativeDevice.connected && (!nativeDevice.hasOwnProperty('inquiryRssi') || nativeDevice.inquiryRssi === -1)) {
	                                    // shouldUpdateLastSeenTime = false;
	                                    // legoBluetoothDevice.updateConnectionStateUponConnectionStateChange(null,
	                                    // StateEnum.DisconnectedNotAdvertising);
	                                    // Removing the above lines fixes Advertising /NotAdvertising
	                                } else if (nativeDevice.pairing === false && nativeDevice.connecting === false && nativeDevice.connected === true) {
	                                    // Paired and connected without WeDo setting it to connecting state - restarting connect
	                                    _LegoDeviceManagerImpl2.default.getInstance().connectToDevice(deviceAddress);
	                                }
	                                return _context7.abrupt('break', 47);
	
	                            case 41:
	                                if (!wrappedDevice.isPairing() /* && wrappedDevice.getPaired() */ && !wrappedDevice.getConnecting() && wrappedDevice.getConnected()) {
	                                    if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                        _LDSDKLogger2.default.info('onDevice - State: Connecting - Already paired device. Changing' + ' state to Interrogating.', wrappedDevice.toString());
	                                    }
	                                    connectCallback = wrappedDevice.getConnectCallback();
	
	                                    if (connectCallback && connectCallback !== null) {
	                                        connectCallback.onConnectionStateChange(null, _LegoDeviceImpl.StateEnum.Interrogating);
	                                    }
	                                } else if (wrappedDevice.isPairing() && wrappedDevice.getPaired()) {
	                                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                        _LDSDKLogger2.default.debug('onDevice isPairing=true', wrappedDevice.toString());
	                                    }
	                                    // await this.legoBluetoothDeviceManager.reconnectToDevice(legoBluetoothDevice);
	                                } else if (!wrappedDevice.isPairing() /* && wrappedDevice.getPaired() */ && !wrappedDevice.getConnected() && !wrappedDevice.getConnecting()) {
	                                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                        _LDSDKLogger2.default.debug('In Connecting state - but neither pairing, connecting nor' + ' connected fields are true.' + ' Transient state while internal chromeos state changes BT connect state for the device', wrappedDevice.toString());
	                                    }
	                                    // await this.legoBluetoothDeviceManager.reconnectToDevice(legoBluetoothDevice);
	                                } else {
	                                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                        _LDSDKLogger2.default.debug('In Connecting state - in else - dumping wrapped', wrappedDevice.toString());
	                                    }
	                                }
	                                return _context7.abrupt('break', 47);
	
	                            case 43:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('State=DisconnectedNotAdvertising - NativeDevice (adapter): ', nativeDevice);
	                                }
	                                if (!nativeDevice.connecting && !nativeDevice.connected && nativeDevice.hasOwnProperty('inquiryRssi') && nativeDevice.inquiryRssi !== -1) {
	                                    // shouldUpdateLastSeenTime = false;
	                                    legoBluetoothDevice.setAdvertising(true);
	                                    legoBluetoothDevice.updateConnectionStateUponAdvertisingChange();
	                                    // legoBluetoothDevice.updateConnectionStateUponConnectionStateChange(null, StateEnum.DisconnectedNotAdvertising);
	                                } else if (nativeDevice.paired === true && nativeDevice.connecting === false && nativeDevice.connected === true) {
	                                    // Paired and connected without WeDo setting it to connecting state - restarting connect
	                                    _LegoDeviceManagerImpl2.default.getInstance().connectToDevice(deviceAddress);
	                                }
	                                return _context7.abrupt('break', 47);
	
	                            case 46:
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info('onDevice (existing device): ' + wrappedDevice.getName() + ' [' + wrappedDevice.getAddress() + '] - ConnectState: ' + legoBluetoothDevice.getConnectState() + ' - WrappedDevice: ', wrappedDevice.getDevice());
	                                }
	
	                            case 47:
	                                _context7.next = 49;
	                                return legoBluetoothDevice.updateWithAdvertisementDataAndRSSI(wrappedDevice.getRssi());
	
	                            case 49:
	                                _context7.next = 51;
	                                return this.legoBluetoothDeviceManager.callbackHelper.performDeviceDidChangeCallback(legoBluetoothDevice);
	
	                            case 51:
	
	                                this.legoBluetoothDeviceManager.deviceIdentifierToLastSeenTimeStamp.set(wrappedDevice.getAddress(), new Date().getTime());
	
	                                if (!_LegoDeviceManagerImpl2.default.getInstance().config.shouldUpdateOnTheOnDeviceEvents()) {
	                                    _context7.next = 62;
	                                    break;
	                                }
	
	                                if (!(_LegoDeviceManagerImpl2.default.getInstance().getDevice(legoBluetoothDevice.getAddress()) !== null)) {
	                                    _context7.next = 59;
	                                    break;
	                                }
	
	                                // Still a 'managed' device - do the performUpdateDeviceInfo call
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('Calling legoBluetoothDevice.performUpdateDeviceInfo from onDevice - ' + wrappedDevice.getName() + ' [' + wrappedDevice.getAddress() + '] - connectState: ' + legoBluetoothDevice.getConnectState());
	                                }
	                                _context7.next = 57;
	                                return legoBluetoothDevice.performUpdateDeviceInfo();
	
	                            case 57:
	                                _context7.next = 62;
	                                break;
	
	                            case 59:
	                                // Device has been removed from the managed devices list - inform the registered listeners that the
	                                // device has disappeared
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('Calling LegoDeviceManagerImpl.getInstance().onDeviceDidDisappear from onDevice - ' + wrappedDevice.getName() + ' [' + wrappedDevice.getAddress() + '] - connectState: ' + legoBluetoothDevice.getConnectState());
	                                }
	                                _context7.next = 62;
	                                return _LegoDeviceManagerImpl2.default.getInstance().onDeviceDidDisappear(legoBluetoothDevice);
	
	                            case 62:
	                                _context7.next = 65;
	                                break;
	
	                            case 64:
	                                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                    _LDSDKLogger2.default.trace('Not a lego uuid. NativeDevice', nativeDevice, 'wrapperDevice', wrappedDevice);
	                                }
	
	                            case 65:
	                            case 'end':
	                                return _context7.stop();
	                        }
	                    }
	                }, _callee7, this);
	            }));
	
	            function onDevice(_x7) {
	                return _ref7.apply(this, arguments);
	            }
	
	            return onDevice;
	        }()
	
	        /**
	         *
	         * @param {ChromeOsBluetoothDeviceWrapper} wrappedDevice
	         */
	
	    }, {
	        key: 'onDeviceAdded',
	        value: function () {
	            var _ref8 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee8(wrappedDevice) {
	                return _regenerator2.default.wrap(function _callee8$(_context8) {
	                    while (1) {
	                        switch (_context8.prev = _context8.next) {
	                            case 0:
	                                if (!wrappedDevice.isLegoDevice()) {
	                                    _context8.next = 9;
	                                    break;
	                                }
	
	                                if (!(!wrappedDevice.getDevice().inquiryRssi || wrappedDevice.getDevice().inquiryRssi === -1)) {
	                                    _context8.next = 4;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('FRJ Device ' + wrappedDevice.getName() + ' (' + wrappedDevice.getAddress() + ') onDeviceAdded ignored since it does not have a proper inquiryRssi property', wrappedDevice.getDevice());
	                                }
	                                return _context8.abrupt('return');
	
	                            case 4:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('FRJ onDeviceAdded - Device ' + wrappedDevice.getName() + ' (' + wrappedDevice.getAddress() + ') added - RSSI: ' + wrappedDevice.getDevice().inquiryRssi);
	                                }
	                                _context8.next = 7;
	                                return this.onDevice(wrappedDevice.getAddress());
	
	                            case 7:
	                                _context8.next = 10;
	                                break;
	
	                            case 9:
	                                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                    _LDSDKLogger2.default.debug('FRJ onDeviceAdded for non-LEGO device \'' + wrappedDevice.getName() + '\'');
	                                }
	
	                            case 10:
	                            case 'end':
	                                return _context8.stop();
	                        }
	                    }
	                }, _callee8, this);
	            }));
	
	            function onDeviceAdded(_x8) {
	                return _ref8.apply(this, arguments);
	            }
	
	            return onDeviceAdded;
	        }()
	
	        /**
	         *
	         * @param {ChromeOsBluetoothDeviceWrapper} wrappedDevice
	         */
	
	    }, {
	        key: 'onDeviceChanged',
	        value: function () {
	            var _ref9 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee9(wrappedDevice) {
	                return _regenerator2.default.wrap(function _callee9$(_context9) {
	                    while (1) {
	                        switch (_context9.prev = _context9.next) {
	                            case 0:
	                                if (!wrappedDevice.isLegoDevice()) {
	                                    _context9.next = 6;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('FRJ onDeviceChanged - Device ' + wrappedDevice.getName() + ' (' + wrappedDevice.getAddress() + ') changed - RSSI: ' + wrappedDevice.getDevice().inquiryRssi);
	                                }
	                                _context9.next = 4;
	                                return this.onDevice(wrappedDevice.getAddress());
	
	                            case 4:
	                                _context9.next = 7;
	                                break;
	
	                            case 6:
	                                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                    _LDSDKLogger2.default.debug('FRJ onDeviceChanged for non-LEGO device \'' + wrappedDevice.getName() + '\'');
	                                }
	
	                            case 7:
	                            case 'end':
	                                return _context9.stop();
	                        }
	                    }
	                }, _callee9, this);
	            }));
	
	            function onDeviceChanged(_x9) {
	                return _ref9.apply(this, arguments);
	            }
	
	            return onDeviceChanged;
	        }()
	
	        /**
	         *
	         * @param {ChromeOsBluetoothDeviceWrapper} wrappedDevice
	         */
	
	    }, {
	        key: 'onDeviceRemoved',
	        value: function () {
	            var _ref10 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee10(wrappedDevice) {
	                var nativeDevice, updatedWrappedDevice, legoBluetoothDevice;
	                return _regenerator2.default.wrap(function _callee10$(_context10) {
	                    while (1) {
	                        switch (_context10.prev = _context10.next) {
	                            case 0:
	                                if (!wrappedDevice.isLegoDevice()) {
	                                    _context10.next = 10;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('FRJ onDeviceRemoved - Device ' + wrappedDevice.getName() + ' (' + wrappedDevice.getAddress() + ') removed');
	                                }
	                                _context10.next = 4;
	                                return this.legoBluetoothDeviceManager.bluetoothAdapter.getDevice(wrappedDevice.getAddress());
	
	                            case 4:
	                                nativeDevice = _context10.sent;
	                                _context10.next = 7;
	                                return this.legoBluetoothDeviceManager.bluetoothAdapter.getWrappedDevice(nativeDevice);
	
	                            case 7:
	                                updatedWrappedDevice = _context10.sent;
	                                legoBluetoothDevice = _LegoBluetoothDeviceImpl2.default.deviceWithWrapper(updatedWrappedDevice, updatedWrappedDevice.getRssi(), _LegoDeviceManagerImpl2.default.getInstance());
	
	                                _LegoDeviceManagerImpl2.default.getInstance().onDeviceDidDisappear(legoBluetoothDevice);
	
	                            case 10:
	                            case 'end':
	                                return _context10.stop();
	                        }
	                    }
	                }, _callee10, this);
	            }));
	
	            function onDeviceRemoved(_x10) {
	                return _ref10.apply(this, arguments);
	            }
	
	            return onDeviceRemoved;
	        }()
	    }]);
	    return DeviceCallbackListener;
	}();
	
	var LegoBluetoothDeviceManagerImpl = function () {
	    (0, _createClass3.default)(LegoBluetoothDeviceManagerImpl, null, [{
	        key: 'rssiComparatorDescending',
	        // [ms]
	        value: function rssiComparatorDescending(lhs, rhs) {
	            var lhsRSSI = lhs.getRSSIValue();
	            var rhsRSSI = rhs.getRSSIValue();
	
	            if (lhsRSSI === rhsRSSI) {
	                return 0;
	            } else if (lhsRSSI < rhsRSSI) {
	                return 1;
	            } else {
	                return -1;
	            }
	        } // list of LegoBluetoothDevice
	        // [ms]
	
	        // [ms]
	
	    }]);
	
	    /**
	     *
	     * @param {ChromeOsBluetoothAdapterWrapper} bluetoothAdapterWrapper
	     */
	    function LegoBluetoothDeviceManagerImpl(bluetoothAdapterWrapper) {
	        (0, _classCallCheck3.default)(this, LegoBluetoothDeviceManagerImpl);
	        this.bluetoothAdapter = null;
	        this._devices = new _map2.default();
	        this.deviceIdentifierToLastSeenTimeStamp = new _map2.default();
	        this.deviceToConnectTimerDic = new _map2.default();
	        this.deviceToReconnectCount = new _map2.default();
	        this.primaryServiceUUIds = new _SimpleList2.default();
	        this.callbackHelper = new BluetoothDeviceManagerCallbackHelper();
	        this.stopScanningTimeoutHandle = null;
	        this.startScanningTimeoutHandle = null;
	
	        if (_LDSDKLogger2.default.isInfoEnabled()) {
	            _LDSDKLogger2.default.info('Constructing ', this.constructor.name, 'for device "' + bluetoothAdapterWrapper.getName() + '"');
	        }
	
	        // Add primary service UUIDs
	        this.primaryServiceUUIds.add(_BluetoothServiceDefinition2.default.ioServiceDefinition().getServiceUUID());
	        this.primaryServiceUUIds.add(_BluetoothServiceDefinition2.default.deviceServiceDefinition().getServiceUUID());
	        this.primaryServiceUUIds.add(_BluetoothServiceDefinition2.default.batteryServiceDefinition().getServiceUUID());
	        this.primaryServiceUUIds.add(_BluetoothServiceDefinition2.default.deviceInfoServiceDefinition().getServiceUUID());
	
	        this.bluetoothAdapter = bluetoothAdapterWrapper;
	
	        this.bluetoothAdapter.connectCallbackListener(new DeviceCallbackListener(this));
	    }
	
	    /**
	     * @ignore - Internal map, should not be accessed directly by client code
	     * This is a map of all known LegoBluetoothDeviceImpl instances - key in the map is the MAC address.
	     * @return {Map<string, LegoBluetoothDeviceImpl>}
	     */
	
	
	    (0, _createClass3.default)(LegoBluetoothDeviceManagerImpl, [{
	        key: 'setDevice',
	
	
	        /**
	         * @ignore - Private
	         * Set the device in the internal map
	         * @param {LegoBluetoothDeviceImpl} device
	         */
	        value: function setDevice(device) {
	            var appeared = !this.devices.has(device.getAddress());
	            this.devices.set(device.getAddress(), device);
	
	            if (appeared) {
	                this.callbackHelper.performDeviceDidAppearCallback(device);
	            }
	        }
	
	        /**
	         *
	         * @param {string} newDeviceAddress
	         * @return {LegoBluetoothDeviceImpl} - Returns null if not found
	         */
	
	    }, {
	        key: 'getLegoBluetoothDeviceWithAddress',
	        value: function getLegoBluetoothDeviceWithAddress(newDeviceAddress) {
	            if (this.devices.has(newDeviceAddress)) {
	                var device = this.devices.get(newDeviceAddress);
	                if (device) {
	                    /*
	                                    if (LDSDKLogger.isTraceEnabled()) {
	                                        LDSDKLogger.debug('Found cached device', device.getName());
	                                    }
	                    */
	                    return device;
	                }
	            }
	            return null;
	        }
	    }, {
	        key: 'cleanUpListOfDiscoveredDevices',
	        value: function cleanUpListOfDiscoveredDevices() {
	            var _this6 = this;
	
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('cleanUpListOfDiscoveredDevices running');
	            }
	            var devicesToRemove = new _SimpleList2.default();
	            var updateAdvertisingDevicesIntervalMillis = _LegoDeviceManagerImpl2.default.getInstance().config.updateAdvertisingDevicesIntervalMillis;
	            this.devices.forEach(function (device, deviceId) {
	                if (device !== null) {
	                    if (_this6.deviceIdentifierToLastSeenTimeStamp.has(deviceId)) {
	                        var lastSeenDateInMillis = _this6.deviceIdentifierToLastSeenTimeStamp.get(deviceId);
	                        var lastAdvertisingPackageTooOld = new Date().getTime() - lastSeenDateInMillis > updateAdvertisingDevicesIntervalMillis;
	                        if (lastAdvertisingPackageTooOld) {
	                            device.setAdvertising(false);
	                        }
	                        if ((device.getConnectState() === _LegoDeviceImpl.StateEnum.DisconnectedNotAdvertising || device.getConnectState() === _LegoDeviceImpl.StateEnum.DisconnectedAdvertising) && lastAdvertisingPackageTooOld) {
	                            _this6.deviceIdentifierToLastSeenTimeStamp.delete(deviceId);
	                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                _LDSDKLogger2.default.debug('cleanUpListOfDiscoveredDevices Filtering out ' + device.getName() + ' [' + deviceId + ']');
	                            }
	                            devicesToRemove.add(device);
	                        }
	                    }
	                }
	            });
	
	            for (var i = 0; i < devicesToRemove.length(); i++) {
	                var device = devicesToRemove.get(i);
	                if (!device || device === null) {
	                    continue;
	                } else {
	                    this.devices.delete(device.getDeviceId());
	                    if (_LDSDKLogger2.default.isDebugEnabled()) {
	                        _LDSDKLogger2.default.debug(this.constructor.name + '.cleanUpListOfDiscoveredDevices :: Deleting device from' + ' devices with key: [' + device.getDeviceId() + ']. Devices size: ' + this.devices.size);
	                    }
	                    this.callbackHelper.performDeviceDidDisappearCallback(device);
	                }
	            }
	
	            // Schedule a new cleanup
	            if (this.cleanUpListOfDiscoveredDevicesTimeoutId) {
	                clearTimeout(this.cleanUpListOfDiscoveredDevicesTimeoutId);
	            }
	            this.cleanUpListOfDiscoveredDevicesTimeoutId = setTimeout(function () {
	                _this6.cleanUpListOfDiscoveredDevices();
	            }, _LegoDeviceManagerImpl2.default.getInstance().config.updateAdvertisingDevicesIntervalMillis);
	        }
	    }, {
	        key: 'scan',
	        value: function () {
	            var _ref11 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee11() {
	                var available, enabled;
	                return _regenerator2.default.wrap(function _callee11$(_context11) {
	                    while (1) {
	                        switch (_context11.prev = _context11.next) {
	                            case 0:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('Do scan...');
	                                }
	                                // Ensure that Bluetooth is available on the device and it is enabled
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info('Scan start time: ', new Date().getTime());
	                                }
	                                _context11.next = 4;
	                                return this.isBluetoothAvailable();
	
	                            case 4:
	                                available = _context11.sent;
	
	                                if (available) {
	                                    _context11.next = 8;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info('Scan isBluetoothAvailable time: ', new Date().getTime());
	                                }
	                                throw new Error('Bluetooth is not available on device');
	
	                            case 8:
	                                _context11.next = 10;
	                                return this.isBluetoothEnabled();
	
	                            case 10:
	                                enabled = _context11.sent;
	
	                                if (enabled) {
	                                    _context11.next = 13;
	                                    break;
	                                }
	
	                                throw new Error('Bluetooth is not enabled');
	
	                            case 13:
	                                if (!_LegoDeviceManagerImpl2.default.getInstance().config.shouldStartStopRepeatedScanning()) {
	                                    _context11.next = 19;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug(this.constructor.name + ' - wait for startRepeatingScanning');
	                                }
	                                _context11.next = 17;
	                                return this.startRepeatingScanning();
	
	                            case 17:
	                                _context11.next = 22;
	                                break;
	
	                            case 19:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug(this.constructor.name + ' - wait for startScan');
	                                }
	                                _context11.next = 22;
	                                return this.startScan();
	
	                            case 22:
	                                _context11.next = 24;
	                                return this.startRepeatingCleanUpListOfDiscoveredDevices();
	
	                            case 24:
	                            case 'end':
	                                return _context11.stop();
	                        }
	                    }
	                }, _callee11, this);
	            }));
	
	            function scan() {
	                return _ref11.apply(this, arguments);
	            }
	
	            return scan;
	        }()
	    }, {
	        key: 'stopScanning',
	        value: function () {
	            var _ref12 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee12() {
	                return _regenerator2.default.wrap(function _callee12$(_context12) {
	                    while (1) {
	                        switch (_context12.prev = _context12.next) {
	                            case 0:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('Stop scanning...');
	                                }
	                                this.stopRepeatingDeviceDisappearanceDiscovery();
	
	                                if (!_LegoDeviceManagerImpl2.default.getInstance().config.shouldStartStopRepeatedScanning()) {
	                                    _context12.next = 8;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug(this.constructor.name + ' - wait for stopRepeatingScanning');
	                                }
	                                _context12.next = 6;
	                                return this.stopRepeatingScanning();
	
	                            case 6:
	                                _context12.next = 11;
	                                break;
	
	                            case 8:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug(this.constructor.name + ' - wait for stopScan');
	                                }
	                                _context12.next = 11;
	                                return this.stopScan();
	
	                            case 11:
	                            case 'end':
	                                return _context12.stop();
	                        }
	                    }
	                }, _callee12, this);
	            }));
	
	            function stopScanning() {
	                return _ref12.apply(this, arguments);
	            }
	
	            return stopScanning;
	        }()
	
	        /**
	         *
	         * @param {LegoBluetoothDeviceImpl} legoBluetoothDevice
	         */
	
	    }, {
	        key: 'connectToDevice',
	        value: function () {
	            var _ref13 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee13(legoBluetoothDevice) {
	                var cachedDevice;
	                return _regenerator2.default.wrap(function _callee13$(_context13) {
	                    while (1) {
	                        switch (_context13.prev = _context13.next) {
	                            case 0:
	                                cachedDevice = this.getLegoBluetoothDeviceWithAddress(legoBluetoothDevice.getAddress());
	
	                                if (cachedDevice !== null && legoBluetoothDevice.instanceId !== cachedDevice.instanceId) {
	                                    legoBluetoothDevice = cachedDevice;
	                                }
	
	                                this.callbackHelper.performWillStartConnectingToDeviceCallback(legoBluetoothDevice);
	                                this.addConnectTimeoutTimerForDevice(legoBluetoothDevice, _LegoDeviceManagerImpl2.default.getInstance().config.connectRequestTimeoutInterval);
	
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info('Connecting to device: ', legoBluetoothDevice.getBluetoothDevice());
	                                }
	                                _context13.prev = 5;
	                                _context13.next = 8;
	                                return legoBluetoothDevice.connectGatt(true, new BaseBluetoothGattCallback(legoBluetoothDevice, this));
	
	                            case 8:
	                                _context13.next = 14;
	                                break;
	
	                            case 10:
	                                _context13.prev = 10;
	                                _context13.t0 = _context13['catch'](5);
	
	                                _LDSDKLogger2.default.error('connectToDevice - legoBluetoothDevice.connectGatt failed', _context13.t0);
	                                throw _context13.t0;
	
	                            case 14:
	                            case 'end':
	                                return _context13.stop();
	                        }
	                    }
	                }, _callee13, this, [[5, 10]]);
	            }));
	
	            function connectToDevice(_x11) {
	                return _ref13.apply(this, arguments);
	            }
	
	            return connectToDevice;
	        }()
	    }, {
	        key: 'deviceDidDisconnect',
	        value: function () {
	            var _ref14 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee14(legoBluetoothDevice) {
	                var status = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	                var userInitiated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	                var cachedDevice, errorMessage, error, shouldAttemptReconnect;
	                return _regenerator2.default.wrap(function _callee14$(_context14) {
	                    while (1) {
	                        switch (_context14.prev = _context14.next) {
	                            case 0:
	                                cachedDevice = this.getLegoBluetoothDeviceWithAddress(legoBluetoothDevice.getAddress());
	
	                                if (cachedDevice !== null && legoBluetoothDevice.instanceId !== cachedDevice.instanceId) {
	                                    legoBluetoothDevice = cachedDevice;
	                                }
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('Device disconnect: ' + legoBluetoothDevice);
	                                }
	                                _context14.next = 5;
	                                return legoBluetoothDevice.cleanUp();
	
	                            case 5:
	                                errorMessage = '';
	                                // LDSDKLogger.info('deviceDidDisconnect - status: ', status);
	
	                                if (status === undefined || status === 0) {
	                                    errorMessage = '';
	                                } else if (status === 8) {
	                                    // Connection lost e.g. due to out of range or Hub lid removed
	                                    errorMessage = 'Connection lost to device: ' + legoBluetoothDevice.getName();
	                                    _LDSDKLogger2.default.error(errorMessage);
	                                } else if (status === 19) {
	                                    // We do not want to treat this as an error
	                                    errorMessage = '';
	                                    // Happens e.g. when the user holds down the button on the device for a few seconds
	                                    _LDSDKLogger2.default.error('Connection closed from device: ' + legoBluetoothDevice.getName());
	                                } else {
	                                    errorMessage = 'Connection closed unexpectedly to device: ' + legoBluetoothDevice.getName();
	                                    if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                        _LDSDKLogger2.default.warn(errorMessage);
	                                    }
	                                }
	
	                                error = void 0;
	
	                                if (!(errorMessage === undefined || errorMessage === '')) {
	                                    error = _LDSDKError2.default.deviceError(_LDSDKError.ErrorCode.BLUETOOTH_CONNECTION_ERROR, errorMessage);
	                                } else {
	                                    error = null;
	                                }
	
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info('Device did disconnect with status ' + status);
	                                }
	
	                                shouldAttemptReconnect = this.shouldAllowReconnectToDevice(legoBluetoothDevice);
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('Device ' + legoBluetoothDevice.getName() + ' - shouldAttemptReconnect: ' + shouldAttemptReconnect);
	                                }
	                                if (shouldAttemptReconnect) {
	                                    legoBluetoothDevice.updateConnectionStateUponConnectionStateChange(null, _LegoDeviceImpl.StateEnum.DisconnectedAdvertising);
	                                }
	
	                                _context14.next = 15;
	                                return this.callbackHelper.performDidDisconnectFromDeviceCallback(legoBluetoothDevice, shouldAttemptReconnect, error);
	
	                            case 15:
	                                if (userInitiated) {
	                                    _context14.next = 18;
	                                    break;
	                                }
	
	                                _context14.next = 18;
	                                return this.performReconnect(legoBluetoothDevice, shouldAttemptReconnect);
	
	                            case 18:
	                            case 'end':
	                                return _context14.stop();
	                        }
	                    }
	                }, _callee14, this);
	            }));
	
	            function deviceDidDisconnect(_x12) {
	                return _ref14.apply(this, arguments);
	            }
	
	            return deviceDidDisconnect;
	        }()
	    }, {
	        key: 'deviceDidFailToConnect',
	        value: function () {
	            var _ref15 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee15(legoBluetoothDevice) {
	                var status = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	                var shouldAttemptReconnect;
	                return _regenerator2.default.wrap(function _callee15$(_context15) {
	                    while (1) {
	                        switch (_context15.prev = _context15.next) {
	                            case 0:
	
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info('Device did fail to connect with status ' + status);
	                                }
	
	                                _context15.next = 3;
	                                return legoBluetoothDevice.cleanUp();
	
	                            case 3:
	
	                                this.removeConnectTimeoutTimerForDevice(legoBluetoothDevice);
	
	                                shouldAttemptReconnect = this.shouldAllowReconnectToDevice(legoBluetoothDevice);
	
	                                if (shouldAttemptReconnect) {
	                                    legoBluetoothDevice.updateConnectionStateUponConnectionStateChange(null, _LegoDeviceImpl.StateEnum.DisconnectedAdvertising);
	                                }
	
	                                _context15.next = 8;
	                                return this.callbackHelper.performDidFailToConnectToDeviceCallback(legoBluetoothDevice, shouldAttemptReconnect, null);
	
	                            case 8:
	                                _context15.next = 10;
	                                return this.performReconnect(legoBluetoothDevice, shouldAttemptReconnect);
	
	                            case 10:
	                            case 'end':
	                                return _context15.stop();
	                        }
	                    }
	                }, _callee15, this);
	            }));
	
	            function deviceDidFailToConnect(_x15) {
	                return _ref15.apply(this, arguments);
	            }
	
	            return deviceDidFailToConnect;
	        }()
	    }, {
	        key: 'performReconnect',
	        value: function () {
	            var _ref16 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee16(legoBluetoothDevice, shouldAttemptReconnect) {
	                return _regenerator2.default.wrap(function _callee16$(_context16) {
	                    while (1) {
	                        switch (_context16.prev = _context16.next) {
	                            case 0:
	                                if (!shouldAttemptReconnect) {
	                                    _context16.next = 5;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('performReconnect -- shouldAttemptReconnect is true - calling reconnect: ' + legoBluetoothDevice.toString());
	                                }
	                                this.reconnectToDevice(legoBluetoothDevice);
	                                _context16.next = 10;
	                                break;
	
	                            case 5:
	                                this.resetReconnectCountForDevice(legoBluetoothDevice);
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('performReconnect -- shouldAttemptReconnect is false - disconnecting from: ' + legoBluetoothDevice.toString());
	                                }
	                                _context16.next = 9;
	                                return legoBluetoothDevice.disconnectGatt(this, false);
	
	                            case 9:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug(this.constructor.name + '.performReconnect :: Deleting device from devices with key:' + ' [' + legoBluetoothDevice.getDeviceId() + ']. Devices size: ' + this.devices.size);
	                                }
	
	                            case 10:
	                            case 'end':
	                                return _context16.stop();
	                        }
	                    }
	                }, _callee16, this);
	            }));
	
	            function performReconnect(_x17, _x18) {
	                return _ref16.apply(this, arguments);
	            }
	
	            return performReconnect;
	        }()
	    }, {
	        key: 'deviceDidConnect',
	        value: function () {
	            var _ref17 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee17(legoBluetoothDevice) {
	                return _regenerator2.default.wrap(function _callee17$(_context17) {
	                    while (1) {
	                        switch (_context17.prev = _context17.next) {
	                            case 0:
	                                _context17.next = 2;
	                                return this.callbackHelper.performDidStartInterrogatingDeviceCallback(legoBluetoothDevice);
	
	                            case 2:
	                                // LECQA-152: Remove the timeout timer already when connecting and give the chromebook more time to interrogate.
	                                this.removeConnectTimeoutTimerForDevice(legoBluetoothDevice);
	
	                            case 3:
	                            case 'end':
	                                return _context17.stop();
	                        }
	                    }
	                }, _callee17, this);
	            }));
	
	            function deviceDidConnect(_x19) {
	                return _ref17.apply(this, arguments);
	            }
	
	            return deviceDidConnect;
	        }()
	    }, {
	        key: 'deviceInterrogationFinished',
	        value: function () {
	            var _ref18 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee18(legoBluetoothDevice) {
	                return _regenerator2.default.wrap(function _callee18$(_context18) {
	                    while (1) {
	                        switch (_context18.prev = _context18.next) {
	                            case 0:
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info('deviceInterrogationFinished for device: ' + legoBluetoothDevice.getAddress());
	                                }
	                                _context18.next = 3;
	                                return this.removeConnectTimeoutTimerForDevice(legoBluetoothDevice);
	
	                            case 3:
	                                this.resetReconnectCountForDevice(legoBluetoothDevice);
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug(this.constructor.name + ' - Awaiting' + ' callbackHelper.performDidFinishInterrogatingDeviceCallback for' + ' legoBluetoothDevice', legoBluetoothDevice.getName());
	                                }
	                                _context18.next = 7;
	                                return this.callbackHelper.performDidFinishInterrogatingDeviceCallback(legoBluetoothDevice);
	
	                            case 7:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug(this.constructor.name + ' - Completed' + ' callbackHelper.performDidFinishInterrogatingDeviceCallback');
	                                }
	
	                            case 8:
	                            case 'end':
	                                return _context18.stop();
	                        }
	                    }
	                }, _callee18, this);
	            }));
	
	            function deviceInterrogationFinished(_x20) {
	                return _ref18.apply(this, arguments);
	            }
	
	            return deviceInterrogationFinished;
	        }()
	    }, {
	        key: 'addConnectTimeoutTimerForDevice',
	        value: function addConnectTimeoutTimerForDevice(legoBluetoothDevice, timeout) {
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('Creating connect timeout timer for ' + legoBluetoothDevice.getName() + ' [' + legoBluetoothDevice.getAddress() + ']');
	            }
	            var timer = new DeviceConnectTimeoutCountDownTimer(legoBluetoothDevice, this, timeout);
	            this.deviceToConnectTimerDic.set(legoBluetoothDevice.getAddress(), timer);
	        }
	    }, {
	        key: 'removeConnectTimeoutTimerForDevice',
	        value: function removeConnectTimeoutTimerForDevice(legoBluetoothDevice) {
	            if (!legoBluetoothDevice || legoBluetoothDevice === null) {
	                return;
	            }
	            var timer = this.deviceToConnectTimerDic.get(legoBluetoothDevice.getAddress());
	            if (timer !== null && timer !== undefined) {
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('Removing connect timeout timer for ' + legoBluetoothDevice.getName() + ' [' + legoBluetoothDevice.getAddress() + ']');
	                }
	                timer.cancel();
	            }
	            this.deviceToConnectTimerDic.delete(legoBluetoothDevice.getAddress());
	        }
	    }, {
	        key: 'registerCallbackListener',
	        value: function registerCallbackListener(listener) {
	            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                _LDSDKLogger2.default.info('Registering ' + this.callbackHelper.constructor.name + ' listener of type: ' + listener.constructor.name);
	            }
	            var callbackId = this.callbackHelper.registerCallbackListener(listener);
	            return callbackId;
	        }
	    }, {
	        key: 'unregisterCallbackListener',
	        value: function unregisterCallbackListener(listenerId) {
	            var result = this.callbackHelper.unregisterCallbackListener(listenerId);
	            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                _LDSDKLogger2.default.info('Unregistering ' + this.callbackHelper.constructor.name + ' listener with id: ' + listenerId);
	            }
	            return result;
	        }
	    }, {
	        key: 'getAdvertisingDevicesInterval',
	        value: function getAdvertisingDevicesInterval() {
	            return this.updateAdvertisingDevicesIntervalMillis;
	        }
	    }, {
	        key: 'updateAdvertisingDevicesInterval',
	        value: function updateAdvertisingDevicesInterval(interval) {
	            if (interval > LegoBluetoothDeviceManagerImpl.REFRESH_DEVICE_LIST_MINIMUM_INTERVAL) {
	                this.updateAdvertisingDevicesIntervalMillis = interval;
	            } else {
	                this.updateAdvertisingDevicesIntervalMillis = LegoBluetoothDeviceManagerImpl.REFRESH_DEVICE_LIST_MINIMUM_INTERVAL;
	            }
	        }
	
	        /**
	         *
	         * @param {string} legoDeviceAddress - The mac address of the hub to disconnect
	         */
	
	    }, {
	        key: 'cancelDeviceConnection',
	        value: function () {
	            var _ref19 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee19(legoDeviceAddress) {
	                var legoBluetoothDevice;
	                return _regenerator2.default.wrap(function _callee19$(_context19) {
	                    while (1) {
	                        switch (_context19.prev = _context19.next) {
	                            case 0:
	                                legoBluetoothDevice = this.devices.get(legoDeviceAddress);
	
	                                if (!(legoBluetoothDevice && legoBluetoothDevice !== null)) {
	                                    _context19.next = 6;
	                                    break;
	                                }
	
	                                this.devices.delete(legoDeviceAddress); // TODO: Do we need to delete it?
	                                _context19.next = 5;
	                                return legoBluetoothDevice.disconnectGatt(this, true);
	
	                            case 5:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug(this.constructor.name + '.cancelDeviceConnection :: Deleted device from devices with' + ' key: [' + legoDeviceAddress + ']. Devices size: ' + this.devices.size);
	                                }
	
	                            case 6:
	                            case 'end':
	                                return _context19.stop();
	                        }
	                    }
	                }, _callee19, this);
	            }));
	
	            function cancelDeviceConnection(_x21) {
	                return _ref19.apply(this, arguments);
	            }
	
	            return cancelDeviceConnection;
	        }()
	
	        /**
	         *
	         * @param {number} connectionState - @see {@link StateEnum}
	         * @return {SimpleList<LegoBluetoothDeviceImpl>}
	         */
	
	    }, {
	        key: 'devicesInState',
	        value: function devicesInState(connectionState) {
	            var devicesInStateList = new _SimpleList2.default();
	            this.devices.forEach(function (device, deviceId) {
	                if (device.getConnectState() === connectionState) {
	                    devicesInStateList.add(device);
	                }
	            });
	
	            if (devicesInStateList.size() > 0) {
	                if (connectionState === _LegoDeviceImpl.StateEnum.DisconnectedAdvertising || connectionState === _LegoDeviceImpl.StateEnum.Connecting) {
	                    devicesInStateList.sort(LegoBluetoothDeviceManagerImpl.rssiComparatorDescending);
	                }
	            }
	
	            return devicesInStateList;
	        }
	
	        /**
	         *
	         * @return {SimpleList<LegoBluetoothDeviceImpl>}
	         */
	
	    }, {
	        key: 'allDevices',
	        value: function allDevices() {
	            var allDevicesList = new _SimpleList2.default();
	            this.devices.forEach(function (device, deviceId) {
	                allDevicesList.add(device);
	            });
	            if (_LDSDKLogger2.default.isTraceEnabled()) {
	                _LDSDKLogger2.default.debug(this.constructor.name + '.allDevices called. Original list:', this.devices, ', Copy:', allDevicesList, ' Original list size: ' + this.devices.size + ', Copy list size: ' + allDevicesList.size());
	            }
	            allDevicesList.sort(LegoBluetoothDeviceManagerImpl.rssiComparatorDescending);
	
	            return allDevicesList;
	        }
	    }, {
	        key: 'isBluetoothEnabled',
	        value: function () {
	            var _ref20 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee20() {
	                return _regenerator2.default.wrap(function _callee20$(_context20) {
	                    while (1) {
	                        switch (_context20.prev = _context20.next) {
	                            case 0:
	                                _context20.next = 2;
	                                return this.bluetoothAdapter.isBluetoothAvailable();
	
	                            case 2:
	                                _context20.t0 = _context20.sent;
	
	                                if (!_context20.t0) {
	                                    _context20.next = 7;
	                                    break;
	                                }
	
	                                _context20.next = 6;
	                                return this.bluetoothAdapter.isBluetoothEnabledOnDevice();
	
	                            case 6:
	                                _context20.t0 = _context20.sent;
	
	                            case 7:
	                                return _context20.abrupt('return', _context20.t0);
	
	                            case 8:
	                            case 'end':
	                                return _context20.stop();
	                        }
	                    }
	                }, _callee20, this);
	            }));
	
	            function isBluetoothEnabled() {
	                return _ref20.apply(this, arguments);
	            }
	
	            return isBluetoothEnabled;
	        }()
	    }, {
	        key: 'isBluetoothAvailable',
	        value: function () {
	            var _ref21 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee21() {
	                return _regenerator2.default.wrap(function _callee21$(_context21) {
	                    while (1) {
	                        switch (_context21.prev = _context21.next) {
	                            case 0:
	                                _context21.next = 2;
	                                return this.bluetoothAdapter.isBluetoothAvailable();
	
	                            case 2:
	                                return _context21.abrupt('return', _context21.sent);
	
	                            case 3:
	                            case 'end':
	                                return _context21.stop();
	                        }
	                    }
	                }, _callee21, this);
	            }));
	
	            function isBluetoothAvailable() {
	                return _ref21.apply(this, arguments);
	            }
	
	            return isBluetoothAvailable;
	        }()
	    }, {
	        key: 'resetReconnectCountForDevice',
	        value: function resetReconnectCountForDevice(legoBluetoothDevice) {
	            this.deviceToReconnectCount.delete(legoBluetoothDevice.getDeviceId());
	        }
	    }, {
	        key: 'reconnectToDevice',
	        value: function () {
	            var _ref22 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee22(legoBluetoothDevice) {
	                var reconnectCount, reconnectAttempt;
	                return _regenerator2.default.wrap(function _callee22$(_context22) {
	                    while (1) {
	                        switch (_context22.prev = _context22.next) {
	                            case 0:
	                                this.removeConnectTimeoutTimerForDevice(legoBluetoothDevice);
	                                reconnectCount = 0;
	
	                                if (this.deviceToReconnectCount.has(legoBluetoothDevice.getAddress())) {
	                                    reconnectCount = this.deviceToReconnectCount.get(legoBluetoothDevice.getAddress());
	                                }
	                                reconnectAttempt = reconnectCount + 1;
	
	
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('Reconnecting to ' + legoBluetoothDevice.getName() + ' - reconnect attempt ' + reconnectAttempt);
	                                }
	                                this.deviceToReconnectCount.set(legoBluetoothDevice.getAddress(), reconnectAttempt);
	
	                                _context22.next = 8;
	                                return legoBluetoothDevice.disconnectGatt(this, false);
	
	                            case 8:
	                                _context22.next = 10;
	                                return this.connectToDevice(legoBluetoothDevice);
	
	                            case 10:
	                            case 'end':
	                                return _context22.stop();
	                        }
	                    }
	                }, _callee22, this);
	            }));
	
	            function reconnectToDevice(_x22) {
	                return _ref22.apply(this, arguments);
	            }
	
	            return reconnectToDevice;
	        }()
	    }, {
	        key: 'shouldAllowReconnectToDevice',
	        value: function shouldAllowReconnectToDevice(legoBluetoothDevice) {
	            if (!_LegoDeviceManagerImpl2.default.getInstance().config.shouldAutomaticallyReconnectOnConnectionLost()) {
	                return false;
	            }
	
	            if (legoBluetoothDevice.hasUserInitiatedDisconnect()) {
	                return false;
	            }
	
	            if (legoBluetoothDevice.buttonPressed) {
	                return false;
	            }
	
	            if (this.deviceToReconnectCount.size > 0) {
	                var reconnectCount = this.deviceToReconnectCount.get(legoBluetoothDevice.getAddress());
	                if (reconnectCount && reconnectCount !== null) {
	                    return reconnectCount < 1;
	                }
	            }
	            return true;
	        }
	    }, {
	        key: 'parseUuids',
	        value: function parseUuids(advertisedData) {
	            var uuids = new _SimpleList2.default();
	
	            var view = new DataView(advertisedData);
	            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                _LDSDKLogger2.default.info('AdvertisedData: ' + new Int8Array(advertisedData));
	            }
	
	            return uuids;
	        }
	    }, {
	        key: 'clearStartScanningTimeoutHandle',
	        value: function clearStartScanningTimeoutHandle() {
	            if (this.startScanningTimeoutHandle !== null) {
	                clearTimeout(this.startScanningTimeoutHandle);
	                this.startScanningTimeoutHandle = null;
	            }
	        }
	    }, {
	        key: 'clearStopScanningTimeoutHandle',
	        value: function clearStopScanningTimeoutHandle() {
	            if (this.stopScanningTimeoutHandle !== null) {
	                clearTimeout(this.stopScanningTimeoutHandle);
	                this.stopScanningTimeoutHandle = null;
	            }
	        }
	    }, {
	        key: 'startScan',
	        value: function () {
	            var _ref23 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee23() {
	                var start;
	                return _regenerator2.default.wrap(function _callee23$(_context23) {
	                    while (1) {
	                        switch (_context23.prev = _context23.next) {
	                            case 0:
	                                _context23.prev = 0;
	                                start = new Date().getTime();
	                                _context23.next = 4;
	                                return this.bluetoothAdapter.startLeScan();
	
	                            case 4:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('startLeScan completed in ' + (new Date().getTime() - start) + ' ms');
	                                }
	                                _context23.next = 10;
	                                break;
	
	                            case 7:
	                                _context23.prev = 7;
	                                _context23.t0 = _context23['catch'](0);
	
	                                // No op - we want to continue
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('Failed starting scan: ', _context23.t0);
	                                }
	
	                            case 10:
	                            case 'end':
	                                return _context23.stop();
	                        }
	                    }
	                }, _callee23, this, [[0, 7]]);
	            }));
	
	            function startScan() {
	                return _ref23.apply(this, arguments);
	            }
	
	            return startScan;
	        }()
	    }, {
	        key: 'stopScan',
	        value: function () {
	            var _ref24 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee24() {
	                var start;
	                return _regenerator2.default.wrap(function _callee24$(_context24) {
	                    while (1) {
	                        switch (_context24.prev = _context24.next) {
	                            case 0:
	                                _context24.prev = 0;
	                                start = new Date().getTime();
	                                _context24.next = 4;
	                                return this.bluetoothAdapter.stopLeScan();
	
	                            case 4:
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('stopLeScan completed in ' + (new Date().getTime() - start) + ' ms');
	                                }
	                                _context24.next = 10;
	                                break;
	
	                            case 7:
	                                _context24.prev = 7;
	                                _context24.t0 = _context24['catch'](0);
	
	                                // No op - we want to continue
	                                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                    _LDSDKLogger2.default.debug('Failed stopping scan: ', _context24.t0);
	                                }
	
	                            case 10:
	                            case 'end':
	                                return _context24.stop();
	                        }
	                    }
	                }, _callee24, this, [[0, 7]]);
	            }));
	
	            function stopScan() {
	                return _ref24.apply(this, arguments);
	            }
	
	            return stopScan;
	        }()
	    }, {
	        key: 'startScanBackground',
	        value: function () {
	            var _ref25 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee26() {
	                var _this7 = this;
	
	                return _regenerator2.default.wrap(function _callee26$(_context26) {
	                    while (1) {
	                        switch (_context26.prev = _context26.next) {
	                            case 0:
	                                _context26.next = 2;
	                                return this.startScan();
	
	                            case 2:
	                                this.clearStopScanningTimeoutHandle();
	                                this.stopScanningTimeoutHandle = setTimeout((0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee25() {
	                                    return _regenerator2.default.wrap(function _callee25$(_context25) {
	                                        while (1) {
	                                            switch (_context25.prev = _context25.next) {
	                                                case 0:
	                                                    _context25.next = 2;
	                                                    return _this7.stopScanBackground();
	
	                                                case 2:
	                                                    _this7.clearStopScanningTimeoutHandle();
	
	                                                case 3:
	                                                case 'end':
	                                                    return _context25.stop();
	                                            }
	                                        }
	                                    }, _callee25, _this7);
	                                })), _LegoDeviceManagerImpl2.default.getInstance().config.startStopScanningInterval);
	
	                            case 4:
	                            case 'end':
	                                return _context26.stop();
	                        }
	                    }
	                }, _callee26, this);
	            }));
	
	            function startScanBackground() {
	                return _ref25.apply(this, arguments);
	            }
	
	            return startScanBackground;
	        }()
	    }, {
	        key: 'stopScanBackground',
	        value: function () {
	            var _ref27 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee28() {
	                var _this8 = this;
	
	                return _regenerator2.default.wrap(function _callee28$(_context28) {
	                    while (1) {
	                        switch (_context28.prev = _context28.next) {
	                            case 0:
	                                _context28.next = 2;
	                                return this.stopScan();
	
	                            case 2:
	                                this.clearStartScanningTimeoutHandle();
	                                this.startScanningTimeoutHandle = setTimeout((0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee27() {
	                                    return _regenerator2.default.wrap(function _callee27$(_context27) {
	                                        while (1) {
	                                            switch (_context27.prev = _context27.next) {
	                                                case 0:
	                                                    _context27.next = 2;
	                                                    return _this8.startScanBackground();
	
	                                                case 2:
	                                                    _this8.clearStartScanningTimeoutHandle();
	
	                                                case 3:
	                                                case 'end':
	                                                    return _context27.stop();
	                                            }
	                                        }
	                                    }, _callee27, _this8);
	                                })), _LegoDeviceManagerImpl2.default.getInstance().config.startStopScanningInterval);
	
	                            case 4:
	                            case 'end':
	                                return _context28.stop();
	                        }
	                    }
	                }, _callee28, this);
	            }));
	
	            function stopScanBackground() {
	                return _ref27.apply(this, arguments);
	            }
	
	            return stopScanBackground;
	        }()
	    }, {
	        key: 'startRepeatingScanning',
	        value: function startRepeatingScanning() {
	            var _this9 = this;
	
	            this.clearStartScanningTimeoutHandle();
	            this.startScanningTimeoutHandle = setTimeout((0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee29() {
	                return _regenerator2.default.wrap(function _callee29$(_context29) {
	                    while (1) {
	                        switch (_context29.prev = _context29.next) {
	                            case 0:
	                                _context29.next = 2;
	                                return _this9.startScanBackground();
	
	                            case 2:
	                                _this9.clearStartScanningTimeoutHandle();
	
	                            case 3:
	                            case 'end':
	                                return _context29.stop();
	                        }
	                    }
	                }, _callee29, _this9);
	            })), 0);
	        }
	    }, {
	        key: 'stopRepeatingScanning',
	        value: function () {
	            var _ref30 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee30() {
	                return _regenerator2.default.wrap(function _callee30$(_context30) {
	                    while (1) {
	                        switch (_context30.prev = _context30.next) {
	                            case 0:
	                                this.clearStartScanningTimeoutHandle();
	                                this.clearStopScanningTimeoutHandle();
	                                _context30.next = 4;
	                                return this.stopScan();
	
	                            case 4:
	                            case 'end':
	                                return _context30.stop();
	                        }
	                    }
	                }, _callee30, this);
	            }));
	
	            function stopRepeatingScanning() {
	                return _ref30.apply(this, arguments);
	            }
	
	            return stopRepeatingScanning;
	        }()
	    }, {
	        key: 'isScanning',
	        value: function () {
	            var _ref31 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee31() {
	                return _regenerator2.default.wrap(function _callee31$(_context31) {
	                    while (1) {
	                        switch (_context31.prev = _context31.next) {
	                            case 0:
	                                _context31.next = 2;
	                                return this.bluetoothAdapter.isScanning();
	
	                            case 2:
	                                return _context31.abrupt('return', _context31.sent);
	
	                            case 3:
	                            case 'end':
	                                return _context31.stop();
	                        }
	                    }
	                }, _callee31, this);
	            }));
	
	            function isScanning() {
	                return _ref31.apply(this, arguments);
	            }
	
	            return isScanning;
	        }()
	    }, {
	        key: 'startRepeatingCleanUpListOfDiscoveredDevices',
	        value: function startRepeatingCleanUpListOfDiscoveredDevices() {
	            this.cleanUpListOfDiscoveredDevices();
	        }
	    }, {
	        key: 'stopRepeatingDeviceDisappearanceDiscovery',
	        value: function stopRepeatingDeviceDisappearanceDiscovery() {
	            if (this.cleanUpListOfDiscoveredDevicesTimeoutId) {
	                clearTimeout(this.cleanUpListOfDiscoveredDevicesTimeoutId);
	            }
	        }
	    }, {
	        key: 'devices',
	        get: function get() {
	            return this._devices;
	        }
	    }]);
	    return LegoBluetoothDeviceManagerImpl;
	}();
	
	LegoBluetoothDeviceManagerImpl.REFRESH_DEVICE_LIST_DEFAULT_INTERVAL = 2000;
	LegoBluetoothDeviceManagerImpl.REFRESH_DEVICE_LIST_MINIMUM_INTERVAL = 1000;
	LegoBluetoothDeviceManagerImpl.START_STOP_SCANNING_INTERVAL = 600;
	exports.default = LegoBluetoothDeviceManagerImpl;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by frj on 22/02/16.
	 */
	
	var LegoDeviceManager = function LegoDeviceManager() {
	  (0, _classCallCheck3.default)(this, LegoDeviceManager);
	};
	
	LegoDeviceManager.DEFAULT_CONNECT_REQUEST_TIMEOUT = 12000;
	exports.default = LegoDeviceManager;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _regenerator = __webpack_require__(14);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _promise = __webpack_require__(12);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _asyncToGenerator2 = __webpack_require__(13);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _stringify = __webpack_require__(19);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var StorageHelper = function () {
	    function StorageHelper() {
	        (0, _classCallCheck3.default)(this, StorageHelper);
	    }
	
	    (0, _createClass3.default)(StorageHelper, null, [{
	        key: '_isEmpty',
	        value: function _isEmpty(obj) {
	            if (typeof obj === 'undefined') {
	                return true;
	            }
	
	            if (typeof obj === 'string' || typeof obj === 'number') {
	                return obj.toString().trim().length === 0;
	            }
	
	            for (var prop in obj) {
	                if (obj.hasOwnProperty(prop)) return false;
	            }
	            return (0, _stringify2.default)(obj) === (0, _stringify2.default)({});
	        }
	    }, {
	        key: '_checkItemsAndKey',
	        value: function () {
	            var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(key, items) {
	                var _this = this;
	
	                return _regenerator2.default.wrap(function _callee$(_context) {
	                    while (1) {
	                        switch (_context.prev = _context.next) {
	                            case 0:
	                                return _context.abrupt('return', new _promise2.default(function (resolve, reject) {
	                                    if (!_this._isEmpty(items)) {
	                                        if (!_this._isEmpty(key)) {
	                                            var myValue = items[key];
	                                            if (!_this._isEmpty(myValue)) {
	                                                return resolve(myValue);
	                                            }
	                                        } else {
	                                            return resolve(items);
	                                        }
	                                    }
	                                    return resolve(undefined);
	                                }));
	
	                            case 1:
	                            case 'end':
	                                return _context.stop();
	                        }
	                    }
	                }, _callee, this);
	            }));
	
	            function _checkItemsAndKey(_x, _x2) {
	                return _ref.apply(this, arguments);
	            }
	
	            return _checkItemsAndKey;
	        }()
	    }, {
	        key: 'saveToLocalStorage',
	        value: function () {
	            var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(key, value) {
	                var _this2 = this;
	
	                return _regenerator2.default.wrap(function _callee2$(_context2) {
	                    while (1) {
	                        switch (_context2.prev = _context2.next) {
	                            case 0:
	                                return _context2.abrupt('return', new _promise2.default(function (resolve, reject) {
	                                    if (!_this2._isEmpty(key) && !_this2._isEmpty(value) && chrome && chrome.storage && chrome.storage.local) {
	                                        var obj = {};
	                                        obj[key] = value;
	                                        chrome.storage.local.set(obj, function () {
	                                            return resolve(true);
	                                        });
	                                    } else {
	                                        if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                            _LDSDKLogger2.default.debug('saveToLocalStorage - chrome.storage.local is not available on this device - skipping persist of "' + key + '" - ' + (0, _stringify2.default)(value));
	                                        }
	                                        return resolve(false);
	                                    }
	                                }));
	
	                            case 1:
	                            case 'end':
	                                return _context2.stop();
	                        }
	                    }
	                }, _callee2, this);
	            }));
	
	            function saveToLocalStorage(_x3, _x4) {
	                return _ref2.apply(this, arguments);
	            }
	
	            return saveToLocalStorage;
	        }()
	    }, {
	        key: 'saveToSyncStorage',
	        value: function () {
	            var _ref3 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(key, value) {
	                var _this3 = this;
	
	                return _regenerator2.default.wrap(function _callee3$(_context3) {
	                    while (1) {
	                        switch (_context3.prev = _context3.next) {
	                            case 0:
	                                return _context3.abrupt('return', new _promise2.default(function (resolve, reject) {
	                                    if (!_this3._isEmpty(key) && !_this3._isEmpty(value) && chrome && chrome.storage && chrome.storage.sync) {
	                                        var obj = {};
	                                        obj[key] = value;
	                                        chrome.storage.sync.set(obj, function () {
	                                            return resolve(true);
	                                        });
	                                    } else {
	                                        if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                            _LDSDKLogger2.default.debug('saveToSyncStorage - chrome.storage.sync is not available on this device - skipping persist of ' + key + ' - ' + (0, _stringify2.default)(value));
	                                        }
	                                        return resolve(false);
	                                    }
	                                }));
	
	                            case 1:
	                            case 'end':
	                                return _context3.stop();
	                        }
	                    }
	                }, _callee3, this);
	            }));
	
	            function saveToSyncStorage(_x5, _x6) {
	                return _ref3.apply(this, arguments);
	            }
	
	            return saveToSyncStorage;
	        }()
	    }, {
	        key: 'getFromLocalStorage',
	        value: function () {
	            var _ref4 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4(key) {
	                var _this4 = this;
	
	                return _regenerator2.default.wrap(function _callee4$(_context4) {
	                    while (1) {
	                        switch (_context4.prev = _context4.next) {
	                            case 0:
	                                return _context4.abrupt('return', new _promise2.default(function (resolve, reject) {
	                                    if (chrome && chrome.storage && chrome.storage.local) {
	                                        chrome.storage.local.get(key, function (items) {
	                                            return _this4._checkItemsAndKey(key, items).then(function (result) {
	                                                return resolve(result);
	                                            });
	                                        });
	                                    } else {
	                                        if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                            _LDSDKLogger2.default.debug('getFromLocalStorage - chrome.storage.local is not available on this device - skipping get of key ' + key);
	                                        }
	                                        return resolve(undefined);
	                                    }
	                                }));
	
	                            case 1:
	                            case 'end':
	                                return _context4.stop();
	                        }
	                    }
	                }, _callee4, this);
	            }));
	
	            function getFromLocalStorage(_x7) {
	                return _ref4.apply(this, arguments);
	            }
	
	            return getFromLocalStorage;
	        }()
	    }, {
	        key: 'getFromSyncStorage',
	        value: function () {
	            var _ref5 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5(key) {
	                var _this5 = this;
	
	                return _regenerator2.default.wrap(function _callee5$(_context5) {
	                    while (1) {
	                        switch (_context5.prev = _context5.next) {
	                            case 0:
	                                return _context5.abrupt('return', new _promise2.default(function (resolve, reject) {
	                                    if (chrome && chrome.storage && chrome.storage.sync) {
	                                        chrome.storage.sync.get(key, function (items) {
	                                            return _this5._checkItemsAndKey(key, items).then(function (result) {
	                                                return resolve(result);
	                                            });
	                                        });
	                                    } else {
	                                        if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                            _LDSDKLogger2.default.debug('getFromSyncStorage - chrome.storage.sync is not available on this device - skipping get of key ' + key);
	                                        }
	                                        return resolve(undefined);
	                                    }
	                                }));
	
	                            case 1:
	                            case 'end':
	                                return _context5.stop();
	                        }
	                    }
	                }, _callee5, this);
	            }));
	
	            function getFromSyncStorage(_x8) {
	                return _ref5.apply(this, arguments);
	            }
	
	            return getFromSyncStorage;
	        }()
	    }]);
	    return StorageHelper;
	}();
	
	exports.default = StorageHelper;
	
	
	window.StorageHelper = window.StorageHelper || StorageHelper;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _map = __webpack_require__(9);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _IdHelper = __webpack_require__(28);
	
	var _IdHelper2 = _interopRequireDefault(_IdHelper);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var TimerUtil = function () {
	    function TimerUtil() {
	        (0, _classCallCheck3.default)(this, TimerUtil);
	    }
	
	    (0, _createClass3.default)(TimerUtil, null, [{
	        key: 'startTimer',
	
	
	        /**
	         * Start a new timer and get the generated id, that is required by the other timer functions
	         * @return {string} - An alphanumeric unique id
	         */
	        value: function startTimer() {
	            var timerKey = _IdHelper2.default.generateID();
	            TimerUtil.timers.set(timerKey, TimerUtil.now());
	            return timerKey;
	        }
	
	        /**
	         * Get the elapsed number of milliseconds since the timer was started - but keep the timer running for further measurements
	         * @param timerKey - The key returned by the startTimer call
	         * @return {number} - The number of milliseconds elapsed since starting the timer
	         */
	
	    }, {
	        key: 'elapsedTime',
	        value: function elapsedTime() {
	            var timerKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	
	            if (TimerUtil.timers.has(timerKey)) {
	                return TimerUtil.now() - TimerUtil.timers.get(timerKey);
	            }
	            return -1;
	        }
	
	        /**
	         * Get the elapsed number of milliseconds since the timer was started, and reset the timer to current timestamp.
	         * @param timerKey - The key returned by the startTimer call
	         * @return {number} - The number of milliseconds elapsed since starting the timer
	         */
	
	    }, {
	        key: 'resetTimer',
	        value: function resetTimer() {
	            var timerKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	
	            if (TimerUtil.timers.has(timerKey)) {
	                var now = TimerUtil.now();
	                var elapsed = TimerUtil.elapsedTime(timerKey);
	                TimerUtil.timers.set(timerKey, now);
	                return elapsed;
	            }
	            return -1;
	        }
	
	        /**
	         * Stop the timer and return the number of milliseconds since the timer was started
	         * @param timerKey
	         * @return {number} - The number of milliseconds elapsed since starting the timer
	         */
	
	    }, {
	        key: 'stopTimer',
	        value: function stopTimer() {
	            var timerKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	
	            if (timerKey === null) return -1;
	
	            var elapsed = TimerUtil.elapsedTime(timerKey);
	            TimerUtil.timers.delete(timerKey);
	            return elapsed;
	        }
	
	        /**
	         * Get the current number of milliseconds since Epoch
	         * @return {number} - Number of milliseconds since jan 1 1970 00:00:00
	         */
	
	    }, {
	        key: 'now',
	        value: function now() {
	            if (!Date.now) {
	                Date.now = function now() {
	                    return new Date().getTime();
	                };
	            }
	            return Date.now();
	        }
	    }]);
	    return TimerUtil;
	}();
	
	TimerUtil.timers = new _map2.default();
	exports.default = TimerUtil;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var InputCommand = function () {
	    function InputCommand(commandId, commandType, connectId, payloadData) {
	        (0, _classCallCheck3.default)(this, InputCommand);
	
	        var commandBytes = new Int8Array(InputCommand.HEADER_SIZE + payloadData.byteLength);
	        var payloadBytes = new Int8Array(payloadData);
	
	        commandBytes[0] = commandId;
	        commandBytes[1] = commandType;
	        commandBytes[2] = connectId;
	
	        commandBytes.set(payloadBytes, InputCommand.HEADER_SIZE); // Append the format bytes from position 3
	
	        this.data = commandBytes.buffer;
	    }
	
	    /**
	     *
	     * @param {InputFormat} format
	     * @param {number} connectId
	     * @return {InputCommand}
	     */
	
	
	    (0, _createClass3.default)(InputCommand, [{
	        key: 'getData',
	
	
	        /**
	         *
	         * @return {ArrayBuffer}
	         */
	        value: function getData() {
	            return this.data === null ? null : this.data.slice();
	        }
	    }], [{
	        key: 'commandWriteInputFormat',
	        value: function commandWriteInputFormat(format, connectId) {
	            return new InputCommand(InputCommand.COMMAND_ID_INPUT_FORMAT, InputCommand.COMMAND_TYPE_WRITE, connectId, format.writeFormatData());
	        }
	
	        /**
	         *
	         * @param {number} connectId
	         * @return {InputCommand}
	         */
	
	    }, {
	        key: 'commandReadInputFormatForConnectId',
	        value: function commandReadInputFormatForConnectId(connectId) {
	            return new InputCommand(InputCommand.COMMAND_ID_INPUT_FORMAT, InputCommand.COMMAND_TYPE_READ, connectId, new Uint8Array(0));
	        }
	
	        /**
	         *
	         * @param {number} connectId
	         * @return {InputCommand}
	         */
	
	    }, {
	        key: 'commandReadValueForConnectId',
	        value: function commandReadValueForConnectId(connectId) {
	            return new InputCommand(InputCommand.COMMAND_ID_INPUT_VALUE, InputCommand.COMMAND_TYPE_READ, connectId, new Uint8Array(0));
	        }
	    }]);
	    return InputCommand;
	}(); /**
	      * Created by frj on 11/02/16.
	      */
	
	
	InputCommand.HEADER_SIZE = 3;
	InputCommand.COMMAND_ID_INPUT_VALUE = 0;
	InputCommand.COMMAND_ID_INPUT_FORMAT = 1;
	InputCommand.COMMAND_TYPE_READ = 1;
	InputCommand.COMMAND_TYPE_WRITE = 2;
	exports.default = InputCommand;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var OutputCommand = function () {
	
	  /**
	   *
	   * @param {number} connectId
	   * @param {commandId} commandId
	   * @param {ArrayBuffer} payloadData
	   */
	  function OutputCommand(connectId, commandId, payloadData) {
	    (0, _classCallCheck3.default)(this, OutputCommand);
	
	    var tempDataArray = new Uint8Array(OutputCommand.HEADER_SIZE + payloadData.byteLength);
	    tempDataArray[0] = connectId;
	    tempDataArray[1] = commandId;
	    tempDataArray[2] = payloadData.byteLength;
	    tempDataArray.set(new Uint8Array(payloadData), 3);
	
	    // LDSDKLogger.trace('OutputCommand data: ' + tempDataArray);
	    this.data = tempDataArray.buffer;
	  }
	
	  /**
	   *
	   * @param {number} power
	   * @param {number} connectId
	   * @return {OutputCommand}
	   */
	
	
	  (0, _createClass3.default)(OutputCommand, [{
	    key: 'getData',
	
	
	    /**
	     *
	     * @return {ArrayBuffer}
	     */
	    value: function getData() {
	      return this.data === null ? null : this.data.slice();
	    }
	  }], [{
	    key: 'commandWriteMotorPower',
	    value: function commandWriteMotorPower(power, connectId) {
	      return new OutputCommand(connectId, OutputCommand.WRITE_MOTOR_POWER_COMMAND_ID, new Uint8Array([power]));
	    }
	
	    /**
	     *
	     * @param {number} frequency
	     * @param {number} duration
	     * @param {number} connectId
	     * @return {OutputCommand}
	     */
	
	  }, {
	    key: 'commandWritePiezoToneFrequency',
	    value: function commandWritePiezoToneFrequency(frequency, duration, connectId) {
	      var payloadBuffer = new DataView(new ArrayBuffer(4));
	      payloadBuffer.setUint16(0, frequency, true); // true -> little endian
	      payloadBuffer.setUint16(2, duration, true); // true -> little endian
	
	      return new OutputCommand(connectId, OutputCommand.PLAY_PIEZO_TONE_COMMAND_ID, payloadBuffer.buffer);
	    }
	
	    /**
	     *
	     * @param {number} red
	     * @param {number} green
	     * @param {number} blue
	     * @param {number} connectId
	     * @return {OutputCommand}
	     */
	
	  }, {
	    key: 'commandWriteRGBLight',
	    value: function commandWriteRGBLight(red, green, blue, connectId) {
	      var payloadBuffer = new DataView(new ArrayBuffer(3));
	      payloadBuffer.setUint8(0, red);
	      payloadBuffer.setUint8(1, green);
	      payloadBuffer.setUint8(2, blue);
	
	      return new OutputCommand(connectId, OutputCommand.WRITE_RGB_COMMAND_ID, payloadBuffer.buffer);
	    }
	
	    /**
	     *
	     * @param {number} index
	     * @param {number} connectId
	     * @return {OutputCommand}
	     */
	
	  }, {
	    key: 'commandWriteRGBLightIndex',
	    value: function commandWriteRGBLightIndex(index, connectId) {
	      var payloadBuffer = new DataView(new ArrayBuffer(1));
	      payloadBuffer.setUint8(0, index);
	      return new OutputCommand(connectId, OutputCommand.WRITE_RGB_COMMAND_ID, payloadBuffer.buffer);
	    }
	
	    /**
	     *
	     * @param {ArrayBuffer} dataBuffer
	     * @param {number} connectId
	     * @return {OutputCommand}
	     */
	
	  }, {
	    key: 'commandWithDirectWriteThroughData',
	    value: function commandWithDirectWriteThroughData(dataBuffer, connectId) {
	      return new OutputCommand(connectId, OutputCommand.WRITE_DIRECT_ID, dataBuffer);
	    }
	
	    /**
	     *
	     * @param {number} connectId
	     * @return {OutputCommand}
	     */
	
	  }, {
	    key: 'commandWritePiezoToneStopForConnectId',
	    value: function commandWritePiezoToneStopForConnectId(connectId) {
	      return new OutputCommand(connectId, OutputCommand.STOP_PIEZO_TONE_COMMAND_ID, new Uint8Array(0));
	    }
	  }]);
	  return OutputCommand;
	}(); /**
	      * Created by frj on 12/02/16.
	      */
	
	
	OutputCommand.HEADER_SIZE = 3;
	OutputCommand.WRITE_MOTOR_POWER_COMMAND_ID = 0x01;
	OutputCommand.PLAY_PIEZO_TONE_COMMAND_ID = 0x02;
	OutputCommand.STOP_PIEZO_TONE_COMMAND_ID = 0x03;
	OutputCommand.WRITE_RGB_COMMAND_ID = 0x04;
	OutputCommand.WRITE_DIRECT_ID = 0x05;
	OutputCommand.COMMAND_PAYLOAD_SIZE_PIEZO = 4;
	OutputCommand.COMMAND_PAYLOAD_SIZE_RGB_LIGHT = 3;
	exports.default = OutputCommand;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getPrototypeOf = __webpack_require__(5);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(7);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get2 = __webpack_require__(23);
	
	var _get3 = _interopRequireDefault(_get2);
	
	var _inherits2 = __webpack_require__(6);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _InputFormat = __webpack_require__(22);
	
	var _InputFormat2 = _interopRequireDefault(_InputFormat);
	
	var _LegoService2 = __webpack_require__(18);
	
	var _LegoService3 = _interopRequireDefault(_LegoService2);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Service implementation handling current readings from the hub
	 */
	var CurrentSensor = function (_LegoService) {
	    (0, _inherits3.default)(CurrentSensor, _LegoService);
	
	    // x = 2;
	
	    /**
	     * @ignore
	     * @param {ConnectInfo} connectInfo
	     * @param {BluetoothIO} io
	     */
	    function CurrentSensor(connectInfo, io) {
	        (0, _classCallCheck3.default)(this, CurrentSensor);
	
	        /**
	         * @private
	         * @type {string}
	         */
	        var _this = (0, _possibleConstructorReturn3.default)(this, (CurrentSensor.__proto__ || (0, _getPrototypeOf2.default)(CurrentSensor)).call(this, connectInfo, io));
	
	        _this.SERVICE_CURRENT_SENSOR_NAME = 'Current Sensor';
	        return _this;
	    }
	
	    /**
	     * Return the name of the sensor
	     * @return {string}
	     */
	
	
	    (0, _createClass3.default)(CurrentSensor, [{
	        key: 'getServiceName',
	        value: function getServiceName() {
	            return this.SERVICE_CURRENT_SENSOR_NAME;
	        }
	
	        /**
	         * Get the default input format for the Current Sensor.
	         *
	         * Note: By default notifications are not enabled for the Current sensor as the measurements can fluctuate
	         * and cause a lot of BLE traffic. Enable notifications only if you need them.
	         * Use {@link InputFormat#inputFormatBySettingNotificationsEnabled} on the default input format to get an input format
	         * with notifications enabled and then update the input format for the voltage sensor using the {@link CurrentSensor#updateInputFormat}
	         *
	         * @return {InputFormat}
	         */
	
	    }, {
	        key: 'getDefaultInputFormat',
	        value: function getDefaultInputFormat() {
	            return _InputFormat2.default.inputFormat(this.getConnectInfo().getConnectId(), this.getConnectInfo().getType(), 0, 30, _InputFormat.InputFormatUnit.SI, false);
	        }
	
	        /**
	         * @ignore
	         * Create an instance of the CurrentSensor
	         *
	         * @param {ConnectInfo} connectInfo
	         * @param {BluetoothIO} io
	         * @return {CurrentSensor}
	         */
	
	    }, {
	        key: 'getValueAsMilliAmps',
	
	
	        /**
	         * Get the current sensor value as milli amperes
	         * @return {number} - Returns a float number representing the measurement in milli amperes.
	         */
	        value: function getValueAsMilliAmps() {
	            if (this.inputFormat !== null && this.inputFormat.getMode() === 0 && this.inputFormat.getUnit() === _InputFormat.InputFormatUnit.SI) {
	                return this.getValueAsFloat();
	            } else {
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('Can only retrieve milli amps from Current Sensor when sensor is in mode 0 and uses SI units');
	                }
	                return 0;
	            }
	        }
	
	        /**
	         * @ignore
	         * Handle updated value data for the sensor
	         * @param {ArrayBuffer} valueData
	         */
	
	    }, {
	        key: 'handleUpdatedValueData',
	        value: function handleUpdatedValueData() {
	            var valueData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	
	            (0, _get3.default)(CurrentSensor.prototype.__proto__ || (0, _getPrototypeOf2.default)(CurrentSensor.prototype), 'handleUpdatedValueData', this).call(this, valueData);
	            this.callbackHelper.performDidUpdateMilliAmps(this, this.getValueAsMilliAmps());
	        }
	
	        /**
	         * Get the simple service data as an object for using in the callback handlers
	         * @return {{valueAsMilliAmps: number}}
	         */
	
	    }, {
	        key: 'getSimpleServiceData',
	        value: function getSimpleServiceData() {
	            return {
	                valueAsMilliAmps: this.getValueAsMilliAmps()
	            };
	        }
	    }], [{
	        key: 'createService',
	        value: function createService(connectInfo, io) {
	            return new CurrentSensor(connectInfo, io);
	        }
	    }]);
	    return CurrentSensor;
	}(_LegoService3.default); /**
	                           * Created by frj on 11/02/16.
	                           */
	
	// 'use strict';
	
	
	exports.default = CurrentSensor;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(5);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(7);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(6);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _LegoService2 = __webpack_require__(18);
	
	var _LegoService3 = _interopRequireDefault(_LegoService2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Generic Service is meant to be used for third party services / unkown services.
	 * This service has no default input format - so to read values from the service you need to set a format.
	 *
	 * It also does not know how to handle updated value data - so this you must also handle and possibly override the default implementation in {@link LegoService#handleUpdatedValueData}.
	 *
	 * @see {@link LegoService#updateInputFormat}
	 * @see {@link LegoService#handleUpdatedValueData}
	 *
	 */
	var GenericService = function (_LegoService) {
	  (0, _inherits3.default)(GenericService, _LegoService);
	
	  /**
	   * @ignore
	   * @param {ConnectInfo} connectInfo
	   * @param {BluetoothIO} io
	   */
	  function GenericService(connectInfo, io) {
	    (0, _classCallCheck3.default)(this, GenericService);
	    return (0, _possibleConstructorReturn3.default)(this, (GenericService.__proto__ || (0, _getPrototypeOf2.default)(GenericService)).call(this, connectInfo, io));
	  }
	
	  /**
	   * Get the service name
	   * @return {string}
	   */
	
	
	  /**
	   * @private
	   * @type {string}
	   */
	
	
	  (0, _createClass3.default)(GenericService, [{
	    key: 'getServiceName',
	    value: function getServiceName() {
	      return GenericService.SERVICE_GENERIC_NAME;
	    }
	
	    /**
	     * There is no default input format for a generic sensor. Create an {@link InputFormat} if you need it, and set it on the service using {@link LegoService#updateInputFormat}
	     * @return {null}
	     */
	
	  }, {
	    key: 'getDefaultInputFormat',
	    value: function getDefaultInputFormat() {
	      return null;
	    }
	
	    /**
	     * @ignore
	     * Create an instance of the generic service
	     * @param connectInfo
	     * @param io
	     * @return {GenericService}
	     */
	
	  }, {
	    key: 'createService',
	    value: function createService(connectInfo, io) {
	      return new GenericService(connectInfo, io);
	    }
	  }]);
	  return GenericService;
	}(_LegoService3.default); /**
	                           * Created by frj on 11/02/16.
	                           */
	
	// 'use strict';
	
	
	GenericService.SERVICE_GENERIC_NAME = 'Generic IO';
	exports.default = GenericService;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.MotionSensorMode = undefined;
	
	var _regenerator = __webpack_require__(14);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(13);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _getPrototypeOf = __webpack_require__(5);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(7);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get2 = __webpack_require__(23);
	
	var _get3 = _interopRequireDefault(_get2);
	
	var _inherits2 = __webpack_require__(6);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _InputFormat = __webpack_require__(22);
	
	var _InputFormat2 = _interopRequireDefault(_InputFormat);
	
	var _LegoService2 = __webpack_require__(18);
	
	var _LegoService3 = _interopRequireDefault(_LegoService2);
	
	var _DataFormat = __webpack_require__(46);
	
	var _DataFormat2 = _interopRequireDefault(_DataFormat);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 *
	 * @type {object} MotionSensorMode
	 * @property {number} MOTION_SENSOR_MODE_DETECT - Detect mode - produces value that reflect the relative distance from the sensor to objects in front of it
	 * @property {number} MOTION_SENSOR_MODE_COUNT - Count mode - produces values that reflect how many times the sensor has been activated
	 * @property {number} MOTION_SENSOR_MODE_UNKNOWN - Unknown (unsupported) mode
	 */
	/**
	 * Created by frj on 11/02/16.
	 */
	
	var MotionSensorMode = exports.MotionSensorMode = {
	    /**
	     * Detect mode - produces value that reflect the relative distance from the sensor to objects in front of it
	     */
	    MOTION_SENSOR_MODE_DETECT: 0,
	
	    /**
	     * Count mode - produces values that reflect how many times the sensor has been activated
	     */
	    MOTION_SENSOR_MODE_COUNT: 1,
	
	    /**
	     * Unknown (unsupported) mode
	     */
	    MOTION_SENSOR_MODE_UNKNOWN: 2,
	
	    /**
	     * Helper for getting the enum  - if the value is not one of the supported values - MOTION_SENSOR_MODE_UNKNOWN is
	     * returned
	     * @param {number} mode
	     * @return {number}
	     */
	    fromInteger: function fromInteger(mode) {
	        switch (parseInt(mode)) {
	            case this.MOTION_SENSOR_MODE_DETECT:
	                return this.MOTION_SENSOR_MODE_DETECT;
	            case this.MOTION_SENSOR_MODE_COUNT:
	                return this.MOTION_SENSOR_MODE_COUNT;
	            case this.MOTION_SENSOR_MODE_UNKNOWN:
	            default:
	                return this.MOTION_SENSOR_MODE_UNKNOWN;
	        }
	    },
	
	    asString: function asString(mode) {
	        switch (parseInt(mode)) {
	            case this.MOTION_SENSOR_MODE_DETECT:
	                return 'MOTION_SENSOR_MODE_DETECT';
	            case this.MOTION_SENSOR_MODE_COUNT:
	                return 'MOTION_SENSOR_MODE_COUNT';
	            case this.MOTION_SENSOR_MODE_UNKNOWN:
	            default:
	                return 'MOTION_SENSOR_MODE_UNKNOWN';
	        }
	    }
	};
	
	/**
	 * The motion sensor can be used for measuring distance to an object or detecting bumps.
	 *
	 * Note that there will be one instance of the MotionSensor per connected motion sensor.
	 */
	
	var MotionSensor = function (_LegoService) {
	    (0, _inherits3.default)(MotionSensor, _LegoService);
	
	    /**
	     * @ignore
	     * @param {ConnectInfo} connectInfo
	     * @param {BluetoothIO} io
	     */
	
	    /**
	     * @private
	     * @type {number}
	     */
	    function MotionSensor(connectInfo, io) {
	        (0, _classCallCheck3.default)(this, MotionSensor);
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, (MotionSensor.__proto__ || (0, _getPrototypeOf2.default)(MotionSensor)).call(this, connectInfo, io));
	
	        _this.addValidDataFormats();
	        return _this;
	    }
	
	    /**
	     * @ignore - Not to be used by client code
	     * Create a new instance of the Motion sensor service
	     * @param {ConnectInfo} connectInfo
	     * @param {BluetoothIO} io
	     * @return {MotionSensor}
	     */
	
	    /**
	     * @private
	     * @type {string}
	     */
	
	
	    /**
	     * @private
	     * @type {number}
	     */
	
	
	    (0, _createClass3.default)(MotionSensor, [{
	        key: 'getServiceName',
	
	
	        /**
	         * Get the service name
	         * @return {string}
	         */
	        value: function getServiceName() {
	            return MotionSensor.SERVICE_MOTION_SENSOR_NAME;
	        }
	
	        /**
	         * Get the default input format for the Motion sensor service
	         * The default input format measures distance to an object using delta interval 1, in SI units and has notifications enabled.
	         * @return {InputFormat}
	         */
	
	    }, {
	        key: 'getDefaultInputFormat',
	        value: function getDefaultInputFormat() {
	            return _InputFormat2.default.inputFormat(this.getConnectInfo().getConnectId(), this.getConnectInfo().getType(), MotionSensorMode.MOTION_SENSOR_MODE_DETECT, 1, _InputFormat.InputFormatUnit.SI, true);
	        }
	
	        /**
	         * @ignore
	         * Adds the valid data formats for the motion sensor service
	         */
	
	    }, {
	        key: 'addValidDataFormats',
	        value: function addValidDataFormats() {
	            this.addValidDataFormat(_DataFormat2.default.create('Detect', MotionSensorMode.MOTION_SENSOR_MODE_DETECT, _InputFormat.InputFormatUnit.RAW, 1, 1));
	            this.addValidDataFormat(_DataFormat2.default.create('Detect', MotionSensorMode.MOTION_SENSOR_MODE_DETECT, _InputFormat.InputFormatUnit.PERCENTAGE, 1, 1));
	            this.addValidDataFormat(_DataFormat2.default.create('Detect', MotionSensorMode.MOTION_SENSOR_MODE_DETECT, _InputFormat.InputFormatUnit.SI, 4, 1));
	            this.addValidDataFormat(_DataFormat2.default.create('Count', MotionSensorMode.MOTION_SENSOR_MODE_COUNT, _InputFormat.InputFormatUnit.RAW, 4, 1));
	            this.addValidDataFormat(_DataFormat2.default.create('Count', MotionSensorMode.MOTION_SENSOR_MODE_COUNT, _InputFormat.InputFormatUnit.PERCENTAGE, 1, 1));
	            this.addValidDataFormat(_DataFormat2.default.create('Count', MotionSensorMode.MOTION_SENSOR_MODE_COUNT, _InputFormat.InputFormatUnit.SI, 4, 1));
	        }
	
	        /**
	         * Get the distance if the sensor mode is MotionSensorMode.MOTION_SENSOR_MODE_COUNT then 0 is returned.
	         * @return {number} - The distance between 0 and 10
	         */
	
	    }, {
	        key: 'getDistance',
	        value: function getDistance() {
	            if (this.getMotionSensorMode() !== MotionSensorMode.MOTION_SENSOR_MODE_DETECT) {
	                return 0;
	            }
	
	            var number = this.getNumberFromValueData();
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug(this.getServiceName() + ' - distance: ' + number);
	            }
	            if (number !== null) {
	                return number;
	            } else {
	                return 0;
	            }
	        }
	
	        /**
	         * Get the count - if the sensor mode is MotionSensorMode.MOTION_SENSOR_MODE_DETECT then 0 is returned.
	         * @return {number} - The count
	         */
	
	    }, {
	        key: 'getCount',
	        value: function getCount() {
	            if (this.getMotionSensorMode() !== MotionSensorMode.MOTION_SENSOR_MODE_COUNT) {
	                return 0;
	            }
	
	            var number = this.getNumberFromValueData();
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug(this.getServiceName() + ' - count: ' + number + ', this.valueData: ' + (this.valueData !== null ? new Int8Array(this.valueData) : 'null'));
	            }
	            if (number !== null) {
	                return number;
	            } else {
	                return 0;
	            }
	        }
	
	        /**
	         * Get the current motion sensor mode.
	         * @return {number} - @see {@link MotionSensorMode}
	         */
	
	    }, {
	        key: 'getMotionSensorMode',
	        value: function getMotionSensorMode() {
	            return MotionSensorMode.fromInteger(this.getInputFormatMode());
	        }
	
	        /**
	         * Set the current motion sensor mode
	         * @param {number} motionSensorMode - @see {@link MotionSensorMode}
	         */
	
	    }, {
	        key: 'setMotionSensorMode',
	        value: function setMotionSensorMode(motionSensorMode) {
	            this.updateCurrentInputFormatWithNewMode(motionSensorMode);
	        }
	
	        /**
	         * @ignore
	         * Handle updated data
	         * @param {ArrayBuffer} valueData
	         */
	
	    }, {
	        key: 'handleUpdatedValueData',
	        value: function () {
	            var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
	                var valueData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	                var oldDistance, newDistance, newCount;
	                return _regenerator2.default.wrap(function _callee$(_context) {
	                    while (1) {
	                        switch (_context.prev = _context.next) {
	                            case 0:
	                                oldDistance = this.getDistance();
	
	                                (0, _get3.default)(MotionSensor.prototype.__proto__ || (0, _getPrototypeOf2.default)(MotionSensor.prototype), 'handleUpdatedValueData', this).call(this, valueData);
	
	                                if (!(this.getMotionSensorMode() === MotionSensorMode.MOTION_SENSOR_MODE_DETECT)) {
	                                    _context.next = 9;
	                                    break;
	                                }
	
	                                newDistance = this.getDistance();
	
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info(this.getServiceName() + ' - handleUpdatedValueData. Old distance: ' + oldDistance + ',  New distance: ' + newDistance + ', SensorMode: MotionSensorMode.MOTION_SENSOR_MODE_DETECT');
	                                }
	                                _context.next = 7;
	                                return this.callbackHelper.performDidUpdateMotionSensorDistanceCallback(this, oldDistance, newDistance);
	
	                            case 7:
	                                _context.next = 13;
	                                break;
	
	                            case 9:
	                                newCount = this.getCount();
	
	                                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                                    _LDSDKLogger2.default.info(this.getServiceName() + ' - handleUpdatedValueData. New count: ' + newCount + ', SensorMode: MotionSensorMode.MOTION_SENSOR_MODE_COUNT (' + this.getMotionSensorMode() + ')');
	                                }
	                                _context.next = 13;
	                                return this.callbackHelper.performDidUpdateMotionSensorCountCallback(this, newCount);
	
	                            case 13:
	                            case 'end':
	                                return _context.stop();
	                        }
	                    }
	                }, _callee, this);
	            }));
	
	            function handleUpdatedValueData() {
	                return _ref.apply(this, arguments);
	            }
	
	            return handleUpdatedValueData;
	        }()
	
	        /**
	         * Get a simple version of the motion sensor service object
	         * @return {{deviceId: string, isInternalService: boolean, serviceName: string, serviceData: ({}|*), numberValue: number, updateInputFormat: simpleService.updateInputFormat, handleUpdatedInputFormat: simpleService.handleUpdatedInputFormat}}
	         */
	
	    }, {
	        key: 'getSimpleService',
	        value: function getSimpleService() {
	            var superService = (0, _get3.default)(MotionSensor.prototype.__proto__ || (0, _getPrototypeOf2.default)(MotionSensor.prototype), 'getSimpleService', this).call(this);
	            var self = this;
	            superService['setMotionSensorMode'] = function (motionSensorMode) {
	                self.setMotionSensorMode(motionSensorMode);
	            };
	            return superService;
	        }
	
	        /**
	         * Get the simple service data for use in the service callback handler
	         * @return {{count: number, distance: number, motionSensorMode: number}}
	         */
	
	    }, {
	        key: 'getSimpleServiceData',
	        value: function getSimpleServiceData() {
	            var superServiceData = (0, _get3.default)(MotionSensor.prototype.__proto__ || (0, _getPrototypeOf2.default)(MotionSensor.prototype), 'getSimpleServiceData', this).call(this);
	            superServiceData['count'] = this.getCount();
	            superServiceData['distance'] = this.getDistance();
	            superServiceData['motionSensorMode'] = this.getMotionSensorMode();
	            return superServiceData;
	        }
	    }], [{
	        key: 'createService',
	        value: function createService(connectInfo, io) {
	            return new MotionSensor(connectInfo, io);
	        }
	    }]);
	    return MotionSensor;
	}(_LegoService3.default);
	
	MotionSensor.MAX_DISTANCE = 10;
	MotionSensor.MIN_DISTANCE = 0;
	MotionSensor.SERVICE_MOTION_SENSOR_NAME = 'Motion Sensor';
	exports.default = MotionSensor;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.PiezoTonePlayerNote = undefined;
	
	var _getPrototypeOf = __webpack_require__(5);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(7);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get2 = __webpack_require__(23);
	
	var _get3 = _interopRequireDefault(_get2);
	
	var _inherits2 = __webpack_require__(6);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _LegoService2 = __webpack_require__(18);
	
	var _LegoService3 = _interopRequireDefault(_LegoService2);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Tones that can be played using the PiezoTonePlayer
	 *
	 * @type {object} PiezoTonePlayerNote
	 * @property {number} PIEZO_NOTE_C - Note 'C'
	 * @property {number} PIEZO_NOTE_CIS - Note 'C#'
	 * @property {number} PIEZO_NOTE_D - Note 'D'
	 * @property {number} PIEZO_NOTE_DIS - Note 'D#'
	 * @property {number} PIEZO_NOTE_E - Note 'E'
	 * @property {number} PIEZO_NOTE_F - Note 'F'
	 * @property {number} PIEZO_NOTE_FIS - Note 'F#'
	 * @property {number} PIEZO_NOTE_G - Note 'G'
	 * @property {number} PIEZO_NOTE_GIS - Note 'G#'
	 * @property {number} PIEZO_NOTE_A - Note 'A'
	 * @property {number} PIEZO_NOTE_AIS - Note 'A#'
	 * @property {number} PIEZO_NOTE_B - Note 'B'
	 */
	/**
	 * Created by frj on 03/03/16.
	 */
	
	var PiezoTonePlayerNote = exports.PiezoTonePlayerNote = {
	    /**
	     * C
	     */
	    PIEZO_NOTE_C: 1,
	    /**
	     * C#
	     */
	    PIEZO_NOTE_CIS: 2,
	    /**
	     * D
	     */
	    PIEZO_NOTE_D: 3,
	    /**
	     * D#
	     */
	    PIEZO_NOTE_DIS: 4,
	    /**
	     * E
	     */
	    PIEZO_NOTE_E: 5,
	    /**
	     * F
	     */
	    PIEZO_NOTE_F: 6,
	    /**
	     * F#
	     */
	    PIEZO_NOTE_FIS: 7,
	    /**
	     * G
	     */
	    PIEZO_NOTE_G: 8,
	    /**
	     * G#
	     */
	    PIEZO_NOTE_GIS: 9,
	    /**
	     * A
	     */
	    PIEZO_NOTE_A: 10,
	    /**
	     * A#
	     */
	    PIEZO_NOTE_AIS: 11,
	    /**
	     * B
	     */
	    PIEZO_NOTE_B: 12,
	
	    fromInteger: function fromInteger(val) {
	        switch (parseInt(val)) {
	            case 0:
	                return this.PIEZO_NOTE_C;
	            case 1:
	                return this.PIEZO_NOTE_CIS;
	            case 2:
	                return this.PIEZO_NOTE_D;
	            case 3:
	                return this.PIEZO_NOTE_DIS;
	            case 4:
	                return this.PIEZO_NOTE_E;
	            case 5:
	                return this.PIEZO_NOTE_F;
	            case 6:
	                return this.PIEZO_NOTE_F;
	            case 7:
	                return this.PIEZO_NOTE_FIS;
	            case 8:
	                return this.PIEZO_NOTE_G;
	            case 9:
	                return this.PIEZO_NOTE_GIS;
	            case 10:
	                return this.PIEZO_NOTE_A;
	            case 11:
	                return this.PIEZO_NOTE_AIS;
	            case 12:
	                return this.PIEZO_NOTE_B;
	            default:
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('Reached default case when trying to determine Piezo Node for value: ' + val + ' note was set to ' + this.PIEZO_NOTE_C);
	                }
	                return this.PIEZO_NOTE_C;
	        }
	    }
	};
	
	/**
	 * The Piezo Tone Player can be used for controlling the Piezo speaker in the hub
	 */
	
	var PiezoTonePlayer = function (_LegoService) {
	    (0, _inherits3.default)(PiezoTonePlayer, _LegoService);
	
	    /**
	     * @ignore
	     *
	     * @param {ConnectInfo} connectInfo
	     * @param {BluetoothIO} io
	     */
	
	    /**
	     * @private
	     * @type {number}
	     */
	    function PiezoTonePlayer(connectInfo, io) {
	        (0, _classCallCheck3.default)(this, PiezoTonePlayer);
	        return (0, _possibleConstructorReturn3.default)(this, (PiezoTonePlayer.__proto__ || (0, _getPrototypeOf2.default)(PiezoTonePlayer)).call(this, connectInfo, io));
	    }
	
	    /**
	     * @ignore
	     * Create an instance of the piezo tone player service
	     * @param {ConnectInfo} connectInfo
	     * @param {BluetoothIO} io
	     * @return {PiezoTonePlayer}
	     */
	
	
	    /**
	     * @private
	     * @type {string}
	     */
	
	
	    /**
	     * @private
	     * @type {number}
	     */
	
	
	    (0, _createClass3.default)(PiezoTonePlayer, [{
	        key: 'getServiceName',
	
	
	        /**
	         * Get the service name
	         * @return {string}
	         */
	        value: function getServiceName() {
	            return PiezoTonePlayer.SERVICE_PIEZO_TONE_PLAYER_NAME;
	        }
	
	        /**
	         * Play a frequency for the given duration in ms
	         *
	         * @param {number} frequency The frequency to play (max supported frequency is 1500Hz)
	         * @param {number} duration  The duration to play (max supported is 65536 milliseconds).
	         */
	
	    }, {
	        key: 'playFrequency',
	        value: function playFrequency(frequency, duration) {
	            frequency = Math.round(Math.max(0, frequency));
	            duration = Math.round(Math.max(0, duration));
	            if (frequency > PiezoTonePlayer.PIEZO_TONE_MAX_FREQUENCY) {
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('Cannot play frequenzy ' + frequency + ', max supported frequency is ' + PiezoTonePlayer.PIEZO_TONE_MAX_FREQUENCY);
	                }
	                frequency = PiezoTonePlayer.PIEZO_TONE_MAX_FREQUENCY;
	            }
	            if (duration > PiezoTonePlayer.PIEZO_TONE_MAX_DURATION) {
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('Cannot play piezo tone with duration ' + duration + ' ms, max supported frequency is ' + PiezoTonePlayer.PIEZO_TONE_MAX_DURATION + ' ms');
	                }
	                duration = PiezoTonePlayer.PIEZO_TONE_MAX_DURATION;
	            }
	
	            this.getIo().writePiezoToneFrequency(frequency, duration, this.getConnectInfo().getConnectId());
	        }
	
	        /**
	         * Play a note.
	         * The highest supported note is F# in 6th octave
	         *
	         * @param {PiezoTonePlayerNote} note     The note to play (max supported is F# in the 6th octave)
	         * @param {number} octave   The octave in which to play the note
	         * @param {number} duration The duration to play (max supported is 65536 milli seconds).
	         */
	
	    }, {
	        key: 'playNote',
	        value: function playNote(note, octave, duration) {
	            octave = Math.round(Math.max(0, octave));
	            duration = Math.round(Math.max(0, duration));
	            if (octave > 6) {
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('Highest supported note is F# in 6th octave - invalid octave: ' + octave);
	                }
	            }
	            if (octave === 6 && note > PiezoTonePlayerNote.PIEZO_NOTE_FIS) {
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('Cannot play note. Highest supported note is F# in 6th octave');
	                }
	            }
	
	            /**
	             * The basic formula for the frequencies of the notes of the equal tempered scale is given by
	             * fn = f0 * (a)n
	             * where
	             * f0 = the frequency of one fixed note which must be defined. A common choice is setting the A above middle C (A4) at f0 = 440 Hz.
	             * n = the number of half steps away from the fixed note you are. If you are at a higher note, n is positive. If you are on a lower note, n is negative.
	             * fn = the frequency of the note n half steps away.
	             * a = (2)1/12 = the twelfth root of 2 = the number which when multiplied by itself 12 times equals 2 = 1.059463094359...
	             */
	
	            var base = 440.0;
	            var octavesAboveMiddle = octave - 4;
	            var halfStepsAwayFromBase = note - PiezoTonePlayer.PiezoTonePlayerNote.PIEZO_NOTE_A + octavesAboveMiddle * 12;
	            var frequency = base * Math.pow(Math.pow(2.0, 1.0 / 12), halfStepsAwayFromBase);
	
	            this.playFrequency(Math.round(frequency), duration);
	        }
	
	        /**
	         * Stop playing any currently playing tone.
	         */
	
	    }, {
	        key: 'stopPlaying',
	        value: function stopPlaying() {
	            this.getIo().writePiezoToneStop(this.getConnectInfo().getConnectId());
	        }
	
	        /**
	         * Get simple representation of the Piezo tone player service
	         * @return {{deviceId: string, isInternalService: boolean, serviceName: string, serviceData: ({}|*), numberValue: number, updateInputFormat: simpleService.updateInputFormat, handleUpdatedInputFormat: simpleService.handleUpdatedInputFormat}}
	         */
	
	    }, {
	        key: 'getSimpleService',
	        value: function getSimpleService() {
	            var superService = (0, _get3.default)(PiezoTonePlayer.prototype.__proto__ || (0, _getPrototypeOf2.default)(PiezoTonePlayer.prototype), 'getSimpleService', this).call(this);
	            var self = this;
	            superService['playFrequency'] = function (frequency, duration) {
	                self.playFrequency(frequency, duration);
	            };
	            superService['playNote'] = function (note, octave, duration) {
	                self.playNote(note, octave, duration);
	            };
	            superService['stopPlaying'] = function () {
	                self.stopPlaying();
	            };
	            return superService;
	        }
	    }], [{
	        key: 'createService',
	        value: function createService(connectInfo, io) {
	            return new PiezoTonePlayer(connectInfo, io);
	        }
	    }]);
	    return PiezoTonePlayer;
	}(_LegoService3.default);
	
	PiezoTonePlayer.PIEZO_TONE_MAX_FREQUENCY = 1500;
	PiezoTonePlayer.PIEZO_TONE_MAX_DURATION = 65536;
	PiezoTonePlayer.SERVICE_PIEZO_TONE_PLAYER_NAME = 'Piezo';
	exports.default = PiezoTonePlayer;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.RGBColor = exports.RGBLightMode = undefined;
	
	var _getPrototypeOf = __webpack_require__(5);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _possibleConstructorReturn2 = __webpack_require__(7);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get2 = __webpack_require__(23);
	
	var _get3 = _interopRequireDefault(_get2);
	
	var _inherits2 = __webpack_require__(6);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _stringify = __webpack_require__(19);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _InputFormat = __webpack_require__(22);
	
	var _InputFormat2 = _interopRequireDefault(_InputFormat);
	
	var _DataFormat = __webpack_require__(46);
	
	var _DataFormat2 = _interopRequireDefault(_DataFormat);
	
	var _LegoService2 = __webpack_require__(18);
	
	var _LegoService3 = _interopRequireDefault(_LegoService2);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 *
	 * @type {object} RGBLightMode
	 * @property {number} RGB_LIGHT_MODE_DISCRETE - Discrete mode allows selecting a color index from a set of predefined colors
	 * @property {number} RGB_LIGHT_MODE_ABSOLUTE - Absolute mode allows selecting any color by specifying its RGB component values
	 * @property {number} RGB_LIGHT_MODE_UNKNOWN - Unknown mode
	 *
	 */
	/**
	 * Created by frj on 11/02/16.
	 */
	
	// 'use strict';
	var RGBLightMode = exports.RGBLightMode = {
	    RGB_LIGHT_MODE_DISCRETE: 0,
	    RGB_LIGHT_MODE_ABSOLUTE: 1,
	    RGB_LIGHT_MODE_UNKNOWN: 2,
	
	    /**
	     * Helper for getting the enum  - if the value is not one of the supported values - RGB_LIGHT_MODE_UNKNOWN is
	     * returned
	     * @param {number} value
	     * @return {number}
	     */
	    fromInteger: function fromInteger(value) {
	        switch (parseInt(value)) {
	            case this.RGB_LIGHT_MODE_DISCRETE:
	                return this.RGB_LIGHT_MODE_DISCRETE;
	            case this.RGB_LIGHT_MODE_ABSOLUTE:
	                return this.RGB_LIGHT_MODE_ABSOLUTE;
	            case this.RGB_LIGHT_MODE_UNKNOWN:
	            default:
	                return this.RGB_LIGHT_MODE_UNKNOWN;
	        }
	    },
	
	    asString: function asString(value) {
	        switch (parseInt(value)) {
	            case this.RGB_LIGHT_MODE_DISCRETE:
	                return 'DISCRETE';
	            case this.RGB_LIGHT_MODE_ABSOLUTE:
	                return 'ABSOLUTE';
	            case this.RGB_LIGHT_MODE_UNKNOWN:
	            default:
	                return 'UNKNOWN';
	        }
	    }
	};
	
	var RGBColor = exports.RGBColor = function () {
	    function RGBColor(red, green, blue) {
	        (0, _classCallCheck3.default)(this, RGBColor);
	
	        this.red = red;
	        this.green = green;
	        this.blue = blue;
	    }
	
	    (0, _createClass3.default)(RGBColor, [{
	        key: 'getColor',
	        value: function getColor() {
	            return { red: this.red, green: this.green, blue: this.blue };
	        }
	    }, {
	        key: 'getRed',
	        value: function getRed() {
	            return this.red;
	        }
	    }, {
	        key: 'getGreen',
	        value: function getGreen() {
	            return this.green;
	        }
	    }, {
	        key: 'getBlue',
	        value: function getBlue() {
	            return this.blue;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return '[ ' + (0, _stringify2.default)(this.getColor()) + ' ]';
	        }
	    }]);
	    return RGBColor;
	}();
	
	/**
	 * The RGBLight can be used for controlling the RGB light LED in the hub
	 */
	
	
	var RGBLight = function (_LegoService) {
	    (0, _inherits3.default)(RGBLight, _LegoService);
	
	    /**
	     * @ignore
	     * @param {ConnectInfo} connectInfo
	     * @param {BluetoothIO} io
	     */
	    function RGBLight(connectInfo, io) {
	        (0, _classCallCheck3.default)(this, RGBLight);
	
	        /**
	         * @private
	         * @type {string}
	         */
	        var _this = (0, _possibleConstructorReturn3.default)(this, (RGBLight.__proto__ || (0, _getPrototypeOf2.default)(RGBLight)).call(this, connectInfo, io));
	
	        _this.SERVICE_RGB_LIGHT_NAME = 'RGB Light';
	        /**
	         * @private
	         * @type {RGBColor}
	         */
	        _this.color = _this.getDefaultColor();
	        /**
	         * @private
	         * @type {number}
	         */
	        _this.colorIndex = 0;
	
	        _this.addValidDataFormats();
	        return _this;
	    }
	
	    /**
	     * Get the name of the service
	     * @return {string}
	     */
	
	
	    (0, _createClass3.default)(RGBLight, [{
	        key: 'getServiceName',
	        value: function getServiceName() {
	            return this.SERVICE_RGB_LIGHT_NAME;
	        }
	
	        /**
	         * Get the default input format for the RGB Light
	         * @return {InputFormat}
	         */
	
	    }, {
	        key: 'getDefaultInputFormat',
	        value: function getDefaultInputFormat() {
	            return _InputFormat2.default.inputFormat(this.getConnectInfo().getConnectId(), this.getConnectInfo().getType(), RGBLightMode.RGB_LIGHT_MODE_DISCRETE, 1, _InputFormat.InputFormatUnit.RAW, true);
	        }
	
	        /**
	         * @ignore
	         * Create an instance of the RGBLight service
	         * @param {ConnectInfo} connectInfo
	         * @param {BluetoothIO} io
	         * @return {RGBLight}
	         */
	
	    }, {
	        key: 'setColor',
	
	
	        /**
	         * Set the RGB color - ignored if mode is not RGB_LIGHT_MODE_ABSOLUTE
	         * @param {RGBColor} rgbColor
	         */
	        value: function setColor(rgbColor) {
	            if (this.getRGBMode() === RGBLightMode.RGB_LIGHT_MODE_ABSOLUTE) {
	                this.color = rgbColor;
	
	                this.getIo().writeColor(rgbColor.getRed(), rgbColor.getGreen(), rgbColor.getBlue(), this.getConnectInfo().getConnectId());
	            } else {
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('Ignoring attempt to set RGB color. It is only supported when RGB is in mode' + ' Absolute.');
	                }
	            }
	        }
	
	        /**
	         *
	         * @return {RGBColor} - Returns the RGBColor that was set last. If no RGBColor has been set it returns the
	         * default RGB color (0,0,255)
	         */
	
	    }, {
	        key: 'getColor',
	        value: function getColor() {
	            return this.color;
	        }
	
	        /**
	         * Get the default RGB color (red: 0, green: 0, blue: 255)
	         * @return {RGBColor}. Returns the default RGB color (0,0,255)
	         */
	
	    }, {
	        key: 'getDefaultColor',
	        value: function getDefaultColor() {
	            // We have no reliable way of reading the default color of the Hub, so it is hardcoded here
	            return new RGBColor(0, 0, 255);
	        }
	
	        /**
	         * Get the current color index
	         * @return {*|number}
	         */
	
	    }, {
	        key: 'getColorIndex',
	        value: function getColorIndex() {
	            return this.colorIndex;
	        }
	
	        /**
	         * Update the color index for the RGB light. The call is ignored if the RGB light mode is not RGB_LIGHT_MODE_DISCRETE.
	         * @param {number} index - The value to se
	         */
	
	    }, {
	        key: 'setColorIndex',
	        value: function setColorIndex(index) {
	            if (this.getRGBMode() === RGBLightMode.RGB_LIGHT_MODE_DISCRETE) {
	                this.colorIndex = index;
	                this.getIo().writeColorIndex(index, this.getConnectInfo().getConnectId());
	            } else {
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('Ignoring attempt to set RGB color index. It is only supported when RGB is in mode Discrete.');
	                }
	            }
	        }
	
	        /**
	         * Get the default color index
	         * @return {number} - The default color index for the RGB light.
	         */
	
	    }, {
	        key: 'getDefaultColorIndex',
	        value: function getDefaultColorIndex() {
	            // We have no reliable way of reading the default color of the Hub, so it is hardcoded here
	            return 3;
	        }
	
	        /**
	         * Get the default RGBMode
	         * @return {number} - See {@link RGBLightMode} for values that can be returned
	         */
	
	    }, {
	        key: 'getRGBMode',
	        value: function getRGBMode() {
	            return RGBLightMode.fromInteger(this.getInputFormatMode());
	        }
	
	        /**
	         * Update the RGBMode for the RGB light service
	         * @param {number} rgbMode - See {@link RGBLightMode}
	         */
	
	    }, {
	        key: 'setRGBMode',
	        value: function setRGBMode(rgbMode) {
	            this.updateCurrentInputFormatWithNewMode(rgbMode);
	        }
	
	        /**
	         * Switch off the RGB light
	         */
	
	    }, {
	        key: 'switchOff',
	        value: function switchOff() {
	            if (this.getRGBMode() === RGBLightMode.RGB_LIGHT_MODE_ABSOLUTE) {
	                this.setColor(new RGBColor(0, 0, 0));
	            } else if (this.getRGBMode() === RGBLightMode.RGB_LIGHT_MODE_DISCRETE) {
	                this.setColorIndex(0);
	            } else {
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('Cannot switch off RGB - unknown mode: ' + this.getInputFormatMode());
	                }
	            }
	        }
	
	        /**
	         * Set the RGBLight to its default color
	         */
	
	    }, {
	        key: 'switchToDefaultColor',
	        value: function switchToDefaultColor() {
	            if (this.getRGBMode() === RGBLightMode.RGB_LIGHT_MODE_ABSOLUTE) {
	                this.setColor(this.getDefaultColor());
	            } else if (this.getRGBMode() === RGBLightMode.RGB_LIGHT_MODE_DISCRETE) {
	                this.setColorIndex(this.getDefaultColorIndex());
	            } else {
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('Cannot switch to default color - unknown mode: ' + this.getInputFormatMode());
	                }
	            }
	        }
	
	        /**
	         * @ignore
	         * @param valueData
	         */
	
	    }, {
	        key: 'handleUpdatedValueData',
	        value: function handleUpdatedValueData() {
	            var valueData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	
	            if (this.getRGBMode() === RGBLightMode.RGB_LIGHT_MODE_ABSOLUTE) {
	                var oldColor = this.color;
	                this.color = this.colorFromData(valueData);
	
	                (0, _get3.default)(RGBLight.prototype.__proto__ || (0, _getPrototypeOf2.default)(RGBLight.prototype), 'handleUpdatedValueData', this).call(this, valueData);
	                this.callbackHelper.performRGBLightDidUpdateValueCallback(this, oldColor, this.color);
	            } else if (this.getRGBMode() === RGBLightMode.RGB_LIGHT_MODE_DISCRETE) {
	                var oldColorIndex = this.colorIndex;
	                this.colorIndex = this.getIntegerFromData(valueData);
	
	                (0, _get3.default)(RGBLight.prototype.__proto__ || (0, _getPrototypeOf2.default)(RGBLight.prototype), 'handleUpdatedValueData', this).call(this, valueData);
	                this.callbackHelper.performRGBLightDidUpdateColorIndexCallback(this, oldColorIndex, this.colorIndex);
	            } else {
	                _LDSDKLogger2.default.error('Cannot handle response for RGB in unknown mode ' + this.getInputFormatMode());
	            }
	        }
	
	        /**
	         * @ignore
	         * Get the RGBColor from the ArrayBuffer data
	         * @param {ArrayBuffer} data
	         * @return {RGBColor|null} Returns an RGBColor representing the color specified in the ArrayBuffer. If the number of bytes in the buffer is different from 3 - null is returned.
	         */
	
	    }, {
	        key: 'colorFromData',
	        value: function colorFromData(data) {
	            if (data.byteLength === 3) {
	                var dataBuffer = new DataView(data);
	                return new RGBColor(dataBuffer.getUint8(0), dataBuffer.getUint8(1), dataBuffer.getUint8(2));
	            }
	
	            _LDSDKLogger2.default.error('Cannot create color from data: ' + new Uint8Array(data) + ' ');
	            return null;
	        }
	
	        /**
	         * @ignore
	         * Populate the valid data formats for the RGB Light.
	         */
	
	    }, {
	        key: 'addValidDataFormats',
	        value: function addValidDataFormats() {
	            this.addValidDataFormat(_DataFormat2.default.create('Discrete', RGBLightMode.RGB_LIGHT_MODE_DISCRETE, _InputFormat.InputFormatUnit.RAW, 1, 1));
	            this.addValidDataFormat(_DataFormat2.default.create('Discrete', RGBLightMode.RGB_LIGHT_MODE_DISCRETE, _InputFormat.InputFormatUnit.PERCENTAGE, 1, 1));
	            this.addValidDataFormat(_DataFormat2.default.create('Discrete', RGBLightMode.RGB_LIGHT_MODE_DISCRETE, _InputFormat.InputFormatUnit.SI, 4, 1));
	
	            this.addValidDataFormat(_DataFormat2.default.create('Absolute', RGBLightMode.RGB_LIGHT_MODE_ABSOLUTE, _InputFormat.InputFormatUnit.RAW, 1, 3));
	            this.addValidDataFormat(_DataFormat2.default.create('Absolute', RGBLightMode.RGB_LIGHT_MODE_ABSOLUTE, _InputFormat.InputFormatUnit.PERCENTAGE, 1, 3));
	            this.addValidDataFormat(_DataFormat2.default.create('Absolute', RGBLightMode.RGB_LIGHT_MODE_ABSOLUTE, _InputFormat.InputFormatUnit.SI, 4, 3));
	        }
	
	        /**
	         * Get the simple service representation
	         * @return {{deviceId: string, isInternalService: boolean, serviceName: string, serviceData: ({}|*), numberValue: number, updateInputFormat: simpleService.updateInputFormat, handleUpdatedInputFormat: simpleService.handleUpdatedInputFormat}}
	         */
	
	    }, {
	        key: 'getSimpleService',
	        value: function getSimpleService() {
	            var superService = (0, _get3.default)(RGBLight.prototype.__proto__ || (0, _getPrototypeOf2.default)(RGBLight.prototype), 'getSimpleService', this).call(this);
	            var self = this;
	            superService['setRGBMode'] = function (rgbMode) {
	                self.setRGBMode(rgbMode);
	            };
	            superService['setColor'] = function (rgbColor) {
	                self.setColor(rgbColor);
	            };
	            superService['setColorIndex'] = function (index) {
	                self.setColorIndex(index);
	            };
	            superService['switchOff'] = function () {
	                self.switchOff();
	            };
	            superService['switchToDefaultColor'] = function () {
	                self.switchToDefaultColor();
	            };
	            return superService;
	        }
	
	        /**
	         * Get the simple service data for use in the service callback handler
	         * @return {{rgbMode: {RGBLightMode|number}, color: RGBColor, defaultColor: RGBColor, colorIndex: number, defaultColorIndex: number}}
	         */
	
	    }, {
	        key: 'getSimpleServiceData',
	        value: function getSimpleServiceData() {
	            return {
	                rgbMode: this.getRGBMode(),
	                color: this.getColor(),
	                defaultColor: this.getDefaultColor(),
	                colorIndex: this.getColorIndex(),
	                defaultColorIndex: this.getDefaultColorIndex()
	            };
	        }
	    }], [{
	        key: 'createService',
	        value: function createService(connectInfo, io) {
	            return new RGBLight(connectInfo, io);
	        }
	    }]);
	    return RGBLight;
	}(_LegoService3.default);
	
	exports.default = RGBLight;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.MotorDirection = undefined;
	
	var _getPrototypeOf = __webpack_require__(5);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(7);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get2 = __webpack_require__(23);
	
	var _get3 = _interopRequireDefault(_get2);
	
	var _inherits2 = __webpack_require__(6);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _LegoService2 = __webpack_require__(18);
	
	var _LegoService3 = _interopRequireDefault(_LegoService2);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 *
	 * @type {object} MotorDirection enum
	 * @property {number} MOTOR_DIRECTION_DRIFTING - Drifting (Floating)
	 * @property {number} MOTOR_DIRECTION_LEFT - Running left
	 * @property {number} MOTOR_DIRECTION_RIGHT - Running right
	 * @property {number} MOTOR_DIRECTION_BRAKING - Braking
	 */
	/**
	 * Created by frj on 11/02/16.
	 */
	
	// 'use strict';
	var MotorDirection = exports.MotorDirection = {
	
	    /**
	     * Drifting (Floating)
	     */
	    MOTOR_DIRECTION_DRIFTING: 0,
	
	    /**
	     * Running left
	     */
	    MOTOR_DIRECTION_LEFT: 1,
	
	    /**
	     * Running right
	     */
	    MOTOR_DIRECTION_RIGHT: 2,
	
	    /**
	     * Brake
	     */
	    MOTOR_DIRECTION_BRAKING: 3,
	
	    /**
	     * Helper for getting the enum  - if the value is not one of the supported values - MOTOR_DIRECTION_DRIFTING is
	     * returned
	     * @param {number} value
	     * @return {number}
	     */
	    fromInteger: function fromInteger(value) {
	        switch (parseInt(value)) {
	            case this.MOTOR_DIRECTION_DRIFTING:
	                return this.MOTOR_DIRECTION_DRIFTING;
	            case this.MOTOR_DIRECTION_LEFT:
	                return this.MOTOR_DIRECTION_LEFT;
	            case this.MOTOR_DIRECTION_RIGHT:
	                return this.MOTOR_DIRECTION_RIGHT;
	            case this.MOTOR_DIRECTION_BRAKING:
	                return this.MOTOR_DIRECTION_BRAKING;
	            default:
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('Reached default case when trying to determine MotorDirection for value: ' + value + ' direction set to ' + this.MOTOR_DIRECTION_DRIFTING);
	                }
	                return this.MOTOR_DIRECTION_DRIFTING;
	        }
	    }
	};
	
	/**
	 * The SimpleMotor can be used for controlling a motor connected to the hub.
	 *
	 * Note that there will be one instance of the SimpleMotor per connected motor.
	 */
	
	var SimpleMotor = function (_LegoService) {
	    (0, _inherits3.default)(SimpleMotor, _LegoService);
	
	    /**
	     * @ignore
	     * @param {ConnectInfo} connectInfo
	     * @param {BluetoothIO} io
	     */
	
	    // Only send values in the range 35-100.
	    // An offset is needed as values below 35 is not enough power to actually make the motor turn.
	    /**
	     * @private
	     * @type {number}
	     */
	
	    /**
	     * @private
	     * @type {number}
	     */
	
	
	    /**
	     * @private
	     * @type {number}
	     */
	    function SimpleMotor(connectInfo, io) {
	        (0, _classCallCheck3.default)(this, SimpleMotor);
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, (SimpleMotor.__proto__ || (0, _getPrototypeOf2.default)(SimpleMotor)).call(this, connectInfo, io));
	
	        _this.mostRecentSendPower = SimpleMotor.MOTOR_POWER_BRAKE;
	        return _this;
	    }
	
	    /**
	     * Get the service name of the SimpleMotor service
	     * @return {string}
	     */
	
	    /**
	     * @private
	     * @type {string}
	     */
	
	    /**
	     * @private
	     * @type {number}
	     */
	
	    /**
	     * @private
	     * @type {number}
	     */
	
	
	    (0, _createClass3.default)(SimpleMotor, [{
	        key: 'getServiceName',
	        value: function getServiceName() {
	            return SimpleMotor.SERVICE_MOTOR_NAME;
	        }
	
	        /**
	         * Get the current motor power
	         * @return {number}
	         */
	
	    }, {
	        key: 'getPower',
	        value: function getPower() {
	            if (this.isBraking() || this.isDrifting()) {
	                return 0;
	            }
	            return Math.abs(this.mostRecentSendPower);
	        }
	
	        /**
	         * Get the direction the motor is rotating
	         * @return {number|*} - See {@link MotorDirection} for the valid values
	         */
	
	    }, {
	        key: 'getDirection',
	        value: function getDirection() {
	            return this.getDirectionForPower(this.mostRecentSendPower);
	        }
	
	        /**
	         * Return if the motor is braking
	         * @return {boolean} - True if the motor is braking, false otherwise
	         */
	
	    }, {
	        key: 'isBraking',
	        value: function isBraking() {
	            return this.mostRecentSendPower === SimpleMotor.MOTOR_POWER_BRAKE;
	        }
	
	        /**
	         * Return if the motor is drifting
	         * @return {boolean} - True if the motor is drifting, false otherwise
	         */
	
	    }, {
	        key: 'isDrifting',
	        value: function isDrifting() {
	            return this.mostRecentSendPower === SimpleMotor.MOTOR_POWER_DRIFT;
	        }
	
	        /**
	         * Set the motor power and run it in the specified direction
	         * @param {number} direction - See {@link MotorDirection} for the valid values
	         * @param {number} power - A value between 1 and 100 - the higher the value the faster the motor turns.
	         */
	
	    }, {
	        key: 'run',
	        value: function run(direction, power) {
	            var checkedPower = Math.min(Math.abs(Math.round(power)), SimpleMotor.MOTOR_MAX_SPEED);
	            if (checkedPower === SimpleMotor.MOTOR_POWER_DRIFT) {
	                this.drift();
	            } else {
	                this.sendPower(this.convertUnsignedMotorPowerToSigned(checkedPower, direction));
	            }
	        }
	
	        /**
	         * Stop the motor
	         */
	
	    }, {
	        key: 'brake',
	        value: function brake() {
	            this.sendPower(SimpleMotor.MOTOR_POWER_BRAKE);
	        }
	
	        /**
	         * Make the motor drift
	         */
	
	    }, {
	        key: 'drift',
	        value: function drift() {
	            this.sendPower(SimpleMotor.MOTOR_POWER_DRIFT);
	        }
	
	        /**
	         * @ignore
	         * Set the motor power directly
	         *
	         * @param {number} power - If power === SimpleMotor.MOTOR_POWER_BRAKE (127) or power === SimpleMotor.MOTOR_POWER_DRIFT (0), the motor will stop. If power is a positive int the motor will rotate to the right, if negative it will rotate left.
	         */
	
	    }, {
	        key: 'sendPower',
	        value: function sendPower(power) {
	            if (this.mostRecentSendPower === power) {
	                // LECQA-91: To prevent overloading the hub with writeMotorPower requests in a loop sending the same value
	                // continously
	                return;
	            }
	            var directionForPower = this.getDirectionForPower(power);
	            var outputCommand = void 0;
	            if (power === SimpleMotor.MOTOR_POWER_BRAKE || power === SimpleMotor.MOTOR_POWER_DRIFT) {
	                // Brake and Float should not be affected by the offset
	                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                    _LDSDKLogger2.default.info('SimpleMotor :: this.io.writeMotorPower(power, offset, this.connectInfo.getConnectId()) --- power: ' + power + ', offset: 0, connectId: ' + this.connectInfo.getConnectId() + ' -- stopping motor');
	                }
	                outputCommand = this.io.writeMotorPower(power, 0, this.connectInfo.getConnectId());
	            } else {
	                var absolutePower = Math.min(Math.abs(Math.round(power)), SimpleMotor.MOTOR_MAX_SPEED);
	                if (MotorDirection.MOTOR_DIRECTION_LEFT === directionForPower) {
	                    // Power must be a negative value for the motor to turn counter clockwise
	                    power = -absolutePower;
	                } else if (MotorDirection.MOTOR_DIRECTION_RIGHT === directionForPower) {
	                    // Power must be a positive value for the motor to turn clockwise
	                    power = absolutePower;
	                }
	
	                var offset = 0;
	                try {
	                    if (this.getDevice().getDeviceInfo().getFirmwareRevision().getMajorVersion() >= 1) {
	                        // On version 0.x of the firmware, PVM offset is handled in the firmware
	                        offset = SimpleMotor.MOTOR_POWER_OFFSET;
	                    }
	                } catch (e) {}
	                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                    _LDSDKLogger2.default.info('SimpleMotor :: this.io.writeMotorPower(power, offset, this.connectInfo.getConnectId()) --- power: ' + power + ', offset: ' + offset + ', connectId: ' + this.connectInfo.getConnectId() + '  (absolutePower value: ' + absolutePower + ')');
	                }
	                outputCommand = this.io.writeMotorPower(power, offset, this.connectInfo.getConnectId());
	            }
	
	            this.mostRecentSendPower = power;
	
	            try {
	                this.handleUpdatedValueData(outputCommand.getData());
	            } catch (e) {
	                _LDSDKLogger2.default.error(e);
	            }
	        }
	
	        /**
	         * @ignore
	         *
	         * @param {number} power
	         * @param {number} direction
	         * @return {number}
	         */
	
	    }, {
	        key: 'convertUnsignedMotorPowerToSigned',
	        value: function convertUnsignedMotorPowerToSigned(power, direction) {
	            var resultPower = Math.min(power, SimpleMotor.MOTOR_MAX_SPEED);
	
	            var directionEnum = direction;
	            if (typeof directionEnum === 'number') {
	                directionEnum = MotorDirection.fromInteger(direction);
	            }
	            if (directionEnum === MotorDirection.MOTOR_DIRECTION_LEFT) {
	                resultPower = -resultPower;
	            }
	
	            return resultPower;
	        }
	
	        /**
	         * @ignore
	         *
	         * Get the direction based on the power
	         * @param {number} power - A signed power value
	         * @return {number} direction - One of the MotorDirection values [MOTOR_DIRECTION_DRIFTING, MOTOR_DIRECTION_BRAKING, MOTOR_DIRECTION_RIGHT, MOTOR_DIRECTION_LEFT]
	         */
	
	    }, {
	        key: 'getDirectionForPower',
	        value: function getDirectionForPower(power) {
	            var directionForPower = void 0;
	            if (SimpleMotor.MOTOR_POWER_DRIFT === power) {
	                directionForPower = MotorDirection.MOTOR_DIRECTION_DRIFTING;
	            } else if (SimpleMotor.MOTOR_POWER_BRAKE === power) {
	                directionForPower = MotorDirection.MOTOR_DIRECTION_BRAKING;
	            } else if (power > 0) {
	                directionForPower = MotorDirection.MOTOR_DIRECTION_RIGHT;
	            } else if (power < 0) {
	                directionForPower = MotorDirection.MOTOR_DIRECTION_LEFT;
	            } else {
	                directionForPower = MotorDirection.MOTOR_DIRECTION_DRIFTING;
	                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                    _LDSDKLogger2.default.info('simpleMotor.getDirectionFromPower --- unsupported power value: ' + power + ' --- returning MOTOR_DIRECTION_DRIFTING: ' + directionForPower);
	                }
	            }
	            return directionForPower;
	        }
	
	        /*
	            getDefaultInputFormat() {
	                return InputFormat.inputFormat(this.getConnectInfo().getConnectId(), this.getConnectInfo().getType(), 0, 30, InputFormatUnit.SI, true);
	            }
	        */
	
	        /**
	         * Return a simple representation of the service
	         * @return {{deviceId: string, isInternalService: boolean, serviceName: string, serviceData: ({}|*), numberValue: number, updateInputFormat: simpleService.updateInputFormat, handleUpdatedInputFormat: simpleService.handleUpdatedInputFormat}}
	         */
	
	    }, {
	        key: 'getSimpleService',
	        value: function getSimpleService() {
	            var superService = (0, _get3.default)(SimpleMotor.prototype.__proto__ || (0, _getPrototypeOf2.default)(SimpleMotor.prototype), 'getSimpleService', this).call(this);
	            var self = this;
	            superService['numberValue'] = this.getPower(); // LECQA-89 and LECQA-90: Use the getPower() value when sending
	            superService['run'] = function (direction, power) {
	                self.run(direction, power);
	            };
	            superService['brake'] = function () {
	                self.brake();
	            };
	            superService['drift'] = function () {
	                self.drift();
	            };
	            return superService;
	        }
	
	        /**
	         * Get the simple service data for use in the service callback handler
	         * @return {{power: number}}
	         */
	
	    }, {
	        key: 'getSimpleServiceData',
	        value: function getSimpleServiceData() {
	            return {
	                power: this.getPower()
	            };
	        }
	
	        /**
	         * @ignore
	         * Create an instance of the service
	         * @param {ConnectInfo} connectInfo
	         * @param {BluetoothIO} io
	         * @return {SimpleMotor}
	         */
	
	    }], [{
	        key: 'createService',
	        value: function createService(connectInfo, io) {
	            return new SimpleMotor(connectInfo, io);
	        }
	    }]);
	    return SimpleMotor;
	}(_LegoService3.default);
	
	SimpleMotor.MOTOR_MIN_SPEED = 1;
	SimpleMotor.MOTOR_MAX_SPEED = 100;
	SimpleMotor.MOTOR_POWER_DRIFT = 0;
	SimpleMotor.MOTOR_POWER_BRAKE = 127;
	SimpleMotor.MOTOR_POWER_OFFSET = 35;
	SimpleMotor.SERVICE_MOTOR_NAME = 'Motor';
	exports.default = SimpleMotor;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.TiltSensorCrash = exports.TiltSensorAngle = exports.TiltSensorMode = exports.TiltSensorDirection = undefined;
	
	var _getPrototypeOf = __webpack_require__(5);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _possibleConstructorReturn2 = __webpack_require__(7);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get2 = __webpack_require__(23);
	
	var _get3 = _interopRequireDefault(_get2);
	
	var _inherits2 = __webpack_require__(6);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _LegoService2 = __webpack_require__(18);
	
	var _LegoService3 = _interopRequireDefault(_LegoService2);
	
	var _DataFormat = __webpack_require__(46);
	
	var _DataFormat2 = _interopRequireDefault(_DataFormat);
	
	var _InputFormat = __webpack_require__(22);
	
	var _InputFormat2 = _interopRequireDefault(_InputFormat);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 *
	 * @type {object} TiltSensorDirection
	 * @property {number} NEUTRAL
	 * @property {number} BACKWARD
	 * @property {number} RIGHT
	 * @property {number} LEFT
	 * @property {number} FORWARD
	 * @property {number} UNKNOWN
	 *
	 */
	/**
	 * Created by frj on 11/02/16.
	 */
	
	var TiltSensorDirection = exports.TiltSensorDirection = {
	    NEUTRAL: 0,
	
	    BACKWARD: 3,
	
	    RIGHT: 5,
	
	    LEFT: 7,
	
	    FORWARD: 9,
	
	    UNKNOWN: 10,
	
	    /**
	     * Helper for getting the enum  - if the value is not one of the supported values - UNKNOWN is
	     * returned
	     * @param {number} value
	     * @return {number}
	     */
	    fromInteger: function fromInteger(value) {
	        switch (parseInt(value)) {
	            case 0:
	                return this.NEUTRAL;
	            case 3:
	                return this.BACKWARD;
	            case 5:
	                return this.RIGHT;
	            case 7:
	                return this.LEFT;
	            case 9:
	                return this.FORWARD;
	            case 10:
	            default:
	                _LDSDKLogger2.default.error('Reached default case when trying to determine TitlSensorDirection for value: ' + value + ' direction set to ' + this.UNKNOWN);
	                return this.UNKNOWN;
	        }
	    },
	
	    asString: function asString(value) {
	        switch (parseInt(value)) {
	            case this.NEUTRAL:
	                return 'NEUTRAL';
	            case this.BACKWARD:
	                return 'BACKWARD';
	            case this.RIGHT:
	                return 'RIGHT';
	            case this.LEFT:
	                return 'LEFT';
	            case this.FORWARD:
	                return 'FORWARD';
	            case this.UNKNOWN:
	            default:
	                _LDSDKLogger2.default.error('Reached default case when trying to determine TitlSensorDirection for value: ' + value + ' direction set to ' + this.UNKNOWN);
	                return 'UNKNOWN';
	        }
	    }
	
	};
	
	/**
	 *
	 * @type {object} TiltSensorMode
	 * @property {number} ANGLE - Angle mode
	 * @property {number} TILT - Tilt mode
	 * @property {number} CRASH - Crash mode
	 * @property {number} UNKNOWN - Unknown mode
	 */
	var TiltSensorMode = exports.TiltSensorMode = {
	    ANGLE: 0,
	
	    TILT: 1,
	
	    CRASH: 2,
	
	    UNKNOWN: 4,
	
	    /**
	     * Helper for getting the enum  - if the value is not one of the supported values - UNKNOWN is
	     * returned
	     * @param {number} value
	     * @return {number}
	     */
	    fromInteger: function fromInteger(value) {
	        switch (parseInt(value)) {
	            case 0:
	                return this.ANGLE;
	            case 1:
	                return this.TILT;
	            case 2:
	                return this.CRASH;
	            case 3:
	            default:
	                _LDSDKLogger2.default.error('Reached default case when trying to determine TiltSensorMode for value: ' + value + ' mode set to ' + this.UNKNOWN);
	                return this.UNKNOWN;
	        }
	    },
	
	    asString: function asString(value) {
	        switch (parseInt(value)) {
	            case this.ANGLE:
	                return 'ANGLE';
	            case this.TILT:
	                return 'TILT';
	            case this.CRASH:
	                return 'CRASH';
	            case this.UNKNOWN:
	            default:
	                _LDSDKLogger2.default.error('Reached default case when trying to determine TiltSensorMode for value: ' + value + ' mode set to ' + this.UNKNOWN);
	                return 'UNKNOWN';
	        }
	    }
	};
	
	/**
	 * Value object for holding a tilt sensor angle measurement as (x, y).
	 *
	 */
	
	var TiltSensorAngle = exports.TiltSensorAngle = function () {
	    function TiltSensorAngle() {
	        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.0;
	        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;
	        (0, _classCallCheck3.default)(this, TiltSensorAngle);
	
	        /**
	         * X value
	         * @type {number}
	         */
	        this.x = x;
	        /**
	         * Y value
	         * @type {number}
	         */
	        this.y = y;
	    }
	
	    (0, _createClass3.default)(TiltSensorAngle, [{
	        key: 'toString',
	        value: function toString() {
	            return '[' + this.x + ', ' + this.y + ']';
	        }
	    }]);
	    return TiltSensorAngle;
	}();
	
	/**
	 * Value object for holding tilt sensor crash counts as (x, y, z)
	 */
	
	
	var TiltSensorCrash = exports.TiltSensorCrash = function () {
	    function TiltSensorCrash() {
	        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	        var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	        (0, _classCallCheck3.default)(this, TiltSensorCrash);
	
	        /**
	         * Crash count in the X axis
	         * @type {number}
	         */
	        this.x = x;
	        /**
	         * Crash count in the Y axis
	         * @type {number}
	         */
	        this.y = y;
	        /**
	         * Crash count in the Z axis
	         * @type {number}
	         */
	        this.z = z;
	    }
	
	    (0, _createClass3.default)(TiltSensorCrash, [{
	        key: 'toString',
	        value: function toString() {
	            return '[' + this.x + ', ' + this.y + ', ' + this.z + ']';
	        }
	    }]);
	    return TiltSensorCrash;
	}();
	
	/**
	 * The tilt sensor can be used for measuring tilt angle and crash count.
	 *
	 * Note that there will be one instance of the TiltSensor per connected tilt sensor.
	 */
	
	
	var TiltSensor = function (_LegoService) {
	    (0, _inherits3.default)(TiltSensor, _LegoService);
	    (0, _createClass3.default)(TiltSensor, null, [{
	        key: 'tiltSensorAngleMake',
	
	
	        /**
	         * Create a new TiltSensorAngle instance
	         * @param {number} x
	         * @param {number} y
	         * @return {TiltSensorAngle}
	         */
	        value: function tiltSensorAngleMake(x, y) {
	            return new TiltSensorAngle(x, y);
	        }
	
	        /**
	         * Construct a new TiltSensorCrash instance
	         * @param {number} x
	         * @param {number} y
	         * @param {number} z
	         * @return {TiltSensorCrash}
	         */
	
	    }, {
	        key: 'tiltSensorCrashMake',
	        value: function tiltSensorCrashMake(x, y, z) {
	            return new TiltSensorCrash(x, y, z);
	        }
	
	        /**
	         * Check if the two TiltSensorAngles are equal (acceptable diff is 0.01 - see the source code for details)
	         *
	         * @param {TiltSensorAngle} angle1
	         * @param {TiltSensorAngle} angle2
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'tiltSensorAngleEqualToAngle',
	        value: function tiltSensorAngleEqualToAngle(angle1, angle2) {
	            var acceptableDiff = 0.01;
	            return angle1.x - angle2.x < acceptableDiff && angle1.y - angle2.y < acceptableDiff;
	        }
	
	        /**
	         * Check if two crash instances are equal
	         * @param {TiltSensorCrash} crash1
	         * @param {TiltSensorCrash} crash2
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'tiltSensorCrashEqualToCrash',
	        value: function tiltSensorCrashEqualToCrash(crash1, crash2) {
	            return crash1.x === crash2.x && crash1.y === crash2.y && crash1.z === crash2.z;
	        }
	
	        /**
	         * @ignore
	         *
	         * @param {ConnectInfo} connectInfo
	         * @param {BluetoothIO} io
	         */
	
	    }]);
	
	    function TiltSensor(connectInfo, io) {
	        (0, _classCallCheck3.default)(this, TiltSensor);
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, (TiltSensor.__proto__ || (0, _getPrototypeOf2.default)(TiltSensor)).call(this, connectInfo, io));
	
	        _this.SERVICE_TILT_SENSOR_NAME = 'Tilt Sensor';
	
	        _this.addValidDataFormats();
	        return _this;
	    }
	
	    /**
	     * Get the service name for the tilt sensor
	     * @return {string}
	     */
	
	
	    (0, _createClass3.default)(TiltSensor, [{
	        key: 'getServiceName',
	        value: function getServiceName() {
	            return this.SERVICE_TILT_SENSOR_NAME;
	        }
	    }, {
	        key: 'getDirection',
	
	
	        /**
	         * Get the most recent direction reading from the sensor.
	         *
	         * If no direction reading has been received, of if the sensor is not in mode {@link TiltSensorMode.TILT}
	         * the return value of this method will be {@link TiltSensorDirection.UNKNOWN}.
	         * @return {number} - See {@link TiltSensorDirection} for valid values
	         */
	        value: function getDirection() {
	            if (this.getInputFormat() === null || this.getInputFormat().getMode() !== TiltSensorMode.TILT) {
	                return TiltSensorDirection.UNKNOWN;
	            }
	
	            var directionInt = this.getNumberFromValueData();
	            if (directionInt === null) {
	                return TiltSensorDirection.UNKNOWN;
	            }
	
	            if (directionInt < 10) {
	                return TiltSensorDirection.fromInteger(directionInt);
	            } else {
	                return TiltSensorDirection.UNKNOWN;
	            }
	        }
	
	        /**
	         * The most recent angle reading from the sensor. The angle represents the angle the sensor is tilted in the x, y and z-direction.
	         * <p/>
	         * If no angle reading has been received, of if the sensor is not in mode {@link TiltSensorMode#ANGLE}
	         * the return value of this method will be a {@link TiltSensorAngle}
	         * @return {TiltSensorAngle} - The angle of the tilt sensor
	         */
	
	    }, {
	        key: 'getAngle',
	        value: function getAngle() {
	            if (this.getInputFormat() === null || this.getInputFormat().getMode() !== TiltSensorMode.ANGLE) {
	                return new TiltSensorAngle();
	            }
	
	            var dataSetNumbers = this.getNumbersFromValueDataSet(this.valueData);
	            if (dataSetNumbers !== null && dataSetNumbers.length === 2) {
	                return TiltSensor.tiltSensorAngleMake(dataSetNumbers[0], dataSetNumbers[1]);
	            }
	            return new TiltSensorAngle();
	        }
	
	        /**
	         * The most recent crash reading from the sensor. The value represents the number of times the sensor has been 'bumped' in
	         * the x, y, and z-direction. The value can be reset by sending the {@link LegoService#sendResetStateRequest}.
	         * <p/>
	         * If no angle reading has been received, or if the sensor is not in mode {@link TiltSensorMode#CRASH}
	         * the return value of this method will be a {@link TiltSensorCrash} instance with 0 as value for both x, y and z.
	         * @return {TiltSensorCrash}
	         */
	
	    }, {
	        key: 'getCrash',
	        value: function getCrash() {
	            if (this.getInputFormat() === null || this.getInputFormat().getMode() !== TiltSensorMode.CRASH) {
	                return new TiltSensorCrash();
	            }
	
	            var dataSetNumbers = this.getNumbersFromValueDataSet(this.valueData);
	            if (dataSetNumbers !== null && dataSetNumbers.length === 3) {
	                return TiltSensor.tiltSensorCrashMake(dataSetNumbers[0] & 255, dataSetNumbers[1] & 255, dataSetNumbers[2] & 255);
	            }
	            return new TiltSensorCrash();
	        }
	
	        /**
	         * Get the current Tilt sensor mode
	         * @return {number} - @see {@link TiltSensorMode}
	         */
	
	    }, {
	        key: 'getTiltSensorMode',
	        value: function getTiltSensorMode() {
	            return TiltSensorMode.fromInteger(this.getInputFormatMode());
	        }
	
	        /**
	         * Set the current tilt sensor mode
	         * @param {number} tiltSensorMode - @see {@link TiltSensorMode}
	         */
	
	    }, {
	        key: 'setTiltSensorMode',
	        value: function setTiltSensorMode(tiltSensorMode) {
	            this.updateCurrentInputFormatWithNewMode(tiltSensorMode);
	        }
	
	        /**
	         * @ignore
	         * Add the valid data formats for the Tilt sensor
	         */
	
	    }, {
	        key: 'addValidDataFormats',
	        value: function addValidDataFormats() {
	            this.addValidDataFormat(_DataFormat2.default.create('Angle', TiltSensorMode.ANGLE, _InputFormat.InputFormatUnit.RAW, 1, 2));
	            this.addValidDataFormat(_DataFormat2.default.create('Angle', TiltSensorMode.ANGLE, _InputFormat.InputFormatUnit.PERCENTAGE, 1, 2));
	            this.addValidDataFormat(_DataFormat2.default.create('Angle', TiltSensorMode.ANGLE, _InputFormat.InputFormatUnit.SI, 4, 2));
	
	            this.addValidDataFormat(_DataFormat2.default.create('Tilt', TiltSensorMode.TILT, _InputFormat.InputFormatUnit.RAW, 1, 1));
	            this.addValidDataFormat(_DataFormat2.default.create('Tilt', TiltSensorMode.TILT, _InputFormat.InputFormatUnit.PERCENTAGE, 1, 1));
	            this.addValidDataFormat(_DataFormat2.default.create('Tilt', TiltSensorMode.TILT, _InputFormat.InputFormatUnit.SI, 4, 1));
	
	            this.addValidDataFormat(_DataFormat2.default.create('Crash', TiltSensorMode.CRASH, _InputFormat.InputFormatUnit.RAW, 1, 3));
	            this.addValidDataFormat(_DataFormat2.default.create('Crash', TiltSensorMode.CRASH, _InputFormat.InputFormatUnit.PERCENTAGE, 1, 3));
	            this.addValidDataFormat(_DataFormat2.default.create('Crash', TiltSensorMode.CRASH, _InputFormat.InputFormatUnit.SI, 4, 3));
	        }
	
	        /**
	         * Get default inputformat for {@link TiltSensor}
	         * @return {InputFormat}
	         */
	
	    }, {
	        key: 'getDefaultInputFormat',
	        value: function getDefaultInputFormat() {
	            return _InputFormat2.default.inputFormat((0, _get3.default)(TiltSensor.prototype.__proto__ || (0, _getPrototypeOf2.default)(TiltSensor.prototype), 'getConnectInfo', this).call(this).getConnectId(), (0, _get3.default)(TiltSensor.prototype.__proto__ || (0, _getPrototypeOf2.default)(TiltSensor.prototype), 'getConnectInfo', this).call(this).getType(), // device type 34
	            TiltSensorMode.TILT, 1, _InputFormat.InputFormatUnit.SI, true);
	        }
	    }, {
	        key: 'handleUpdatedValueData',
	
	
	        /**
	         * @ignore
	         * Process updated value data as TiltSensor value
	         * @param {ArrayBuffer} valueData
	         */
	        value: function handleUpdatedValueData() {
	            var valueData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	
	            // Remember the old values before calling 'handleUpdatedValueData'
	            var oldDirection = this.getDirection();
	            var oldAngle = this.getAngle();
	            var oldCrash = this.getCrash();
	
	            (0, _get3.default)(TiltSensor.prototype.__proto__ || (0, _getPrototypeOf2.default)(TiltSensor.prototype), 'handleUpdatedValueData', this).call(this, valueData);
	
	            var mode = this.getTiltSensorMode();
	            if (mode === TiltSensorMode.TILT) {
	                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                    _LDSDKLogger2.default.trace(this.getServiceName() + ' TILT :: this.getDirection = ' + this.getDirection());
	                }
	                this.callbackHelper.performDidUpdateTiltDirection(this, oldDirection, this.getDirection());
	            } else if (mode === TiltSensorMode.ANGLE) {
	                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                    _LDSDKLogger2.default.trace(this.getServiceName() + ' ANGLE :: this.getAngle = ' + this.getAngle());
	                }
	                this.callbackHelper.performDidUpdateTiltAngle(this, oldAngle, this.getAngle());
	            } else if (mode === TiltSensorMode.CRASH) {
	                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                    _LDSDKLogger2.default.trace(this.getServiceName() + ' CRASH :: this.getCrash = ' + this.getCrash());
	                }
	                this.callbackHelper.performDidUpdateTiltCrash(this, oldCrash, this.getCrash());
	            } else {
	                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                    _LDSDKLogger2.default.info(this.getServiceName() + ' unknown mode: ' + mode);
	                }
	            }
	        }
	
	        /**
	         * @ignore
	         */
	
	    }, {
	        key: 'sendDefaultInputFormat',
	        value: function sendDefaultInputFormat() {}
	
	        /**
	         * Get the simple representation of the Tilt sensor for use in the service callback handler
	         * @return {{deviceId: string, isInternalService: boolean, serviceName: string, serviceData: ({}|*), numberValue: number, updateInputFormat: simpleService.updateInputFormat, handleUpdatedInputFormat: simpleService.handleUpdatedInputFormat}}
	         */
	
	    }, {
	        key: 'getSimpleService',
	        value: function getSimpleService() {
	            var superService = (0, _get3.default)(TiltSensor.prototype.__proto__ || (0, _getPrototypeOf2.default)(TiltSensor.prototype), 'getSimpleService', this).call(this);
	            var self = this;
	            superService['setTiltSensorMode'] = function (tiltSensorMode) {
	                self.setTiltSensorMode(tiltSensorMode);
	            };
	            return superService;
	        }
	
	        /**
	         * Get the simple service data representation for use in the service callback handler
	         * @return {{angle: TiltSensorAngle, crash: TiltSensorCrash, direction: TiltSensorDirection, tiltSensorMode: TiltSensorMode}}
	         */
	
	    }, {
	        key: 'getSimpleServiceData',
	        value: function getSimpleServiceData() {
	            return {
	                angle: this.getAngle(),
	                crash: this.getCrash(),
	                direction: this.getDirection(),
	                tiltSensorMode: this.getTiltSensorMode()
	            };
	        }
	    }], [{
	        key: 'createService',
	
	
	        /**
	         * @ignore
	         * Create a tilt service instance
	         * @param {ConnectInfo} connectInfo
	         * @param {BluetoothIO} io
	         * @return {TiltSensor}
	         */
	        value: function createService(connectInfo, io) {
	            return new TiltSensor(connectInfo, io);
	        }
	    }]);
	    return TiltSensor;
	}(_LegoService3.default);
	
	exports.default = TiltSensor;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getPrototypeOf = __webpack_require__(5);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(7);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _get2 = __webpack_require__(23);
	
	var _get3 = _interopRequireDefault(_get2);
	
	var _inherits2 = __webpack_require__(6);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _InputFormat = __webpack_require__(22);
	
	var _InputFormat2 = _interopRequireDefault(_InputFormat);
	
	var _LegoService2 = __webpack_require__(18);
	
	var _LegoService3 = _interopRequireDefault(_LegoService2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Service implementation handling voltage readings from the hub
	 */
	/**
	 * Created by frj on 11/02/16.
	 */
	
	var VoltageSensor = function (_LegoService) {
	    (0, _inherits3.default)(VoltageSensor, _LegoService);
	
	    /**
	     * @ignore
	     * @param {ConnectInfo} connectInfo
	     * @param {BluetoothIO} io
	     */
	    function VoltageSensor(connectInfo, io) {
	        (0, _classCallCheck3.default)(this, VoltageSensor);
	
	        /**
	         * @private
	         * @type {string}
	         */
	        var _this = (0, _possibleConstructorReturn3.default)(this, (VoltageSensor.__proto__ || (0, _getPrototypeOf2.default)(VoltageSensor)).call(this, connectInfo, io));
	
	        _this.SERVICE_VOLTAGE_SENSOR_NAME = 'Voltage Sensor';
	        return _this;
	    }
	
	    /**
	     * Get the service name for VoltageSensor
	     * @return {string}
	     */
	
	
	    (0, _createClass3.default)(VoltageSensor, [{
	        key: 'getServiceName',
	        value: function getServiceName() {
	            return this.SERVICE_VOLTAGE_SENSOR_NAME;
	        }
	
	        /**
	         * Get the default input format for the Voltage Sensor.
	         *
	         * Note: By default notifications are not enabled for the Voltage sensor as the measurements can fluctuate
	         * and cause a lot of BLE traffic. Enable notifications only if you need them.
	         * Use @link {InputFormat.inputFormatBySettingNotificationsEnabled} on the default input format to get an input format
	         * with notifications enabled and then update the input format for the voltage sensor using the {VoltageSensor.updateInputFormat}
	         *
	         * @return {InputFormat}
	         */
	
	    }, {
	        key: 'getDefaultInputFormat',
	        value: function getDefaultInputFormat() {
	            // Only one available mode for voltage sensor
	            return _InputFormat2.default.inputFormat(this.getConnectInfo().getConnectId(), this.getConnectInfo().getType(), 0, 30, _InputFormat.InputFormatUnit.SI, false);
	        }
	
	        /**
	         * @ignore
	         * Create a Voltage Sensor instance
	         * @param connectInfo
	         * @param io
	         * @return {VoltageSensor}
	         */
	
	    }, {
	        key: 'getValueAsMilliVolts',
	
	
	        /**
	         * Get the value as milli volts
	         * @return {number} - The voltage in millivolts
	         */
	        value: function getValueAsMilliVolts() {
	            if (this.inputFormat !== null && this.inputFormat.getMode() === 0 && this.inputFormat.getUnit() === _InputFormat.InputFormatUnit.SI) {
	                return this.getValueAsFloat();
	            } else {
	                // LDSDKLogger.warn('Can only retrieve milli volts from Voltage Sensor when sensor is in mode 0 and uses SI units');
	                return 0;
	            }
	        }
	
	        /**
	         * @ignore
	         * Handle an updated value from the sensor
	         * @param {ArrayBuffer} valueData
	         */
	
	    }, {
	        key: 'handleUpdatedValueData',
	        value: function handleUpdatedValueData() {
	            var valueData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	
	            (0, _get3.default)(VoltageSensor.prototype.__proto__ || (0, _getPrototypeOf2.default)(VoltageSensor.prototype), 'handleUpdatedValueData', this).call(this, valueData);
	            this.callbackHelper.performDidUpdateMilliVolts(this, this.getValueAsMilliVolts());
	        }
	
	        /**
	         * Get the simple service data for use in the service callback handler - see also @link {LegoService.getSimpleService}
	         * @return {{valueAsMilliVolts: number}}
	         */
	
	    }, {
	        key: 'getSimpleServiceData',
	        value: function getSimpleServiceData() {
	            return {
	                valueAsMilliVolts: this.getValueAsMilliVolts()
	            };
	        }
	    }], [{
	        key: 'createService',
	        value: function createService(connectInfo, io) {
	            return new VoltageSensor(connectInfo, io);
	        }
	    }]);
	    return VoltageSensor;
	}(_LegoService3.default);
	
	exports.default = VoltageSensor;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getPrototypeOf = __webpack_require__(5);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(7);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(6);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _BaseServiceDefinition = __webpack_require__(36);
	
	var _BaseServiceDefinition2 = _interopRequireDefault(_BaseServiceDefinition);
	
	var _CharacteristicDefinition = __webpack_require__(38);
	
	var _CharacteristicDefinition2 = _interopRequireDefault(_CharacteristicDefinition);
	
	var _UuidHelper = __webpack_require__(11);
	
	var _UuidHelper2 = _interopRequireDefault(_UuidHelper);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var BatteryServiceDefinition = function (_BaseServiceDefinitio) {
	    (0, _inherits3.default)(BatteryServiceDefinition, _BaseServiceDefinitio);
	
	    function BatteryServiceDefinition() {
	        (0, _classCallCheck3.default)(this, BatteryServiceDefinition);
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, (BatteryServiceDefinition.__proto__ || (0, _getPrototypeOf2.default)(BatteryServiceDefinition)).call(this));
	
	        _this.batteryLevel = -1;
	        return _this;
	    }
	
	    (0, _createClass3.default)(BatteryServiceDefinition, [{
	        key: 'init',
	        value: function init() {
	            this.serviceUUID = _UuidHelper2.default.getSpecUuid(BatteryServiceDefinition.BATTERY_SERVICE_UUID);
	            this.serviceName = 'BatteryService';
	
	            this.batteryLevel = new _CharacteristicDefinition2.default('InputValues', this, _UuidHelper2.default.getSpecUuid(BatteryServiceDefinition.BATTERY_LEVEL_CHARACTERISTIC_UUID), true, 0 /* (BluetoothHelper.Properties.PROPERTY_NOTIFY.ordinal() |
	                                                                                                                                                                                                  BluetoothHelper.Properties.PROPERTY_NOTIFY.ordinal()) */
	            , 0, 0 /* BluetoothHelper.Permissions.PERMISSION_READ.ordinal() */);
	
	            this.characteristicDefinitions.add(this.batteryLevel);
	        }
	    }, {
	        key: 'getBatteryLevel',
	        value: function getBatteryLevel() {
	            return this.batteryLevel;
	        }
	    }], [{
	        key: 'getInstance',
	        value: function getInstance() {
	            if (BatteryServiceDefinition.instance === null) {
	                BatteryServiceDefinition.instance = new BatteryServiceDefinition();
	                BatteryServiceDefinition.instance.init();
	            }
	            return BatteryServiceDefinition.instance;
	        }
	    }]);
	    return BatteryServiceDefinition;
	}(_BaseServiceDefinition2.default); /**
	                                     * Created by frj on 19/02/16.
	                                     */
	
	
	BatteryServiceDefinition.BATTERY_SERVICE_UUID = '180F';
	BatteryServiceDefinition.BATTERY_LEVEL_CHARACTERISTIC_UUID = '2A19';
	BatteryServiceDefinition.instance = null;
	exports.default = BatteryServiceDefinition;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(10).document && document.documentElement;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(15) && !__webpack_require__(34)(function(){
	  return Object.defineProperty(__webpack_require__(66)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(39);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(39);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ }),
/* 103 */
/***/ (function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(107)
	  , hiddenKeys = __webpack_require__(67).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ }),
/* 105 */
/***/ (function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(30)
	  , toObject    = __webpack_require__(77)
	  , IE_PROTO    = __webpack_require__(73)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(30)
	  , toIObject    = __webpack_require__(26)
	  , arrayIndexOf = __webpack_require__(147)(false)
	  , IE_PROTO     = __webpack_require__(73)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(16)
	  , core    = __webpack_require__(4)
	  , fails   = __webpack_require__(34);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(24);

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(10)
	  , core        = __webpack_require__(4)
	  , dP          = __webpack_require__(17)
	  , DESCRIPTORS = __webpack_require__(15)
	  , SPECIES     = __webpack_require__(8)('species');
	
	module.exports = function(KEY){
	  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(29)
	  , invoke             = __webpack_require__(155)
	  , html               = __webpack_require__(99)
	  , cel                = __webpack_require__(66)
	  , global             = __webpack_require__(10)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(39)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(50)
	  , ITERATOR  = __webpack_require__(8)('iterator')
	  , Iterators = __webpack_require__(35);
	module.exports = __webpack_require__(4).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ }),
/* 113 */
/***/ (function(module, exports) {

	module.exports = function arraybufferEqual (buf1, buf2) {
	  if (buf1 === buf2) {
	    return true;
	  }
	
	  if (buf1.byteLength !== buf2.byteLength) {
	    return false;
	  }
	
	  var view1 = new DataView(buf1);
	  var view2 = new DataView(buf2);
	
	  var i = buf1.byteLength;
	  while (i--) {
	    if (view1.getUint8(i) !== view2.getUint8(i)) {
	      return false;
	    }
	  }
	
	  return true;
	};


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _promise = __webpack_require__(12);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _stringify = __webpack_require__(19);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _map = __webpack_require__(9);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _getPrototypeOf = __webpack_require__(5);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _regenerator = __webpack_require__(14);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(13);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(7);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _inherits2 = __webpack_require__(6);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _IOServiceDefinition = __webpack_require__(48);
	
	var _IOServiceDefinition2 = _interopRequireDefault(_IOServiceDefinition);
	
	var _BluetoothHelper = __webpack_require__(62);
	
	var _BluetoothHelper2 = _interopRequireDefault(_BluetoothHelper);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	var _ByteUtils = __webpack_require__(116);
	
	var _ByteUtils2 = _interopRequireDefault(_ByteUtils);
	
	var _InputCommands = __webpack_require__(88);
	
	var _InputCommands2 = _interopRequireDefault(_InputCommands);
	
	var _OutputCommand = __webpack_require__(89);
	
	var _OutputCommand2 = _interopRequireDefault(_OutputCommand);
	
	var _InputFormat = __webpack_require__(22);
	
	var _InputFormat2 = _interopRequireDefault(_InputFormat);
	
	var _IO2 = __webpack_require__(120);
	
	var _IO3 = _interopRequireDefault(_IO2);
	
	var _StringUtils = __webpack_require__(21);
	
	var _StringUtils2 = _interopRequireDefault(_StringUtils);
	
	var _UuidHelper = __webpack_require__(11);
	
	var _UuidHelper2 = _interopRequireDefault(_UuidHelper);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by frj on 29/02/16.
	 */
	
	/**
	 * @ignore For internal use
	 * The BluetoothIO handles the communication for a specific service connected to the hub
	 */
	var BluetoothIO = function (_IO) {
	    (0, _inherits3.default)(BluetoothIO, _IO);
	    (0, _createClass3.default)(BluetoothIO, null, [{
	        key: 'bluetoothIO',
	
	
	        /**
	         * Create a new BluetoothIO instance, from the service and associatedDevice params.
	         *
	         * @param {NativeService} service
	         * @param {LegoBluetoothDeviceImpl} associatedDevice
	         * @return {BluetoothIO} BluetoothIO instance or null if any of the characteristics for the service are null.
	         */
	
	
	        /**
	         * @private
	         * @type {Map}
	         */
	        value: function () {
	            var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(service, associatedDevice) {
	                var serviceDefinition, inputValueCharacteristic, inputFormatCharacteristic, inputCommandCharacteristic, outputCommandCharacteristic;
	                return _regenerator2.default.wrap(function _callee$(_context) {
	                    while (1) {
	                        switch (_context.prev = _context.next) {
	                            case 0:
	                                if (!(service === null || service === undefined)) {
	                                    _context.next = 2;
	                                    break;
	                                }
	
	                                throw new Error('Cannot create BluetoothIO with null service');
	
	                            case 2:
	                                serviceDefinition = _IOServiceDefinition2.default.getInstance();
	                                _context.next = 5;
	                                return _BluetoothHelper2.default.create(serviceDefinition.getInputValue().getUuid(), service);
	
	                            case 5:
	                                inputValueCharacteristic = _context.sent;
	                                _context.next = 8;
	                                return _BluetoothHelper2.default.create(serviceDefinition.getInputFormat().getUuid(), service);
	
	                            case 8:
	                                inputFormatCharacteristic = _context.sent;
	                                _context.next = 11;
	                                return _BluetoothHelper2.default.create(serviceDefinition.getInputCommand().getUuid(), service);
	
	                            case 11:
	                                inputCommandCharacteristic = _context.sent;
	                                _context.next = 14;
	                                return _BluetoothHelper2.default.create(serviceDefinition.getOutputCommand().getUuid(), service);
	
	                            case 14:
	                                outputCommandCharacteristic = _context.sent;
	
	                                if (!(inputValueCharacteristic === null || inputFormatCharacteristic === null || inputCommandCharacteristic === null || outputCommandCharacteristic === null)) {
	                                    _context.next = 18;
	                                    break;
	                                }
	
	                                _LDSDKLogger2.default.error('IOService missing mandatory characteristic. inputValueCharacteristic: ' + _StringUtils2.default.getCharacteristicString(inputValueCharacteristic) + ', inputFormatCharacteristic: ' + _StringUtils2.default.getCharacteristicString(inputFormatCharacteristic) + ', inputCommandCharacteristic: ' + _StringUtils2.default.getCharacteristicString(inputCommandCharacteristic) + ', outputCommandCharacteristic: ' + _StringUtils2.default.getCharacteristicString(outputCommandCharacteristic));
	                                return _context.abrupt('return', null);
	
	                            case 18:
	                                _context.next = 20;
	                                return associatedDevice.setCharacteristicNotification(inputValueCharacteristic, true);
	
	                            case 20:
	                                _context.next = 22;
	                                return associatedDevice.setCharacteristicNotification(inputFormatCharacteristic, true);
	
	                            case 22:
	                                return _context.abrupt('return', new BluetoothIO(service, associatedDevice, serviceDefinition, inputValueCharacteristic, inputFormatCharacteristic, inputCommandCharacteristic, outputCommandCharacteristic));
	
	                            case 23:
	                            case 'end':
	                                return _context.stop();
	                        }
	                    }
	                }, _callee, this);
	            }));
	
	            function bluetoothIO(_x, _x2) {
	                return _ref.apply(this, arguments);
	            }
	
	            return bluetoothIO;
	        }()
	
	        /**
	         * @ignore
	         * @constructs
	         * @param {NativeService} service
	         * @param {LegoBluetoothDeviceImpl} associatedDevice
	         * @param {IOServiceDefinition} ioServiceDefinition
	         * @param {NativeCharacteristic} inputValueCharacteristic
	         * @param {NativeCharacteristic} inputFormatCharacteristic
	         * @param {NativeCharacteristic} inputCommandCharacteristic
	         * @param {NativeCharacteristic} outputCommandCharacteristic
	         */
	
	
	        /**
	         * @private
	         * @type {number}
	         */
	
	    }]);
	
	    function BluetoothIO(service, associatedDevice, ioServiceDefinition, inputValueCharacteristic, inputFormatCharacteristic, inputCommandCharacteristic, outputCommandCharacteristic) {
	        (0, _classCallCheck3.default)(this, BluetoothIO);
	
	        /**
	         * @private
	         * @type {IOServiceDefinition|null}
	         */
	        var _this = (0, _possibleConstructorReturn3.default)(this, (BluetoothIO.__proto__ || (0, _getPrototypeOf2.default)(BluetoothIO)).call(this));
	
	        _this.service = null;
	        _this.inputValueCharacteristic = null;
	        _this.inputFormatCharacteristic = null;
	        _this.inputCommandCharacteristic = null;
	        _this.outputCommandCharacteristic = null;
	        _this.serviceDefinition = null;
	        _this.inputFormats = new _map2.default();
	        _this.receivedMessagesCounter = 0;
	        _this.serviceDefinition = ioServiceDefinition;
	
	        /**
	         * @private
	         * @type {NativeCharacteristic|null}
	         */
	        _this.inputValueCharacteristic = inputValueCharacteristic;
	
	        /**
	         * @private
	         * @type {NativeCharacteristic|null}
	         */
	        _this.inputFormatCharacteristic = inputFormatCharacteristic;
	
	        /**
	         * @private
	         * @type {NativeCharacteristic|null}
	         */
	        _this.inputCommandCharacteristic = inputCommandCharacteristic;
	
	        /**
	         * @private
	         * @type {NativeCharacteristic|null}
	         */
	        _this.outputCommandCharacteristic = outputCommandCharacteristic;
	
	        /**
	         * @private
	         * @type {CurrentSensor|GenericService|MotionSensor|PiezoTonePlayer|RGBLight|SimpleMotor|TiltSensor|VoltageSensor|null}
	         */
	        _this.service = service;
	
	        /**
	         * @private
	         * @type {LegoBluetoothDeviceImpl}
	         */
	        _this.associatedDevice = associatedDevice;
	
	        /**
	         * @private
	         * @type {number}
	         */
	        _this.receivedMessagesCounter = 0;
	
	        return _this;
	    }
	
	    /**
	     * Check if the associated device is connected
	     * @return {boolean}
	     */
	
	
	    (0, _createClass3.default)(BluetoothIO, [{
	        key: 'isDeviceConnected',
	        value: function isDeviceConnected() {
	            return this.associatedDevice.getBluetoothWrapper().isConnected();
	        }
	
	        /**
	         * @ignore
	         * Increments the counter for received messages
	         */
	
	    }, {
	        key: 'incrementReceivedMessages',
	        value: function incrementReceivedMessages() {
	            this.receivedMessagesCounter++;
	        }
	
	        /**
	         * Get the received message count
	         * @return {number}
	         */
	
	    }, {
	        key: 'getReceivedMessagesCount',
	        value: function getReceivedMessagesCount() {
	            return this.receivedMessagesCounter;
	        }
	
	        /**
	         * Add a write of characteristic to the queue to get the value for the sensor connected to connectId
	         * @param {number} connectId - The connectId of the service we wish to read the value for
	         */
	
	    }, {
	        key: 'readValueForConnectId',
	        value: function readValueForConnectId(connectId) {
	            this.writeInputCommand(_InputCommands2.default.commandReadValueForConnectId(connectId));
	        }
	
	        /**
	         * Reset the state for the connectId by sending {0x44, 0x11, 0xAA} to the connected peripheral
	         * @param {number} connectId - The connectId of the device we wish to reset the state for
	         */
	
	    }, {
	        key: 'resetStateForConnectId',
	        value: function resetStateForConnectId(connectId) {
	            // Byte sequence sent to sensor to reset any state (for instance, crash-count for tilt sensor)
	            var resetBytes = new Uint8Array([68, 17, 170]); // {0x44, 0x11, 0xAA};
	            this.writeData(resetBytes, connectId);
	        }
	
	        /**
	         * Add a write inputformat command to the queue.
	         * @param {InputFormat} inputFormat - The inputformat to write to the device
	         * @param {number} connectId - The connectId of the device we wish to update the InputFormat for
	         */
	
	    }, {
	        key: 'writeInputFormat',
	        value: function writeInputFormat(inputFormat, connectId) {
	            this.writeInputCommand(_InputCommands2.default.commandWriteInputFormat(inputFormat, connectId));
	        }
	
	        /**
	         * Reads the inputformat for the given connectId by writing a command with InputCommand.COMMAND_TYPE_READ to the hub
	         * @param {number} connectId - The connectId for the device to read the inputFormat for
	         */
	
	    }, {
	        key: 'readInputFormatForConnectId',
	        value: function readInputFormatForConnectId(connectId) {
	            this.writeInputCommand(_InputCommands2.default.commandReadInputFormatForConnectId(connectId));
	        }
	
	        /**
	         * Adds a WriteInputCommand operation to the queue
	         * @param {InputCommand} command - Generic input command to write
	         */
	
	    }, {
	        key: 'writeInputCommand',
	        value: function writeInputCommand(command) {
	            if (this.isDeviceConnected()) {
	                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                    _LDSDKLogger2.default.info('Writing Input Command: ', _ByteUtils2.default.bytesToHex(command.getData()));
	                }
	                this.associatedDevice.addWriteOfCharacteristicToQueue(this.inputCommandCharacteristic, command.getData());
	            } else {
	                if (_LDSDKLogger2.default.isInfoEnabled()) {
	                    _LDSDKLogger2.default.info('isDeviceConnected returns false for ' + this.associatedDevice.getAddress() + ' - not adding write of characteristic to queue');
	                }
	            }
	        }
	
	        /**
	         * Adds a writeMotorPower command to the queue
	         *
	         * @param {number} power - The speed of rotation
	         * @param {number} offset - An offset to add to the power
	         * @param {number} connectId - The connectId of the motor
	         * @return {OutputCommand}
	         */
	
	    }, {
	        key: 'writeMotorPower',
	        value: function writeMotorPower(power) {
	            var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	            var connectId = arguments[2];
	
	            var isPositive = power >= 0;
	            power = Math.abs(power);
	
	            var actualPower = (100.0 - offset) / 100.0 * power + offset;
	            var actualResultInt = Math.round(actualPower);
	
	            if (!isPositive) {
	                actualResultInt = -actualResultInt;
	            }
	
	            var outputCommand = _OutputCommand2.default.commandWriteMotorPower(actualResultInt, connectId);
	            this.writeOutputCommand(outputCommand);
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('Writing motor power command: ', new Int8Array(outputCommand.getData()));
	            }
	            return outputCommand;
	        }
	
	        /**
	         * Writes a command to the queue that plays a frequency for a duration
	         *
	         * @param {number} frequency - The frequency in Hz
	         * @param {number} duration - The time that the frequency is playing for - in milliseconds
	         * @param {number} connectId - The connectId of the Piezo
	         */
	
	    }, {
	        key: 'writePiezoToneFrequency',
	        value: function writePiezoToneFrequency(frequency, duration, connectId) {
	            var outputCommand = _OutputCommand2.default.commandWritePiezoToneFrequency(frequency, duration, connectId);
	            this.writeOutputCommand(outputCommand);
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('Writing piezo tone play command: ', new Uint8Array(outputCommand.getData()));
	            }
	        }
	
	        /**
	         * Writes command to queue that stops playing the piezo tone
	         * @param {number} connectId - The connectId of the Piezo
	         */
	
	    }, {
	        key: 'writePiezoToneStop',
	        value: function writePiezoToneStop(connectId) {
	            var outputCommand = _OutputCommand2.default.commandWritePiezoToneStopForConnectId(connectId);
	            this.writeOutputCommand(outputCommand);
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('Writing piezo tone stop command: ', new Uint8Array(outputCommand.getData()));
	            }
	        }
	
	        /**
	         * Writes command to queue that sets the color of the LED as RGB
	         * @param {number} red - Value for red color (0-255)
	         * @param {number} green - Value for green color (0-255)
	         * @param {number} blue - Value for blue color (0-255)
	         * @param {number} connectId - The connectId of the LED
	         */
	
	    }, {
	        key: 'writeColor',
	        value: function writeColor(red, green, blue, connectId) {
	            var outputCommand = _OutputCommand2.default.commandWriteRGBLight(red, green, blue, connectId);
	            this.writeOutputCommand(outputCommand);
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('Writing RGB command: ', new Uint8Array(outputCommand.getData()));
	            }
	        }
	
	        /**
	         * Writes command to queue that sets the color of the LED as colorIndex.
	         * @param {number} index - The color index (0-16), 0 being off
	         * @param {number} connectId - The connectId of the LED
	         */
	
	    }, {
	        key: 'writeColorIndex',
	        value: function writeColorIndex(index, connectId) {
	            var outputCommand = _OutputCommand2.default.commandWriteRGBLightIndex(index, connectId);
	            this.writeOutputCommand(outputCommand);
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('Writing RGB Index command: ', new Uint8Array(outputCommand.getData()));
	            }
	        }
	
	        /**
	         * Writes command to queue that writes data directly
	         *
	         * @param {TypedArray} data - Typed array with direct command bytes
	         * @param {number} connectId - The connectId of the device to write the data to
	         */
	
	    }, {
	        key: 'writeData',
	        value: function writeData(data, connectId) {
	            var outputCommand = _OutputCommand2.default.commandWithDirectWriteThroughData(data, connectId);
	            this.writeOutputCommand(outputCommand);
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('Direct write with data: ', new Int8Array(outputCommand.getData()));
	            }
	        }
	
	        /**
	         * Adds an output command to the queue for execution.
	         *
	         * @param {OutputCommand} command - The command to execute as a typed array (Int8Array, Uint8Array etc)
	         */
	
	    }, {
	        key: 'writeOutputCommand',
	        value: function writeOutputCommand(command) {
	            if (this.isDeviceConnected()) {
	                this.associatedDevice.addWriteOfCharacteristicToQueue(this.outputCommandCharacteristic, command.getData());
	            }
	        }
	
	        /**
	         * Receives the response for the write command.
	         *
	         * @param {NativeCharacteristic} characteristic - The characteristic for which the command was executed
	         * @param {string} error - The error param is set if and only if the command failed
	         */
	
	    }, {
	        key: 'handleWriteResponseFromIOServiceWithCharacteristic',
	        value: function handleWriteResponseFromIOServiceWithCharacteristic(characteristic, error) {
	            if (error === null || error === undefined) {
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('Did write data ', new Int8Array(characteristic.value));
	                }
	            } else {
	                _LDSDKLogger2.default.error('Failed to write data for characteristic ', (0, _stringify2.default)(characteristic));
	            }
	        }
	
	        /**
	         * Handles updated inputformat (after a write of new format), or updated input values for the characteristic.
	         * The characteristic must either be the InputFormatCharacteristic, or the InputValue characteristic, other
	         * characteristics are ignored (logged as a Warning).
	         *
	         * In case of updates to the inputformat, this function will delegate to the @see {@link #handleUpdatedInputFormatData} function
	         *
	         * In case of updates to the inputvalue, this function will delegate to the @see {@link #handleUpdatedInputValueData} function
	         *
	         * @param {NativeCharacteristic} characteristic
	         */
	
	    }, {
	        key: 'handleUpdatedInputServiceCharacteristic',
	        value: function handleUpdatedInputServiceCharacteristic(characteristic) {
	            if (characteristic && characteristic !== null) {
	                if (this.serviceDefinition.getInputFormat().matchesCharacteristic(characteristic)) {
	                    this.handleUpdatedInputFormatData(characteristic.value);
	                } else if (this.serviceDefinition.getInputValue().matchesCharacteristic(characteristic)) {
	                    this.handleUpdatedInputValueData(characteristic.value);
	                } else {
	                    if (_LDSDKLogger2.default.isWarnEnabled()) {
	                        _LDSDKLogger2.default.warn('handleUpdatedInputServiceCharacteristic - No match for characteristic uuid ', _UuidHelper2.default.getUuid(characteristic));
	                    }
	                }
	            } else {
	                if (_LDSDKLogger2.default.isWarnEnabled()) {
	                    _LDSDKLogger2.default.warn('Illegal argument - handleUpdatedInputServiceCharacteristic requires the characteristic parameter to be set');
	                }
	            }
	        }
	
	        /**
	         * Handler method for updates to the input format.
	         * @param {ArrayBuffer} data - The data received from the native characteristic.
	         */
	
	    }, {
	        key: 'handleUpdatedInputFormatData',
	        value: function handleUpdatedInputFormatData(data) {
	            var format = _InputFormat2.default.inputFormatFromBuffer(data);
	            if (format !== null && format !== undefined) {
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('Did receive Input Format: ', format.toString());
	                }
	
	                // If we already have input format with an earlier revision, delete all those
	                // as all known formats must have the same version
	                if (this.inputFormats.size > 0) {
	                    var anyFormat = this.inputFormats.values().next().value;
	                    if (anyFormat.getRevision() !== format.getRevision()) {
	                        this.inputFormats.clear();
	                    }
	                }
	
	                this.inputFormats.set(format.getConnectId(), format);
	
	                if (this.ioCallbackHelper) {
	                    this.ioCallbackHelper.performDidReceiveInputFormatCallback(this, format);
	                } else {
	                    if (_LDSDKLogger2.default.isWarnEnabled()) {
	                        _LDSDKLogger2.default.warn('No this.ioCallbackHelper set in ', this.constructor.name, ' unable to notify performDidReceiveInputFormatCallback');
	                    }
	                }
	            }
	        }
	
	        /**
	         * This function should not be called by clients.
	         *
	         * It is called by the device characteristic listener, parses the received data as specified in the InputFormat
	         * for the IO device and finally forwards the parsed data to the IoCallbackHelper.
	         *
	         * If no InputFormat has yet been registered for this IO device, a call to @see {@link #readInputFormatForConnectId}
	         * is performed and this function resolves without processing the received data any further.
	         *
	         * If an inputformat for the IO device is found the data is parsed and subsequently a Map is created and finally
	         *  once the entire payload has been parsed the Map is sent as argument to @see {@link IoCallbackHelper#performDidReceiveValueDataCallback}
	         *
	         * @param {ArrayBuffer} data The data received in the notification.
	         * @return {Promise} The promise resolves
	         */
	
	    }, {
	        key: 'handleUpdatedInputValueData',
	        value: function handleUpdatedInputValueData(data) {
	            var _this2 = this;
	
	            // NOTE: This can be called very frequently and exhaust the resources
	            // setTimeout(() => {
	            if (typeof data === 'undefined') {
	                return _promise2.default.resolve();
	            }
	            this.incrementReceivedMessages();
	            return new _promise2.default(function (resolve, reject) {
	                try {
	                    var dataBuffer = new DataView(data);
	
	                    var offset = 0;
	                    var valueFormatRevision = dataBuffer.getUint8(offset++);
	
	                    var hasMoreValues = true;
	                    var idToValue = new _map2.default();
	
	                    while (hasMoreValues) {
	                        var valueConnectId = dataBuffer.getUint8(offset++);
	                        if (_this2.inputFormats.size === 0) {
	                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                _LDSDKLogger2.default.debug('Cannot parse value - has not yet received any Input Format from device');
	                            }
	                            _this2.readInputFormatForConnectId(valueConnectId); // HUB is sending data, so it must have an Input
	                            // Format registered
	                            return resolve();
	                        }
	
	                        var format = _this2.inputFormats.get(valueConnectId);
	                        if (format === null || format === undefined) {
	                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                _LDSDKLogger2.default.debug('No known Input Format for input with Connect ID ', valueConnectId);
	                            }
	                            return resolve();
	                        }
	
	                        if (format.getRevision() !== valueFormatRevision) {
	                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                _LDSDKLogger2.default.debug('Format revision ' + valueFormatRevision + ' in received value does not match last received Input Format revision ' + format.getRevision());
	                            }
	                            _this2.readInputFormatForConnectId(valueConnectId); // HUB is sending data, so it must have an Input Format
	                            // registered
	                            return resolve();
	                        }
	
	                        var payload = dataBuffer.buffer.slice(offset, offset + format.getNumberOfBytes());
	                        offset += format.getNumberOfBytes();
	
	                        idToValue.set(valueConnectId, payload);
	
	                        if (offset >= dataBuffer.byteLength) {
	                            hasMoreValues = false;
	                        }
	                    }
	
	                    if (_this2.ioCallbackHelper) {
	                        // LDSDKLogger.warn(`this.ioCallbackHelper.performDidReceiveValueDataCallback called with idToValue map of size: ${idToValue.size}`);
	                        _this2.ioCallbackHelper.performDidReceiveValueDataCallback(_this2, idToValue);
	                    } else {
	                        if (_LDSDKLogger2.default.isWarnEnabled()) {
	                            _LDSDKLogger2.default.warn('No this.ioCallbackHelper set in ', _this2.constructor.name, ' unable to notify performDidReceiveValueDataCallback');
	                        }
	                    }
	                    return resolve();
	                } catch (error) {
	                    return reject(error);
	                }
	            });
	
	            // }, 5);
	        }
	    }]);
	    return BluetoothIO;
	}(_IO3.default);
	
	exports.default = BluetoothIO;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _arraybufferEqual = __webpack_require__(113);
	
	var _arraybufferEqual2 = _interopRequireDefault(_arraybufferEqual);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ArrayHelper = function () {
	    function ArrayHelper() {
	        (0, _classCallCheck3.default)(this, ArrayHelper);
	    }
	
	    (0, _createClass3.default)(ArrayHelper, null, [{
	        key: 'isArrayBuffersEqual',
	
	
	        /**
	         * @param {ArrayBuffer}
	         * @param {ArrayBuffer}
	         *
	         * @return {boolean}
	         */
	        value: function isArrayBuffersEqual() {
	            var buffer1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	            var buffer2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
	            if (buffer1 === null && buffer2 === null) {
	                return true;
	            }
	
	            if (buffer1 === null && buffer2 !== null || buffer1 !== null && buffer2 === null) {
	                return false;
	            }
	
	            return (0, _arraybufferEqual2.default)(buffer1, buffer2);
	        }
	    }]);
	    return ArrayHelper;
	}();
	
	exports.default = ArrayHelper;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by frj on 20/02/16.
	 */
	
	/**
	 * @ignore Internal use only
	 */
	var ByteUtils = function () {
	    function ByteUtils() {
	        (0, _classCallCheck3.default)(this, ByteUtils);
	    }
	
	    (0, _createClass3.default)(ByteUtils, null, [{
	        key: 'hexToBytes',
	
	
	        /**
	         * Convert a hex string into a byte array
	         * @param hex
	         * @returns {Array}
	         */
	        value: function hexToBytes(hex) {
	            var bytes = [];
	            for (var c = 0; c < hex.length; c += 2) {
	                bytes.push(parseInt(hex.substr(c, 2), 16));
	            }
	            return bytes;
	        }
	
	        /**
	         * Convert a byte array into a hex string
	         *
	         * @param bytes
	         * @returns {string}
	         */
	
	    }, {
	        key: 'bytesToHex',
	        value: function bytesToHex(bytes) {
	            var hex = [];
	            for (var i = 0; i < bytes.length; i++) {
	                hex.push((bytes[i] >>> 4).toString(16));
	                hex.push((bytes[i] & 0xF).toString(16));
	            }
	            return hex.join('');
	        }
	    }]);
	    return ByteUtils;
	}();
	
	exports.default = ByteUtils;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var _UuidHelper = __webpack_require__(11);
	
	var _UuidHelper2 = _interopRequireDefault(_UuidHelper);
	
	var _DeviceInfoServiceDefinition = __webpack_require__(32);
	
	var _DeviceInfoServiceDefinition2 = _interopRequireDefault(_DeviceInfoServiceDefinition);
	
	var _BluetoothServiceDefinition = __webpack_require__(37);
	
	var _BluetoothServiceDefinition2 = _interopRequireDefault(_BluetoothServiceDefinition);
	
	var _StringUtils = __webpack_require__(21);
	
	var _StringUtils2 = _interopRequireDefault(_StringUtils);
	
	var _DeviceServiceDefinition = __webpack_require__(47);
	
	var _DeviceServiceDefinition2 = _interopRequireDefault(_DeviceServiceDefinition);
	
	var _IOServiceDefinition = __webpack_require__(48);
	
	var _IOServiceDefinition2 = _interopRequireDefault(_IOServiceDefinition);
	
	var _IdHelper = __webpack_require__(28);
	
	var _IdHelper2 = _interopRequireDefault(_IdHelper);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by frj on 28/02/16.
	 */
	/**
	 * @ignore Internal use only
	 */
	function getService(deviceAddress, uuid) {
	    var service = {};
	    service.deviceAddress = deviceAddress;
	    service.uuid = uuid;
	    service.isPrimary = true;
	    service.instanceId = _IdHelper2.default.generateID();
	    return service;
	}
	
	/**
	 * @ignore Internal use only
	 */
	function getCharacteristic(uuid) {
	    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
	    var characteristic = {};
	    characteristic.properties = [];
	    characteristic.uuid = uuid;
	    characteristic.instanceId = uuid;
	    if (value !== null) {
	        characteristic.properties.push('write');
	        characteristic.value = value;
	    } else {
	        characteristic.properties.push('read');
	        characteristic.properties.push('notify');
	    }
	    characteristic.service = getService('fooaddress');
	    return characteristic;
	}
	
	global.chrome = global.chrome || {};
	global.chrome.runtime = global.chrome.runtime || {};
	global.chrome.runtime.lastError = undefined;
	global.chrome.bluetooth = global.chrome.bluetooth || {
	
	    getAdapterState: function getAdapterState(cbAdapter) {
	        if (_LDSDKLogger2.default.isWarnEnabled()) {
	            _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetooth.getAdapterState invoked');
	        }
	
	        var adapter = {
	            discovering: true,
	            powered: true,
	            available: true
	        };
	        setTimeout(function () {
	            cbAdapter(adapter);
	        }, 100);
	    },
	
	    startDiscovery: function startDiscovery(callback) {
	        if (_LDSDKLogger2.default.isWarnEnabled()) {
	            _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetooth.startDiscovery invoked');
	        }
	
	        setTimeout(function () {
	            callback();
	        }, 100);
	    },
	    stopDiscovery: function stopDiscovery(callback) {
	        if (_LDSDKLogger2.default.isWarnEnabled()) {
	            _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetooth.stopDiscovery invoked');
	        }
	
	        setTimeout(function () {
	            callback();
	        }, 100);
	    },
	
	    getDevices: function getDevices(devicesCallback) {
	        if (_LDSDKLogger2.default.isWarnEnabled()) {
	            _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetooth.getDevices invoked');
	        }
	
	        var devices = [];
	        setTimeout(function () {
	            devicesCallback(devices);
	        }, 100);
	    },
	
	    getDevice: function getDevice(deviceAddress, deviceCallback) {
	        if (_LDSDKLogger2.default.isWarnEnabled()) {
	            _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetooth.getDevice [' + deviceAddress + '] invoked');
	        }
	
	        setTimeout(function () {
	            var device = {
	                address: deviceAddress,
	                name: deviceAddress.toUpperCase().replace(/:/g, ''),
	                inquiryRssi: -44,
	                connecting: false,
	                connected: false,
	                connectable: true,
	                paired: false,
	                uuids: [_DeviceServiceDefinition2.default.getInstance().getServiceUUID()]
	            };
	            deviceCallback(device);
	        }, 50);
	    },
	
	    onDeviceAdded: {
	        addListener: function addListener(callback) {
	            if (_LDSDKLogger2.default.isWarnEnabled()) {
	                _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetooth.onDeviceAdded.addListener invoked');
	            }
	
	            var device = { name: 'hep_1', address: 'AB:CD:DE:FG:12:34' };
	            setTimeout(function () {
	                callback(device);
	            }, 100);
	        }
	    },
	    onDeviceChanged: {
	        addListener: function addListener(callback) {
	            if (_LDSDKLogger2.default.isWarnEnabled()) {
	                _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetooth.onDeviceChanged.addListener invoked');
	            }
	
	            var device = { name: 'hep_2', address: 'AB:CD:DE:FG:43:21' };
	            setTimeout(function () {
	                callback(device);
	            }, 100);
	        }
	    },
	    onDeviceRemoved: {
	        addListener: function addListener(callback) {
	            if (_LDSDKLogger2.default.isWarnEnabled()) {
	                _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetooth.onDeviceRemoved.addListener invoked');
	            }
	
	            var device = { name: 'hep_3', address: 'AB:CD:DE:FG:11:22' };
	            setTimeout(function () {
	                callback(device);
	            }, 100);
	        }
	    }
	};
	
	global.chrome.bluetoothLowEnergy = global.chrome.bluetoothLowEnergy || {
	    connect: function connect(deviceAddress, resultFunc) {
	        if (_LDSDKLogger2.default.isWarnEnabled()) {
	            _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetoothLowEnergy.connect [' + deviceAddress + '] invoked');
	        }
	        setTimeout(function () {
	            resultFunc();
	        }, 200);
	    },
	
	    disconnect: function disconnect(deviceAddress, resultFunc) {
	        if (_LDSDKLogger2.default.isWarnEnabled()) {
	            _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetoothLowEnergy.disconnect [' + deviceAddress + '] invoked');
	        }
	        setTimeout(function () {
	            resultFunc();
	        }, 200);
	    },
	
	    getServices: function getServices(deviceAddress, resultFunc) {
	        if (_LDSDKLogger2.default.isWarnEnabled()) {
	            _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetoothLowEnergy.getServices [' + deviceAddress + '] invoked');
	        }
	
	        var services = [];
	        services.push({ instanceId: '1ABCDEF', uuid: _DeviceInfoServiceDefinition2.default.getInstance().getServiceUUID() });
	
	        setTimeout(function () {
	            resultFunc(services);
	        }, 200);
	    },
	
	    getService: function getService(serviceInstanceId, resultFunc) {
	        if (_LDSDKLogger2.default.isWarnEnabled()) {
	            _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetoothLowEnergy.getService [' + serviceInstanceId + '] invoked');
	        }
	
	        var service = {};
	        service.instanceId = 'serviceInstanceId';
	        service.uuid = _DeviceInfoServiceDefinition2.default.getInstance().getServiceUUID();
	
	        setTimeout(function () {
	            resultFunc(service);
	        }, 200);
	    },
	
	    getIncludedServices: function getIncludedServices(serviceInstanceId, callbackWithCharacteristics) {
	        if (_LDSDKLogger2.default.isWarnEnabled()) {
	            _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetoothLowEnergy.getIncludedServices [' + serviceInstanceId + '] invoked');
	        }
	
	        var characteristics = [];
	        setTimeout(function () {
	            callbackWithCharacteristics(characteristics);
	        }, 100);
	    },
	
	    getCharacteristics: function getCharacteristics(serviceInstanceId, callbackWithCharacteristics) {
	        if (_LDSDKLogger2.default.isWarnEnabled()) {
	            _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetoothLowEnergy.getCharacteristics [' + serviceInstanceId + '] invoked');
	        }
	
	        var characteristics = [];
	        if (serviceInstanceId === _BluetoothServiceDefinition2.default.deviceInfoServiceDefinition().getServiceUUID()) {
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('In ChromeShim.getCharacteristics - serviceInstanceId === ' + serviceInstanceId + ' (deviceInfoServiceDefinition)');
	            }
	            characteristics.push(getCharacteristic(_UuidHelper2.default.getSpecUuid(_DeviceInfoServiceDefinition2.default.DEVICE_INFO_FIRMWARE_REVISION_CHARACTERISTIC_UUID)));
	            characteristics.push(getCharacteristic(_UuidHelper2.default.getSpecUuid(_DeviceInfoServiceDefinition2.default.DEVICE_INFO_HARDWARE_REVISION_CHARACTERISTIC_UUID)));
	            characteristics.push(getCharacteristic(_UuidHelper2.default.getSpecUuid(_DeviceInfoServiceDefinition2.default.DEVICE_INFO_SOFTWARE_REVISION_CHARACTERISTIC_UUID)));
	            characteristics.push(getCharacteristic(_UuidHelper2.default.getSpecUuid(_DeviceInfoServiceDefinition2.default.DEVICE_INFO_MANUFACTURER_NAME_CHARACTERISTIC_UUID)));
	        } else if (serviceInstanceId === _BluetoothServiceDefinition2.default.deviceServiceDefinition().getServiceUUID()) {
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('In ChromeShim.getCharacteristics - serviceInstanceId === ' + serviceInstanceId + ' (deviceServiceDefinition)');
	            }
	            characteristics.push(getCharacteristic(_UuidHelper2.default.getLegoUuid(_DeviceServiceDefinition2.default.HUB_CHARACTERISTIC_NAME_UUID)));
	            characteristics.push(getCharacteristic(_UuidHelper2.default.getLegoUuid(_DeviceServiceDefinition2.default.HUB_CHARACTERISTIC_ATTACHED_IO)));
	            characteristics.push(getCharacteristic(_UuidHelper2.default.getLegoUuid(_DeviceServiceDefinition2.default.HUB_CHARACTERISTIC_BUTTON_STATE)));
	            characteristics.push(getCharacteristic(_UuidHelper2.default.getLegoUuid(_DeviceServiceDefinition2.default.HUB_CHARACTERISTIC_LOW_VOLTAGE_ALERT)));
	            characteristics.push(getCharacteristic(_UuidHelper2.default.getLegoUuid(_DeviceServiceDefinition2.default.HUB_CHARACTERISTIC_DISCONNECT)));
	        } else if (serviceInstanceId === _BluetoothServiceDefinition2.default.ioServiceDefinition().getServiceUUID()) {
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('In ChromeShim.getCharacteristics - serviceInstanceId === ' + serviceInstanceId + ' (ioServiceDefinition)');
	            }
	            characteristics.push(getCharacteristic(_UuidHelper2.default.getLegoUuid(_IOServiceDefinition2.default.CHARACTERISTIC_INPUT_VALUE_UUID)));
	            characteristics.push(getCharacteristic(_UuidHelper2.default.getLegoUuid(_IOServiceDefinition2.default.CHARACTERISTIC_INPUT_FORMAT_UUID)));
	            characteristics.push(getCharacteristic(_UuidHelper2.default.getLegoUuid(_IOServiceDefinition2.default.CHARACTERISTIC_INPUT_COMMAND_UUID)));
	            characteristics.push(getCharacteristic(_UuidHelper2.default.getLegoUuid(_IOServiceDefinition2.default.CHARACTERISTIC_OUTPUT_COMMAND_UUID)));
	        } else if (serviceInstanceId === _BluetoothServiceDefinition2.default.batteryServiceDefinition().getServiceUUID()) {
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug('In ChromeShim.getCharacteristics - serviceInstanceId === ' + serviceInstanceId + ' (batteryServiceDefinition)');
	            }
	            characteristics.push(getCharacteristic(_UuidHelper2.default.getSpecUuid(BatteryServiceDefinition.BATTERY_LEVEL_CHARACTERISTIC_UUID)));
	        } else {
	            if (_LDSDKLogger2.default.isErrorEnabled()) {
	                _LDSDKLogger2.default.error('*** In ChromeShim.getCharacteristics - Unhandled service instanceId: (chrome.bluetoothLowEnergy.getCharacteristics): ', serviceInstanceId, ' ***');
	            }
	        }
	
	        setTimeout(function () {
	            if (callbackWithCharacteristics && callbackWithCharacteristics !== null) {
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('In ChromeShim.getCharacteristics - Calling back - got: ' + characteristics.length + ' characteristics for service instanceId: ' + serviceInstanceId);
	                }
	                callbackWithCharacteristics(characteristics);
	            } else {
	                _LDSDKLogger2.default.error('In ChromeShim.getCharacteristics - The callbackWithCharacteristics argument to chrome.bluetoothLowEnergy.getCharacteristics was not defined - unable to callback with ' + characteristics.length + ' characteristics for service instanceId: ' + serviceInstanceId);
	            }
	        }, 150);
	    },
	
	    writeCharacteristicValue: function writeCharacteristicValue(characteristicIinstanceId, buffer, replyFunc) {
	        if (_LDSDKLogger2.default.isWarnEnabled()) {
	            _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetoothLowEnergy.writeCharacteristicValue [' + characteristicIinstanceId + '] invoked');
	        }
	    },
	
	    readCharacteristicValue: function readCharacteristicValue(characteristicIinstanceId, resultFunc) {
	        if (_LDSDKLogger2.default.isWarnEnabled()) {
	            _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetoothLowEnergy.readCharacteristicValue [' + characteristicIinstanceId + '] invoked');
	        }
	
	        setTimeout(function () {
	            var characteristic = void 0;
	
	            switch (characteristicIinstanceId) {
	                case _UuidHelper2.default.getSpecUuid(_DeviceInfoServiceDefinition2.default.DEVICE_INFO_FIRMWARE_REVISION_CHARACTERISTIC_UUID):
	                    characteristic = getCharacteristic(_UuidHelper2.default.getSpecUuid(_DeviceInfoServiceDefinition2.default.DEVICE_INFO_FIRMWARE_REVISION_CHARACTERISTIC_UUID), Uint8Array.from(_StringUtils2.default.toUtf8Bytes('1.0.0.0')).buffer);
	                    break;
	                case _UuidHelper2.default.getSpecUuid(_DeviceInfoServiceDefinition2.default.DEVICE_INFO_HARDWARE_REVISION_CHARACTERISTIC_UUID):
	                    characteristic = getCharacteristic(_UuidHelper2.default.getSpecUuid(_DeviceInfoServiceDefinition2.default.DEVICE_INFO_HARDWARE_REVISION_CHARACTERISTIC_UUID), Uint8Array.from(_StringUtils2.default.toUtf8Bytes('2.0.0.0')).buffer);
	                    break;
	                case _UuidHelper2.default.getSpecUuid(_DeviceInfoServiceDefinition2.default.DEVICE_INFO_SOFTWARE_REVISION_CHARACTERISTIC_UUID):
	                    characteristic = getCharacteristic(_UuidHelper2.default.getSpecUuid(_DeviceInfoServiceDefinition2.default.DEVICE_INFO_SOFTWARE_REVISION_CHARACTERISTIC_UUID), Uint8Array.from(_StringUtils2.default.toUtf8Bytes('3.0.0.0')).buffer);
	                    break;
	                case _UuidHelper2.default.getSpecUuid(_DeviceInfoServiceDefinition2.default.DEVICE_INFO_MANUFACTURER_NAME_CHARACTERISTIC_UUID):
	                    characteristic = getCharacteristic(_UuidHelper2.default.getSpecUuid(_DeviceInfoServiceDefinition2.default.DEVICE_INFO_MANUFACTURER_NAME_CHARACTERISTIC_UUID), Uint8Array.from(_StringUtils2.default.toUtf8Bytes('Trifork')).buffer);
	                    break;
	                case _UuidHelper2.default.getLegoUuid(_DeviceServiceDefinition2.default.HUB_CHARACTERISTIC_NAME_UUID):
	                    characteristic = getCharacteristic(_UuidHelper2.default.getLegoUuid(_DeviceServiceDefinition2.default.HUB_CHARACTERISTIC_NAME_UUID), Uint8Array.from(_StringUtils2.default.toUtf8Bytes('Some Hub Name')).buffer);
	                    break;
	
	                default:
	                    characteristic = getCharacteristic(characteristicIinstanceId, new Uint8Array([0]).buffer);
	            }
	            resultFunc(characteristic);
	        }, 100);
	    },
	
	    startCharacteristicNotifications: function startCharacteristicNotifications(characteristicIinstanceId, resultFunc) {
	        if (_LDSDKLogger2.default.isWarnEnabled()) {
	            _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetoothLowEnergy.startCharacteristicNotifications [' + characteristicIinstanceId + '] invoked');
	        }
	
	        setTimeout(function () {
	            resultFunc();
	        }, 100);
	    },
	
	    stopCharacteristicNotifications: function stopCharacteristicNotifications(characteristicIinstanceId, resultFunc) {
	        if (_LDSDKLogger2.default.isWarnEnabled()) {
	            _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetoothLowEnergy.stopCharacteristicNotifications [' + characteristicIinstanceId + '] invoked');
	        }
	
	        setTimeout(function () {
	            resultFunc();
	        }, 100);
	    },
	
	    getDescriptor: function getDescriptor(descriptorUuid, resultFunc) {
	        if (_LDSDKLogger2.default.isWarnEnabled()) {
	            _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetoothLowEnergy.getDescriptor [' + descriptorUuid + '] invoked');
	        }
	    },
	
	    onCharacteristicValueChanged: {
	        addListener: function addListener(callbackFunc) {
	            if (_LDSDKLogger2.default.isWarnEnabled()) {
	                _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetoothLowEnergy.onCharacteristicValueChanged.addListener invoked');
	            }
	
	            setTimeout(function () {
	                var characteristic = getCharacteristic(_UuidHelper2.default.getLegoUuid(_DeviceServiceDefinition2.default.HUB_CHARACTERISTIC_NAME_UUID));
	                callbackFunc(characteristic);
	            }, 200);
	        }
	    },
	
	    onServiceAdded: {
	        addListener: function addListener(callbackFunc) {
	            if (_LDSDKLogger2.default.isWarnEnabled()) {
	                _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetoothLowEnergy.onServiceAdded.addListener invoked');
	            }
	            setTimeout(function () {
	                var service = getService('fooaddress', _UuidHelper2.default.getLegoUuid('1523'));
	                callbackFunc(service);
	            }, 400);
	        }
	    },
	    onServiceChanged: {
	        addListener: function addListener(callbackFunc) {
	            if (_LDSDKLogger2.default.isWarnEnabled()) {
	                _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetoothLowEnergy.onServiceChanged.addListener invoked');
	            }
	
	            setTimeout(function () {
	                var service = getService('fooaddress', _UuidHelper2.default.getLegoUuid('1523'));
	                callbackFunc(service);
	            }, 400);
	        }
	    },
	    onServiceRemoved: {
	        addListener: function addListener(callbackFunc) {
	            if (_LDSDKLogger2.default.isWarnEnabled()) {
	                _LDSDKLogger2.default.warn('ChromeShim: global.chrome.bluetoothLowEnergy.onServiceRemoved.addListener invoked');
	            }
	
	            setTimeout(function () {
	                var service = getService('fooaddress', _UuidHelper2.default.getLegoUuid('1523'));
	                callbackFunc(service);
	            }, 400);
	        }
	    }
	
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var _map = __webpack_require__(9);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _LegoDeviceManagerImpl = __webpack_require__(31);
	
	var _LegoDeviceManagerImpl2 = _interopRequireDefault(_LegoDeviceManagerImpl);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_LDSDKLogger2.default.error('INSERTING DEBUG CALLBACKS - TO BE REMOVED');
	global.debugDeviceServices = new _map2.default();
	global.startDebugPollingServices = function () {
	    var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4000;
	
	    if (!_LDSDKLogger2.default.isWarnEnabled()) {
	        _LDSDKLogger2.default.enable(3);
	    }
	    if (!global.hasOwnProperty('debugPollingServicesId')) {
	        global.debugPollingServicesId = setInterval(function () {
	            var allDevices = _LegoDeviceManagerImpl2.default.getInstance().allDevices();
	            if (allDevices && Array.isArray(allDevices.simpleList)) {
	                var _loop = function _loop(idx) {
	                    var device = allDevices.simpleList[idx];
	                    if (device.connectState < 3) {
	                        if (global.debugDeviceServices.has(device.deviceId)) {
	                            global.debugDeviceServices.delete(device.deviceId);
	                        }
	                    } else {
	                        if (!global.debugDeviceServices.has(device.deviceId)) {
	                            setTimeout(function () {
	                                chrome.bluetoothLowEnergy.getServices(allDevices.simpleList[idx].deviceId, function (services) {
	                                    if (chrome.runtime.lastError) {
	                                        _LDSDKLogger2.default.warn('#1 Failed getServices for ' + device.deviceName + ' [' + device.deviceId + '] - Error: ' + chrome.runtime.lastError.message);
	                                        return;
	                                    }
	                                    if (Array.isArray(services) && services.length > 0) {
	                                        _LDSDKLogger2.default.warn('#1 getServices for ' + device.deviceName + ' [' + device.deviceId + '] returned ' + services.length + ' services');
	                                        global.debugDeviceServices.set(device.deviceId, services);
	                                    } else {
	                                        _LDSDKLogger2.default.warn('#1 getServices for ' + device.deviceName + ' [' + device.deviceId + '] returned no services');
	                                    }
	                                });
	                            }, 0);
	                        }
	                    }
	                };
	
	                for (var idx = 0; idx < allDevices.simpleList.length; idx++) {
	                    _loop(idx);
	                }
	            }
	        }, interval);
	        _LDSDKLogger2.default.warn('startDebugPollingServices started polling of getServices with intervalId=' + global.debugPollingServicesId + ' use stopDebugPollingServices to stop it');
	    } else {
	        _LDSDKLogger2.default.warn('startDebugPollingServices is already started with intervalId=' + global.debugPollingServicesId);
	    }
	};
	
	global.stopDebugPollingServices = function () {
	    if (!_LDSDKLogger2.default.isWarnEnabled()) {
	        _LDSDKLogger2.default.enable(3);
	    }
	    if (global.hasOwnProperty('debugPollingServicesId')) {
	        clearInterval(global.debugPollingServicesId);
	        delete global.debugPollingServicesId;
	        _LDSDKLogger2.default.warn('stopDebugPollingServices has stopped intervalId=' + global.debugPollingServicesId);
	    }
	};
	
	global.addDebugServiceLister = function () {
	    var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '2#';
	
	    if (!_LDSDKLogger2.default.isWarnEnabled()) {
	        _LDSDKLogger2.default.enable(3);
	    }
	    var listenerAdded = chrome.bluetoothLowEnergy.onServiceAdded.addListener(function (service) {
	        var device = _LegoDeviceManagerImpl2.default.getInstance().getDevice(service.deviceAddress);
	        _LDSDKLogger2.default.warn(prefix + ' - onServiceAdded for ' + device.deviceName + ' [' + device.deviceId + '] - ' + service.uuid);
	    });
	    _LDSDKLogger2.default.warn('addDebugServiceLister added "onServiceAdded" listener - addListener returned: ', listenerAdded);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _regenerator = __webpack_require__(14);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(13);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _slicedToArray2 = __webpack_require__(131);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _getIterator2 = __webpack_require__(33);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _map = __webpack_require__(9);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	var _IdHelper = __webpack_require__(28);
	
	var _IdHelper2 = _interopRequireDefault(_IdHelper);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by frj on 19/02/16.
	 */
	
	/**
	 * @ignore Internal use only
	 */
	var IoCallbackHelper = function () {
	    function IoCallbackHelper() {
	        (0, _classCallCheck3.default)(this, IoCallbackHelper);
	        this.callbackListeners = new _map2.default();
	    }
	
	    /**
	     * Map of callback listeners
	     * @type {Map<string, LegoService>}
	     */
	
	
	    (0, _createClass3.default)(IoCallbackHelper, [{
	        key: 'registerCallbackListener',
	
	
	        /**
	         * Register a new service for receiving service value callbacks
	         * @param {LegoService} callback - Any instance object extending LegoService
	         * @return {string} - Returns a Callback id that can be used when unregistering for Io callbacks
	         */
	        value: function registerCallbackListener(service) {
	            this.checkCallbackListener(service);
	
	            var callbackIdKey = 'generatedCallbackId';
	            var callbackId = void 0;
	            if (service.hasOwnProperty(callbackIdKey)) {
	                callbackId = service[callbackIdKey];
	                if (!this.callbackListeners.has(callbackId)) {
	                    this.callbackListeners.set(callbackId, service);
	                }
	            } else {
	                callbackId = _IdHelper2.default.generateID();
	                while (this.callbackListeners.has(callbackId)) {
	                    // in case the map already has a key === callbackId we generate a new one
	                    callbackId = _IdHelper2.default.generateID();
	                }
	                this.callbackListeners.set(callbackId, service);
	            }
	            return callbackId;
	        }
	
	        /**
	         *
	         * @param {string} callbackId - The callback id returned when registering for callbacks
	         * @param {LegoService} service - The service to unregister
	         * @return {boolean} - Returns true if a callback listener was found and unregistered, false otherwise
	         */
	
	    }, {
	        key: 'unregisterCallbackListener',
	        value: function unregisterCallbackListener() {
	            var callbackId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	            var service = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
	            if (callbackId !== null) {
	                if (_LDSDKLogger2.default.isDebugEnabled()) {
	                    _LDSDKLogger2.default.debug('Unregistering callback listener with callbackId: ' + callbackId);
	                }
	                return this.callbackListeners.delete(callbackId);
	            }
	
	            if (service !== null) {
	                var _iteratorNormalCompletion = true;
	                var _didIteratorError = false;
	                var _iteratorError = undefined;
	
	                try {
	                    for (var _iterator = (0, _getIterator3.default)(this.callbackListeners.entries()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                        var _step$value = (0, _slicedToArray3.default)(_step.value, 2),
	                            _callbackId = _step$value[0],
	                            callbackListener = _step$value[1];
	
	                        if (callbackListener.getConnectInfo().getConnectId() === service.getConnectInfo().getConnectId()) {
	                            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                                _LDSDKLogger2.default.debug('Service connectId matches callback listener connectId: ' + service.getConnectInfo().getConnectId() + ' - Unregistering callbackId: ' + _callbackId);
	                            }
	                            this.unregisterCallbackListener(_callbackId);
	                        }
	                    }
	                } catch (err) {
	                    _didIteratorError = true;
	                    _iteratorError = err;
	                } finally {
	                    try {
	                        if (!_iteratorNormalCompletion && _iterator.return) {
	                            _iterator.return();
	                        }
	                    } finally {
	                        if (_didIteratorError) {
	                            throw _iteratorError;
	                        }
	                    }
	                }
	            }
	        }
	
	        /**
	         *
	         * @param {LegoService} service
	         * @return {string} callbackId
	         */
	
	    }, {
	        key: 'checkOrRegisterAsCallbackListener',
	        value: function checkOrRegisterAsCallbackListener(service) {
	            var _iteratorNormalCompletion2 = true;
	            var _didIteratorError2 = false;
	            var _iteratorError2 = undefined;
	
	            try {
	                for (var _iterator2 = (0, _getIterator3.default)(this.callbackListeners.entries()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                    var _step2$value = (0, _slicedToArray3.default)(_step2.value, 2),
	                        callbackId = _step2$value[0],
	                        callbackListener = _step2$value[1];
	
	                    if (callbackListener.getConnectInfo().getConnectId() === service.getConnectInfo().getConnectId()) {
	                        if (callbackListener.getConnectInfo().getTypeEnum() === service.getConnectInfo().getTypeEnum()) {
	                            return callbackId; // Found identical connectId and type - no reason for changes
	                        } else {
	                            // Different type for the connectId - unregister existing listener
	                            this.unregisterCallbackListener(callbackId);
	                        }
	                    }
	                }
	            } catch (err) {
	                _didIteratorError2 = true;
	                _iteratorError2 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                        _iterator2.return();
	                    }
	                } finally {
	                    if (_didIteratorError2) {
	                        throw _iteratorError2;
	                    }
	                }
	            }
	
	            return this.registerCallbackListener(service);
	        }
	    }, {
	        key: 'performDidRequestConnectInfo',
	        value: function performDidRequestConnectInfo(io) {
	            var _this = this;
	
	            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                _LDSDKLogger2.default.info('performDidRequestConnectInfo: ', io);
	            }
	
	            setTimeout(function () {
	                if (_this.callbackListeners.size === 0) {
	                    if (_LDSDKLogger2.default.isWarnEnabled()) {
	                        _LDSDKLogger2.default.warn('performDidRequestConnectInfo :: No callbacklisteners found - unable' + ' to call back didRequestConnectInfo');
	                    }
	                    /*
	                                    if (io.associatedDevice.cachedListener && io.associatedDevice.cachedListener !== null) {
	                                        if (io.associatedDevice.cachedListener.hasOwnProperty('serviceCallbackListener')) {
	                                            this.registerCallbackListener(io.associatedDevice.cachedListener.serviceCallbackListener);
	                                        }
	                                    }
	                    */
	                }
	
	                var _iteratorNormalCompletion3 = true;
	                var _didIteratorError3 = false;
	                var _iteratorError3 = undefined;
	
	                try {
	                    for (var _iterator3 = (0, _getIterator3.default)(_this.callbackListeners.values()), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                        var callbackListener = _step3.value;
	
	                        if (callbackListener !== null) {
	                            callbackListener.didRequestConnectInfo(io);
	                        }
	                    }
	                } catch (err) {
	                    _didIteratorError3 = true;
	                    _iteratorError3 = err;
	                } finally {
	                    try {
	                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                            _iterator3.return();
	                        }
	                    } finally {
	                        if (_didIteratorError3) {
	                            throw _iteratorError3;
	                        }
	                    }
	                }
	            }, 0);
	        }
	
	        /**
	         *
	         * @param io
	         * @param {Map<>} idToValue
	         */
	
	    }, {
	        key: 'performDidReceiveValueDataCallback',
	        value: function performDidReceiveValueDataCallback(io, idToValue) {
	            var _this2 = this;
	
	            setTimeout(function () {
	                if (_this2.callbackListeners.size === 0) {
	                    if (_LDSDKLogger2.default.isWarnEnabled()) {
	                        _LDSDKLogger2.default.warn('performDidReceiveValueDataCallback :: No callbacklisteners found - unable' + ' to call back didReceiveValueData');
	                    }
	                    /*
	                                    if (io.associatedDevice.cachedListener && io.associatedDevice.cachedListener !== null) {
	                                        if (io.associatedDevice.cachedListener.hasOwnProperty('serviceCallbackListener')) {
	                                            this.registerCallbackListener(io.associatedDevice.cachedListener.serviceCallbackListener);
	                                        }
	                                    }
	                    */
	                }
	
	                var _iteratorNormalCompletion4 = true;
	                var _didIteratorError4 = false;
	                var _iteratorError4 = undefined;
	
	                try {
	                    for (var _iterator4 = (0, _getIterator3.default)(_this2.callbackListeners.values()), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	                        var callbackListener = _step4.value;
	
	                        if (callbackListener !== null) {
	                            var connectInfo = callbackListener.didRequestConnectInfo(io);
	                            var cachedService = callbackListener.getDevice().getService(connectInfo.getConnectId());
	                            if (cachedService !== null && cachedService.getConnectInfo().getTypeEnum() === connectInfo.getTypeEnum()) {
	                                if (idToValue.has(connectInfo.getConnectId())) {
	                                    var value = idToValue.get(connectInfo.getConnectId());
	                                    if (value) {
	                                        callbackListener.didReceiveValueData(io, value);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                } catch (err) {
	                    _didIteratorError4 = true;
	                    _iteratorError4 = err;
	                } finally {
	                    try {
	                        if (!_iteratorNormalCompletion4 && _iterator4.return) {
	                            _iterator4.return();
	                        }
	                    } finally {
	                        if (_didIteratorError4) {
	                            throw _iteratorError4;
	                        }
	                    }
	                }
	            }, 0);
	        }
	    }, {
	        key: 'performDidReceiveInputFormatCallback',
	        value: function performDidReceiveInputFormatCallback(io, inputFormat) {
	            var _this3 = this;
	
	            if (_LDSDKLogger2.default.isInfoEnabled()) {
	                _LDSDKLogger2.default.info('performDidReceiveInputFormatCallback - inputFormat: ', inputFormat);
	            }
	
	            setTimeout((0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
	                var _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, callbackListener, connectInfo, cachedService;
	
	                return _regenerator2.default.wrap(function _callee$(_context) {
	                    while (1) {
	                        switch (_context.prev = _context.next) {
	                            case 0:
	                                if (_this3.callbackListeners.size === 0) {
	                                    if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                        _LDSDKLogger2.default.warn('performDidReceiveInputFormatCallback :: No callbacklisteners found - unable' + ' to call back didReceiveInputFormat');
	                                    }
	                                    /*
	                                                    if (io.associatedDevice.cachedListener && io.associatedDevice.cachedListener !== null) {
	                                                        if (io.associatedDevice.cachedListener.hasOwnProperty('serviceCallbackListener')) {
	                                                            this.registerCallbackListener(io.associatedDevice.cachedListener.serviceCallbackListener);
	                                                        }
	                                                    }
	                                    */
	                                }
	                                _iteratorNormalCompletion5 = true;
	                                _didIteratorError5 = false;
	                                _iteratorError5 = undefined;
	                                _context.prev = 4;
	                                _iterator5 = (0, _getIterator3.default)(_this3.callbackListeners.values());
	
	                            case 6:
	                                if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {
	                                    _context.next = 19;
	                                    break;
	                                }
	
	                                callbackListener = _step5.value;
	
	                                if (!(callbackListener !== null)) {
	                                    _context.next = 16;
	                                    break;
	                                }
	
	                                connectInfo = callbackListener.didRequestConnectInfo(io);
	                                cachedService = callbackListener.getDevice().getService(connectInfo.getConnectId());
	
	                                if (!(cachedService !== null && cachedService.getConnectInfo().getTypeEnum() === connectInfo.getTypeEnum())) {
	                                    _context.next = 16;
	                                    break;
	                                }
	
	                                if (!(inputFormat && inputFormat !== null && (connectInfo.getConnectId() !== inputFormat.getConnectId() || connectInfo.getTypeEnum() !== inputFormat.getType()))) {
	                                    _context.next = 15;
	                                    break;
	                                }
	
	                                if (_LDSDKLogger2.default.isTraceEnabled()) {
	                                    _LDSDKLogger2.default.debug('Ignoring input format. The inputformat ' + inputFormat.toString() + 'does not match this service - check that the connectId and/or type matches. Service: ' + callbackListener.getServiceName() + ', ConnectId: ' + connectInfo.getConnectId() + ', Type: ' + connectInfo.getTypeEnum());
	                                }
	                                return _context.abrupt('continue', 16);
	
	                            case 15:
	                                callbackListener.didReceiveInputFormat(io, inputFormat);
	
	                            case 16:
	                                _iteratorNormalCompletion5 = true;
	                                _context.next = 6;
	                                break;
	
	                            case 19:
	                                _context.next = 25;
	                                break;
	
	                            case 21:
	                                _context.prev = 21;
	                                _context.t0 = _context['catch'](4);
	                                _didIteratorError5 = true;
	                                _iteratorError5 = _context.t0;
	
	                            case 25:
	                                _context.prev = 25;
	                                _context.prev = 26;
	
	                                if (!_iteratorNormalCompletion5 && _iterator5.return) {
	                                    _iterator5.return();
	                                }
	
	                            case 28:
	                                _context.prev = 28;
	
	                                if (!_didIteratorError5) {
	                                    _context.next = 31;
	                                    break;
	                                }
	
	                                throw _iteratorError5;
	
	                            case 31:
	                                return _context.finish(28);
	
	                            case 32:
	                                return _context.finish(25);
	
	                            case 33:
	                            case 'end':
	                                return _context.stop();
	                        }
	                    }
	                }, _callee, _this3, [[4, 21, 25, 33], [26,, 28, 32]]);
	            })), 0);
	        }
	    }, {
	        key: 'checkCallbackListener',
	        value: function checkCallbackListener(callbackListener) {
	            if (callbackListener === null || callbackListener === undefined) {
	                _LDSDKLogger2.default.error('Attempt to add undefined callback listener to ' + this.constructor.name + ' ignored');
	                return false;
	            }
	        }
	    }]);
	    return IoCallbackHelper;
	}();
	
	exports.default = IoCallbackHelper;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _IoCallbackHelper = __webpack_require__(119);
	
	var _IoCallbackHelper2 = _interopRequireDefault(_IoCallbackHelper);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @abstract
	 * This is an abstract class not meant to be used directly
	 */
	var IO = function () {
	  function IO() {
	    (0, _classCallCheck3.default)(this, IO);
	    this.associatedDevice = null;
	    this.ioCallbackHelper = new _IoCallbackHelper2.default();
	  }
	  /**
	   * @private
	   * @type {LegoBluetoothDeviceImpl}
	   */
	
	
	  /**
	  * @private
	   * @type {IoCallbackHelper}
	   */
	
	
	  (0, _createClass3.default)(IO, [{
	    key: 'writeInputFormat',
	    value: function writeInputFormat(newFormat, connectId) {}
	  }, {
	    key: 'readInputFormatForConnectId',
	    value: function readInputFormatForConnectId(connectId) {}
	  }, {
	    key: 'writeMotorPower',
	
	    // writeMotorPower(power, connectId) {};
	    value: function writeMotorPower(power, offset, connectId) {}
	  }, {
	    key: 'writePiezoToneFrequency',
	    value: function writePiezoToneFrequency(frequency, duration, connectId) {}
	  }, {
	    key: 'writePiezoToneStop',
	    value: function writePiezoToneStop(connectId) {}
	  }, {
	    key: 'writeColor',
	    value: function writeColor(red, green, blue, connectId) {}
	  }, {
	    key: 'writeColorIndex',
	    value: function writeColorIndex(index, connectId) {}
	  }, {
	    key: 'writeData',
	    value: function writeData(dataBuffer, connectId) {}
	  }, {
	    key: 'readValueForConnectId',
	    value: function readValueForConnectId(connectId) {}
	  }, {
	    key: 'resetStateForConnectId',
	    value: function resetStateForConnectId(connectId) {}
	  }, {
	    key: 'getCallbackHelper',
	
	
	    /**
	     *
	     * @return {IoCallbackHelper}
	     */
	    value: function getCallbackHelper() {
	      return this.ioCallbackHelper;
	    }
	
	    /**
	     * Register a callback listener
	     *
	     * @param {LegoService} ioCallbackListener
	     * @return {string}
	     */
	
	  }, {
	    key: 'registerCallbackListener',
	    value: function registerCallbackListener(ioCallbackListener) {
	      if (ioCallbackListener === null || ioCallbackListener === undefined) {
	        throw new Error('null cannot be registered as a callbacklistener');
	      }
	      return this.getCallbackHelper().checkOrRegisterAsCallbackListener(ioCallbackListener);
	    }
	
	    /**
	     * Unregister the callback listener
	     * @param ioCallbackListener
	     * @return {*}
	     */
	
	  }, {
	    key: 'unregisterCallbackListener',
	    value: function unregisterCallbackListener(ioCallbackListener) {
	      if (ioCallbackListener === null || ioCallbackListener === undefined) {
	        throw new Error('null cannot be unregistered as a callbacklistener');
	      }
	      return this.getCallbackHelper().unregisterIOCallbackListener(ioCallbackListener);
	    }
	  }]);
	  return IO;
	}(); /**
	      * Created by frj on 11/02/16.
	      */
	
	exports.default = IO;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getIterator2 = __webpack_require__(33);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _promise = __webpack_require__(12);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _map = __webpack_require__(9);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _classCallCheck2 = __webpack_require__(1);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(2);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _IdHelper = __webpack_require__(28);
	
	var _IdHelper2 = _interopRequireDefault(_IdHelper);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by frj on 01/03/16.
	 */
	
	/**
	 * The LEGO Service Callbackhelper is used for registering and holding service listeners and for notifying the service listeners about
	 * value changes and updated input formats.
	 */
	var LegoServiceCallbackHelper = function () {
	    function LegoServiceCallbackHelper() {
	        (0, _classCallCheck3.default)(this, LegoServiceCallbackHelper);
	        this.callbackListeners = new _map2.default();
	    }
	    /**
	     * @private
	     * @type {Map<string, object>}
	     */
	
	
	    (0, _createClass3.default)(LegoServiceCallbackHelper, [{
	        key: 'registerCallbackListener',
	
	
	        /**
	         * Register the callback as a listener to be notified when the service input format or any of its values changes.
	         * @param {{didUpdateInputFormat: function, didUpdateValueData: function, didUpdateDistance: function, didUpdateCount: function, didReadInitialColor: function, didUpdateRGBValue: function, didUpdateRGBColorIndex: function, didUpdateDirection: function, didUpdateAngle: function, didUpdateCrash: function, didUpdateMilliVolts: function, didUpdateMilliAmps: function}} callback - All the functions that can be called back are optional. If they don't exist the callback helper will just skip that notification.
	         * @return {string} - A unique id for the registered listener. The id must be used if you need to unregister the listener again.
	         */
	        value: function registerCallbackListener(callback) {
	            this.checkCallbackListener(callback);
	            var callbackIdKey = 'generatedCallbackId';
	            var callbackId = void 0;
	
	            if (callback.hasOwnProperty(callbackIdKey)) {
	                callbackId = callback[callbackIdKey];
	                if (!this.callbackListeners.has(callbackId)) {
	                    this.callbackListeners.set(callbackId, callback);
	                }
	            } else {
	                callbackId = _IdHelper2.default.generateID();
	                while (this.callbackListeners.has(callbackId)) {
	                    // in case the map already has a key === callbackId we generate a new one
	                    callbackId = _IdHelper2.default.generateID();
	                }
	                this.callbackListeners.set(callbackId, callback);
	            }
	
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug(this.constructor.name + '.registerCallbackListener - Id: ' + callbackId + ', Type: ' + callback.constructor.name + ' callbackListeners size: ' + this.callbackListeners.size);
	            }
	            return callbackId;
	        }
	
	        /**
	         * Unregister a callback to stop receiving callbacks.
	         *
	         * @param {string} callbackId
	         * @return {boolean} Returns true if a callback was unregistered
	         */
	
	    }, {
	        key: 'unregisterCallbackListener',
	        value: function unregisterCallbackListener(callbackId) {
	            var deleted = this.callbackListeners.delete(callbackId);
	            if (_LDSDKLogger2.default.isDebugEnabled()) {
	                _LDSDKLogger2.default.debug(this.constructor.name + '.unregisterCallbackListener - Id: ' + callbackId + ' callbackListeners size: ' + this.callbackListeners.size);
	            }
	            return deleted;
	        }
	
	        /**
	         * @ignore
	         * Get all the callback listeners
	         * @return {Iterator.<object>}
	         */
	
	    }, {
	        key: 'getCallbackListeners',
	        value: function getCallbackListeners() {
	            return this.callbackListeners.values();
	        }
	
	        /**
	         * @ignore
	         * @param {LegoService} legoService
	         * @param {InputFormat} oldFormat
	         * @param {InputFormat} inputFormat
	         * @return {Promise} - The promise resolves once the callback listeners have been notified
	         */
	
	    }, {
	        key: 'performDidUpdateInputFormatCallback',
	        value: function performDidUpdateInputFormatCallback(legoService, oldFormat, inputFormat) {
	            var _this = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                try {
	                    setTimeout(function () {
	                        var previousFormat = void 0,
	                            currentFormat = void 0;
	                        if (oldFormat && oldFormat !== null) {
	                            previousFormat = oldFormat.getSimpleInputFormat();
	                        }
	                        if (inputFormat && inputFormat !== null) {
	                            currentFormat = inputFormat.getSimpleInputFormat();
	                        }
	                        if (_this.callbackListeners.size === 0) {
	                            if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                _LDSDKLogger2.default.warn('No callbacklisteners found on ' + _this.constructor.name + ' unable to callback didUpdateInputFormat');
	                            }
	                        }
	
	                        var _iteratorNormalCompletion = true;
	                        var _didIteratorError = false;
	                        var _iteratorError = undefined;
	
	                        try {
	                            for (var _iterator = (0, _getIterator3.default)(_this.callbackListeners.values()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                                var callbackListener = _step.value;
	
	                                if (typeof callbackListener.didUpdateInputFormat === 'function') {
	                                    callbackListener.didUpdateInputFormat(legoService.getSimpleService(), previousFormat, currentFormat);
	                                }
	                            }
	                        } catch (err) {
	                            _didIteratorError = true;
	                            _iteratorError = err;
	                        } finally {
	                            try {
	                                if (!_iteratorNormalCompletion && _iterator.return) {
	                                    _iterator.return();
	                                }
	                            } finally {
	                                if (_didIteratorError) {
	                                    throw _iteratorError;
	                                }
	                            }
	                        }
	                    }, 0);
	                    return resolve();
	                } catch (err) {
	                    return reject(err);
	                }
	            });
	        }
	
	        /**
	         * @ignore
	         * @param {LegoService} legoService
	         * @param {*} oldData
	         * @param {*} valueData
	         * @return {Promise} - The promise resolves once the callback listeners have been notified
	         */
	
	    }, {
	        key: 'performDidUpdateValueDataCallback',
	        value: function performDidUpdateValueDataCallback(legoService, oldData, valueData) {
	            var _this2 = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                setTimeout(function () {
	                    try {
	                        var simpleService = legoService.getSimpleService();
	                        if (_this2.callbackListeners.size === 0) {
	                            if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                _LDSDKLogger2.default.warn('No callbacklisteners found on ' + _this2.constructor.name + ' unable to callback didUpdateValueData');
	                            }
	                        }
	
	                        var _iteratorNormalCompletion2 = true;
	                        var _didIteratorError2 = false;
	                        var _iteratorError2 = undefined;
	
	                        try {
	                            for (var _iterator2 = (0, _getIterator3.default)(_this2.callbackListeners.values()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                                var callbackListener = _step2.value;
	
	                                if (typeof callbackListener.didUpdateValueData === 'function') {
	                                    callbackListener.didUpdateValueData(simpleService, oldData, valueData);
	                                }
	                            }
	                        } catch (err) {
	                            _didIteratorError2 = true;
	                            _iteratorError2 = err;
	                        } finally {
	                            try {
	                                if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                                    _iterator2.return();
	                                }
	                            } finally {
	                                if (_didIteratorError2) {
	                                    throw _iteratorError2;
	                                }
	                            }
	                        }
	
	                        return resolve();
	                    } catch (err) {
	                        return reject(err);
	                    }
	                }, 0);
	            });
	        }
	
	        /**
	         * @ignore
	         * @param {MotionSensor} motionSensor
	         * @param {number} oldDistance
	         * @param {number} newDistance
	         * @return {Promise} - The promise resolves once the callback listeners have been notified
	         */
	
	    }, {
	        key: 'performDidUpdateMotionSensorDistanceCallback',
	        value: function performDidUpdateMotionSensorDistanceCallback(motionSensor, oldDistance, newDistance) {
	            var _this3 = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                setTimeout(function () {
	                    try {
	                        var simpleService = motionSensor.getSimpleService();
	                        if (_this3.callbackListeners.size === 0) {
	                            if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                _LDSDKLogger2.default.warn('No callbacklisteners found on ' + _this3.constructor.name + ' unable to callback didUpdateDistance');
	                            }
	                        }
	
	                        var _iteratorNormalCompletion3 = true;
	                        var _didIteratorError3 = false;
	                        var _iteratorError3 = undefined;
	
	                        try {
	                            for (var _iterator3 = (0, _getIterator3.default)(_this3.callbackListeners.values()), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                                var callbackListener = _step3.value;
	
	                                if (typeof callbackListener.didUpdateDistance === 'function') {
	                                    callbackListener.didUpdateDistance(simpleService, oldDistance, newDistance);
	                                }
	                            }
	                        } catch (err) {
	                            _didIteratorError3 = true;
	                            _iteratorError3 = err;
	                        } finally {
	                            try {
	                                if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                                    _iterator3.return();
	                                }
	                            } finally {
	                                if (_didIteratorError3) {
	                                    throw _iteratorError3;
	                                }
	                            }
	                        }
	
	                        return resolve();
	                    } catch (err) {
	                        return reject(err);
	                    }
	                }, 0);
	            });
	        }
	
	        /**
	         * @ignore
	         * @param {MotionSensor} motionSensor
	         * @param {number} count
	         * @return {Promise} - The promise resolves once the callback listeners have been notified
	         */
	
	    }, {
	        key: 'performDidUpdateMotionSensorCountCallback',
	        value: function performDidUpdateMotionSensorCountCallback(motionSensor, count) {
	            var _this4 = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                setTimeout(function () {
	                    try {
	                        var simpleService = motionSensor.getSimpleService();
	                        if (_this4.callbackListeners.size === 0) {
	                            if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                _LDSDKLogger2.default.warn('No callbacklisteners found on ' + _this4.constructor.name + ' unable to callback didUpdateCount');
	                            }
	                        }
	                        var _iteratorNormalCompletion4 = true;
	                        var _didIteratorError4 = false;
	                        var _iteratorError4 = undefined;
	
	                        try {
	                            for (var _iterator4 = (0, _getIterator3.default)(_this4.callbackListeners.values()), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	                                var callbackListener = _step4.value;
	
	                                if (typeof callbackListener.didUpdateCount === 'function') {
	                                    callbackListener.didUpdateCount(simpleService, count);
	                                }
	                            }
	                        } catch (err) {
	                            _didIteratorError4 = true;
	                            _iteratorError4 = err;
	                        } finally {
	                            try {
	                                if (!_iteratorNormalCompletion4 && _iterator4.return) {
	                                    _iterator4.return();
	                                }
	                            } finally {
	                                if (_didIteratorError4) {
	                                    throw _iteratorError4;
	                                }
	                            }
	                        }
	
	                        return resolve();
	                    } catch (err) {
	                        return reject(err);
	                    }
	                }, 0);
	            });
	        }
	
	        /**
	         * @ignore
	         * @param {RGBLight} rgbLight
	         * @return {Promise} - The promise resolves once the callback listeners have been notified
	         */
	
	    }, {
	        key: 'performRGBLightDefaultColorInitializedCallback',
	        value: function performRGBLightDefaultColorInitializedCallback(rgbLight) {
	            var _this5 = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                try {
	                    setTimeout(function () {
	                        var simpleService = rgbLight.getSimpleService();
	                        if (_this5.callbackListeners.size === 0) {
	                            if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                _LDSDKLogger2.default.warn('No callbacklisteners found on ' + _this5.constructor.name + ' unable to callback didReadInitialColor');
	                            }
	                        }
	
	                        var _iteratorNormalCompletion5 = true;
	                        var _didIteratorError5 = false;
	                        var _iteratorError5 = undefined;
	
	                        try {
	                            for (var _iterator5 = (0, _getIterator3.default)(_this5.callbackListeners.values()), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	                                var callbackListener = _step5.value;
	
	                                if (typeof callbackListener.didReadInitialColor === 'function') {
	                                    callbackListener.didReadInitialColor(simpleService);
	                                }
	                            }
	                        } catch (err) {
	                            _didIteratorError5 = true;
	                            _iteratorError5 = err;
	                        } finally {
	                            try {
	                                if (!_iteratorNormalCompletion5 && _iterator5.return) {
	                                    _iterator5.return();
	                                }
	                            } finally {
	                                if (_didIteratorError5) {
	                                    throw _iteratorError5;
	                                }
	                            }
	                        }
	                    }, 0);
	                    return resolve();
	                } catch (err) {
	                    return reject(err);
	                }
	            });
	        }
	
	        /**
	         * @ignore
	         * @param {RGBLight} rgbLight
	         * @param {RGBColor} oldColor
	         * @param {RGBColor} color
	         * @return {Promise} - The promise resolves once the callback listeners have been notified
	         */
	
	    }, {
	        key: 'performRGBLightDidUpdateValueCallback',
	        value: function performRGBLightDidUpdateValueCallback(rgbLight, oldColor, color) {
	            var _this6 = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                setTimeout(function () {
	                    try {
	                        var simpleService = rgbLight.getSimpleService();
	                        if (_this6.callbackListeners.size === 0) {
	                            if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                _LDSDKLogger2.default.warn('No callbacklisteners found on ' + _this6.constructor.name + ' unable to callback didUpdateRGBValue');
	                            }
	                        }
	
	                        var _iteratorNormalCompletion6 = true;
	                        var _didIteratorError6 = false;
	                        var _iteratorError6 = undefined;
	
	                        try {
	                            for (var _iterator6 = (0, _getIterator3.default)(_this6.callbackListeners.values()), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	                                var callbackListener = _step6.value;
	
	                                if (typeof callbackListener.didUpdateRGBValue === 'function') {
	                                    callbackListener.didUpdateRGBValue(simpleService, oldColor, color);
	                                }
	                            }
	                        } catch (err) {
	                            _didIteratorError6 = true;
	                            _iteratorError6 = err;
	                        } finally {
	                            try {
	                                if (!_iteratorNormalCompletion6 && _iterator6.return) {
	                                    _iterator6.return();
	                                }
	                            } finally {
	                                if (_didIteratorError6) {
	                                    throw _iteratorError6;
	                                }
	                            }
	                        }
	
	                        return resolve();
	                    } catch (err) {
	                        return reject(err);
	                    }
	                }, 0);
	            });
	        }
	
	        /**
	         * @ignore
	         * @param {RGBLight} rgbLight
	         * @param {number} oldColorIndex
	         * @param {number} newColorIndex
	         * @return {Promise} - The promise resolves once the callback listeners have been notified
	         */
	
	    }, {
	        key: 'performRGBLightDidUpdateColorIndexCallback',
	        value: function performRGBLightDidUpdateColorIndexCallback(rgbLight, oldColorIndex, newColorIndex) {
	            var _this7 = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                setTimeout(function () {
	                    try {
	                        var simpleService = rgbLight.getSimpleService();
	                        if (_this7.callbackListeners.size === 0) {
	                            if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                _LDSDKLogger2.default.warn('No callbacklisteners found on ' + _this7.constructor.name + ' unable to callback didUpdateRGBColorIndex');
	                            }
	                        }
	
	                        var _iteratorNormalCompletion7 = true;
	                        var _didIteratorError7 = false;
	                        var _iteratorError7 = undefined;
	
	                        try {
	                            for (var _iterator7 = (0, _getIterator3.default)(_this7.callbackListeners.values()), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
	                                var callbackListener = _step7.value;
	
	                                if (typeof callbackListener.didUpdateRGBColorIndex === 'function') {
	                                    callbackListener.didUpdateRGBColorIndex(simpleService, oldColorIndex, newColorIndex);
	                                }
	                            }
	                        } catch (err) {
	                            _didIteratorError7 = true;
	                            _iteratorError7 = err;
	                        } finally {
	                            try {
	                                if (!_iteratorNormalCompletion7 && _iterator7.return) {
	                                    _iterator7.return();
	                                }
	                            } finally {
	                                if (_didIteratorError7) {
	                                    throw _iteratorError7;
	                                }
	                            }
	                        }
	
	                        return resolve();
	                    } catch (err) {
	                        return reject(err);
	                    }
	                }, 0);
	            });
	        }
	
	        /**
	         * @ignore
	         * @param {TiltSensor} tiltSensor
	         * @param {TiltSensorDirection} oldDirection
	         * @param {TiltSensorDirection} direction
	         * @return {Promise} - The promise resolves once the callback listeners have been notified
	         */
	
	    }, {
	        key: 'performDidUpdateTiltDirection',
	        value: function performDidUpdateTiltDirection(tiltSensor, oldDirection, direction) {
	            var _this8 = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                setTimeout(function () {
	                    try {
	                        var simpleService = tiltSensor.getSimpleService();
	                        if (_this8.callbackListeners.size === 0) {
	                            if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                _LDSDKLogger2.default.warn('No callbacklisteners found on ' + _this8.constructor.name + ' unable to callback didUpdateDirection');
	                            }
	                        }
	
	                        var _iteratorNormalCompletion8 = true;
	                        var _didIteratorError8 = false;
	                        var _iteratorError8 = undefined;
	
	                        try {
	                            for (var _iterator8 = (0, _getIterator3.default)(_this8.callbackListeners.values()), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
	                                var callbackListener = _step8.value;
	
	                                if (typeof callbackListener.didUpdateDirection === 'function') {
	                                    callbackListener.didUpdateDirection(simpleService, oldDirection, direction);
	                                }
	                            }
	                        } catch (err) {
	                            _didIteratorError8 = true;
	                            _iteratorError8 = err;
	                        } finally {
	                            try {
	                                if (!_iteratorNormalCompletion8 && _iterator8.return) {
	                                    _iterator8.return();
	                                }
	                            } finally {
	                                if (_didIteratorError8) {
	                                    throw _iteratorError8;
	                                }
	                            }
	                        }
	
	                        return resolve();
	                    } catch (err) {
	                        return reject(err);
	                    }
	                }, 0);
	            });
	        }
	
	        /**
	         * @ignore
	         * @param {TiltSensor} tiltSensor
	         * @param {TiltSensorAngle} oldAngle
	         * @param {TiltSensorAngle} angle
	         * @return {Promise} - The promise resolves once the callback listeners have been notified
	         */
	
	    }, {
	        key: 'performDidUpdateTiltAngle',
	        value: function performDidUpdateTiltAngle(tiltSensor, oldAngle, angle) {
	            var _this9 = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                setTimeout(function () {
	                    try {
	                        var simpleService = tiltSensor.getSimpleService();
	                        if (_this9.callbackListeners.size === 0) {
	                            if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                _LDSDKLogger2.default.warn('No callbacklisteners found on ' + _this9.constructor.name + ' unable to callback didUpdateAngle');
	                            }
	                        }
	
	                        var _iteratorNormalCompletion9 = true;
	                        var _didIteratorError9 = false;
	                        var _iteratorError9 = undefined;
	
	                        try {
	                            for (var _iterator9 = (0, _getIterator3.default)(_this9.callbackListeners.values()), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
	                                var callbackListener = _step9.value;
	
	                                if (typeof callbackListener.didUpdateAngle === 'function') {
	                                    callbackListener.didUpdateAngle(simpleService, oldAngle, angle);
	                                }
	                            }
	                        } catch (err) {
	                            _didIteratorError9 = true;
	                            _iteratorError9 = err;
	                        } finally {
	                            try {
	                                if (!_iteratorNormalCompletion9 && _iterator9.return) {
	                                    _iterator9.return();
	                                }
	                            } finally {
	                                if (_didIteratorError9) {
	                                    throw _iteratorError9;
	                                }
	                            }
	                        }
	
	                        return resolve();
	                    } catch (err) {
	                        return reject(err);
	                    }
	                }, 0);
	            });
	        }
	
	        /**
	         * @ignore
	         * @param {TiltSensor} tiltSensor
	         * @param {TiltSensorCrash} oldCrash
	         * @param {TiltSensorCrash} crash
	         * @return {Promise} - The promise resolves once the callback listeners have been notified
	         */
	
	    }, {
	        key: 'performDidUpdateTiltCrash',
	        value: function performDidUpdateTiltCrash(tiltSensor, oldCrash, crash) {
	            var _this10 = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                setTimeout(function () {
	                    try {
	                        var simpleService = tiltSensor.getSimpleService();
	                        if (_this10.callbackListeners.size === 0) {
	                            if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                _LDSDKLogger2.default.warn('No callbacklisteners found on ' + _this10.constructor.name + ' unable to callback didUpdateCrash');
	                            }
	                        }
	
	                        var _iteratorNormalCompletion10 = true;
	                        var _didIteratorError10 = false;
	                        var _iteratorError10 = undefined;
	
	                        try {
	                            for (var _iterator10 = (0, _getIterator3.default)(_this10.callbackListeners.values()), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
	                                var callbackListener = _step10.value;
	
	                                if (typeof callbackListener.didUpdateCrash === 'function') {
	                                    callbackListener.didUpdateCrash(simpleService, oldCrash, crash);
	                                }
	                            }
	                        } catch (err) {
	                            _didIteratorError10 = true;
	                            _iteratorError10 = err;
	                        } finally {
	                            try {
	                                if (!_iteratorNormalCompletion10 && _iterator10.return) {
	                                    _iterator10.return();
	                                }
	                            } finally {
	                                if (_didIteratorError10) {
	                                    throw _iteratorError10;
	                                }
	                            }
	                        }
	
	                        return resolve();
	                    } catch (err) {
	                        return reject(err);
	                    }
	                }, 0);
	            });
	        }
	
	        /**
	         * @ignore
	         * @param {VoltageSensor} voltageSensor
	         * @param {number} milliVolts
	         * @return {Promise} - The promise resolves once the callback listeners have been notified
	         */
	
	    }, {
	        key: 'performDidUpdateMilliVolts',
	        value: function performDidUpdateMilliVolts(voltageSensor, milliVolts) {
	            var _this11 = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                setTimeout(function () {
	                    try {
	                        var simpleService = voltageSensor.getSimpleService();
	                        if (_this11.callbackListeners.size === 0) {
	                            if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                _LDSDKLogger2.default.warn('No callbacklisteners found on ' + _this11.constructor.name + ' unable to callback didUpdateMilliVolts');
	                            }
	                        }
	
	                        var _iteratorNormalCompletion11 = true;
	                        var _didIteratorError11 = false;
	                        var _iteratorError11 = undefined;
	
	                        try {
	                            for (var _iterator11 = (0, _getIterator3.default)(_this11.callbackListeners.values()), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
	                                var callbackListener = _step11.value;
	
	                                if (typeof callbackListener.didUpdateMilliVolts === 'function') {
	                                    callbackListener.didUpdateMilliVolts(simpleService, milliVolts);
	                                }
	                            }
	                        } catch (err) {
	                            _didIteratorError11 = true;
	                            _iteratorError11 = err;
	                        } finally {
	                            try {
	                                if (!_iteratorNormalCompletion11 && _iterator11.return) {
	                                    _iterator11.return();
	                                }
	                            } finally {
	                                if (_didIteratorError11) {
	                                    throw _iteratorError11;
	                                }
	                            }
	                        }
	
	                        return resolve();
	                    } catch (err) {
	                        return reject(err);
	                    }
	                }, 0);
	            });
	        }
	
	        /**
	         * @ignore
	         * @param {CurrentSensor} currentSensor
	         * @param {number} milliAmps
	         * @return {Promise} - The promise resolves once the callback listeners have been notified
	         */
	
	    }, {
	        key: 'performDidUpdateMilliAmps',
	        value: function performDidUpdateMilliAmps(currentSensor, milliAmps) {
	            var _this12 = this;
	
	            return new _promise2.default(function (resolve, reject) {
	                setTimeout(function () {
	                    try {
	                        var simpleService = currentSensor.getSimpleService();
	                        if (_this12.callbackListeners.size === 0) {
	                            if (_LDSDKLogger2.default.isWarnEnabled()) {
	                                _LDSDKLogger2.default.warn('No callbacklisteners found on ' + _this12.constructor.name + ' unable to callback didUpdateMilliAmps');
	                            }
	                        }
	
	                        var _iteratorNormalCompletion12 = true;
	                        var _didIteratorError12 = false;
	                        var _iteratorError12 = undefined;
	
	                        try {
	                            for (var _iterator12 = (0, _getIterator3.default)(_this12.callbackListeners.values()), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
	                                var callbackListener = _step12.value;
	
	                                if (typeof callbackListener.didUpdateMilliAmps === 'function') {
	                                    callbackListener.didUpdateMilliAmps(simpleService, milliAmps);
	                                }
	                            }
	                        } catch (err) {
	                            _didIteratorError12 = true;
	                            _iteratorError12 = err;
	                        } finally {
	                            try {
	                                if (!_iteratorNormalCompletion12 && _iterator12.return) {
	                                    _iterator12.return();
	                                }
	                            } finally {
	                                if (_didIteratorError12) {
	                                    throw _iteratorError12;
	                                }
	                            }
	                        }
	
	                        return resolve();
	                    } catch (err) {
	                        return reject(err);
	                    }
	                }, 0);
	            });
	        }
	
	        /**
	         * @ignore
	         * @param callbackListener
	         */
	
	    }, {
	        key: 'checkCallbackListener',
	        value: function checkCallbackListener(callbackListener) {
	            if (callbackListener === null || callbackListener === undefined) {
	                if (_LDSDKLogger2.default.isErrorEnabled()) {
	                    _LDSDKLogger2.default.error('Attempt to add undefined callback listener to ' + this.constructor.name + ' ignored');
	                }
	                return;
	            }
	        }
	    }]);
	    return LegoServiceCallbackHelper;
	}();
	
	exports.default = LegoServiceCallbackHelper;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ChromeOsBluetoothAdapterWrapper = __webpack_require__(83);
	
	var _ChromeOsBluetoothAdapterWrapper2 = _interopRequireDefault(_ChromeOsBluetoothAdapterWrapper);
	
	var _ChromeOsBluetoothDeviceWrapper = __webpack_require__(58);
	
	var _ChromeOsBluetoothDeviceWrapper2 = _interopRequireDefault(_ChromeOsBluetoothDeviceWrapper);
	
	var _LegoBluetoothDeviceImpl = __webpack_require__(59);
	
	var _LegoBluetoothDeviceImpl2 = _interopRequireDefault(_LegoBluetoothDeviceImpl);
	
	var _LegoBluetoothDeviceManagerImpl = __webpack_require__(84);
	
	var _LegoBluetoothDeviceManagerImpl2 = _interopRequireDefault(_LegoBluetoothDeviceManagerImpl);
	
	var _ConnectInfo = __webpack_require__(43);
	
	var _ConnectInfo2 = _interopRequireDefault(_ConnectInfo);
	
	var _DeviceInfo = __webpack_require__(60);
	
	var _DeviceInfo2 = _interopRequireDefault(_DeviceInfo);
	
	var _LegoDeviceImpl = __webpack_require__(27);
	
	var _LegoDeviceImpl2 = _interopRequireDefault(_LegoDeviceImpl);
	
	var _Revision = __webpack_require__(61);
	
	var _Revision2 = _interopRequireDefault(_Revision);
	
	var _LegoDeviceManager = __webpack_require__(85);
	
	var _LegoDeviceManager2 = _interopRequireDefault(_LegoDeviceManager);
	
	var _LegoDeviceManagerImpl = __webpack_require__(31);
	
	var _LegoDeviceManagerImpl2 = _interopRequireDefault(_LegoDeviceManagerImpl);
	
	var _LDSDKLogger = __webpack_require__(3);
	
	var _LDSDKLogger2 = _interopRequireDefault(_LDSDKLogger);
	
	var _CurrentSensor = __webpack_require__(90);
	
	var _CurrentSensor2 = _interopRequireDefault(_CurrentSensor);
	
	var _GenericService = __webpack_require__(91);
	
	var _GenericService2 = _interopRequireDefault(_GenericService);
	
	var _LegoService = __webpack_require__(18);
	
	var _LegoService2 = _interopRequireDefault(_LegoService);
	
	var _LegoServiceFactory = __webpack_require__(63);
	
	var _LegoServiceFactory2 = _interopRequireDefault(_LegoServiceFactory);
	
	var _MotionSensor = __webpack_require__(92);
	
	var _MotionSensor2 = _interopRequireDefault(_MotionSensor);
	
	var _RGBLight = __webpack_require__(94);
	
	var _RGBLight2 = _interopRequireDefault(_RGBLight);
	
	var _SimpleMotor = __webpack_require__(95);
	
	var _SimpleMotor2 = _interopRequireDefault(_SimpleMotor);
	
	var _TiltSensor = __webpack_require__(96);
	
	var _TiltSensor2 = _interopRequireDefault(_TiltSensor);
	
	var _VoltageSensor = __webpack_require__(97);
	
	var _VoltageSensor2 = _interopRequireDefault(_VoltageSensor);
	
	var _PiezoTonePlayer = __webpack_require__(93);
	
	var _PiezoTonePlayer2 = _interopRequireDefault(_PiezoTonePlayer);
	
	var _DataFormat = __webpack_require__(46);
	
	var _DataFormat2 = _interopRequireDefault(_DataFormat);
	
	var _InputCommands = __webpack_require__(88);
	
	var _InputCommands2 = _interopRequireDefault(_InputCommands);
	
	var _InputFormat = __webpack_require__(22);
	
	var _InputFormat2 = _interopRequireDefault(_InputFormat);
	
	var _OutputCommand = __webpack_require__(89);
	
	var _OutputCommand2 = _interopRequireDefault(_OutputCommand);
	
	var _BaseServiceDefinition = __webpack_require__(36);
	
	var _BaseServiceDefinition2 = _interopRequireDefault(_BaseServiceDefinition);
	
	var _BatteryServiceDefinition = __webpack_require__(98);
	
	var _BatteryServiceDefinition2 = _interopRequireDefault(_BatteryServiceDefinition);
	
	var _BluetoothServiceDefinition = __webpack_require__(37);
	
	var _BluetoothServiceDefinition2 = _interopRequireDefault(_BluetoothServiceDefinition);
	
	var _CharacteristicDefinition = __webpack_require__(38);
	
	var _CharacteristicDefinition2 = _interopRequireDefault(_CharacteristicDefinition);
	
	var _DeviceInfoServiceDefinition = __webpack_require__(32);
	
	var _DeviceInfoServiceDefinition2 = _interopRequireDefault(_DeviceInfoServiceDefinition);
	
	var _DeviceServiceDefinition = __webpack_require__(47);
	
	var _DeviceServiceDefinition2 = _interopRequireDefault(_DeviceServiceDefinition);
	
	var _IOServiceDefinition = __webpack_require__(48);
	
	var _IOServiceDefinition2 = _interopRequireDefault(_IOServiceDefinition);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Created by frj on 17/02/16.
	 */
	var ChromeShim = __webpack_require__(117);
	var DebugHelper = __webpack_require__(118);
	var StorageHelper = __webpack_require__(86);
	
	// Define the exports that need to be accessible for consumers of the library
	// These exports will be available as named exports meaning the user needs to import them like:
	// import { ConnectInfo } from 'smarthub_commlib';
	//
	module.exports = {
	    // bluetooth package exports
	    ChromeOsBluetoothAdapterWrapper: _ChromeOsBluetoothAdapterWrapper2.default,
	    ChromeOsBluetoothDeviceWrapper: _ChromeOsBluetoothDeviceWrapper2.default,
	    LegoBluetoothDeviceImpl: _LegoBluetoothDeviceImpl2.default,
	    LegoBluetoothDeviceManagerImpl: _LegoBluetoothDeviceManagerImpl2.default,
	
	    // device package exports
	    ConnectInfo: _ConnectInfo2.default, IOType: _ConnectInfo.IOType,
	    DeviceInfo: _DeviceInfo2.default,
	    LegoDeviceImpl: _LegoDeviceImpl2.default, DeviceCategoryEnum: _LegoDeviceImpl.DeviceCategoryEnum, DeviceFunctionEnum: _LegoDeviceImpl.DeviceFunctionEnum, StateEnum: _LegoDeviceImpl.StateEnum,
	    LegoDeviceManager: _LegoDeviceManager2.default,
	    LegoDeviceManagerImpl: _LegoDeviceManagerImpl2.default,
	    LegoDeviceManagerConfig: _LegoDeviceManagerImpl.LegoDeviceManagerConfig,
	    Revision: _Revision2.default,
	
	    // helpers package exports
	    LDSDKLogger: _LDSDKLogger2.default,
	    StorageHelper: StorageHelper,
	
	    // io/services package exports
	    CurrentSensor: _CurrentSensor2.default,
	    VoltageSensor: _VoltageSensor2.default,
	    GenericService: _GenericService2.default,
	    LegoService: _LegoService2.default,
	    LegoServiceFactory: _LegoServiceFactory2.default,
	    MotionSensor: _MotionSensor2.default, MotionSensorMode: _MotionSensor.MotionSensorMode,
	    RGBLight: _RGBLight2.default, RGBColor: _RGBLight.RGBColor, RGBLightMode: _RGBLight.RGBLightMode,
	    SimpleMotor: _SimpleMotor2.default, MotorDirection: _SimpleMotor.MotorDirection,
	    TiltSensor: _TiltSensor2.default, TiltSensorDirection: _TiltSensor.TiltSensorDirection, TiltSensorMode: _TiltSensor.TiltSensorMode, TiltSensorAngle: _TiltSensor.TiltSensorAngle, TiltSensorCrash: _TiltSensor.TiltSensorCrash,
	    PiezoTonePlayer: _PiezoTonePlayer2.default, PiezoTonePlayerNote: _PiezoTonePlayer.PiezoTonePlayerNote,
	
	    // io package exports
	    DataFormat: _DataFormat2.default,
	    InputCommand: _InputCommands2.default,
	    InputFormat: _InputFormat2.default, InputFormatUnit: _InputFormat.InputFormatUnit,
	    OutputCommand: _OutputCommand2.default,
	
	    // Service definitions package
	    BaseServiceDefinition: _BaseServiceDefinition2.default,
	    BatteryServiceDefinition: _BatteryServiceDefinition2.default,
	    BluetoothServiceDefinition: _BluetoothServiceDefinition2.default,
	    CharacteristicDefinition: _CharacteristicDefinition2.default,
	    DeviceInfoServiceDefinition: _DeviceInfoServiceDefinition2.default,
	    DeviceServiceDefinition: _DeviceServiceDefinition2.default,
	    IOServiceDefinition: _IOServiceDefinition2.default
	
	    // ChromeShim: ChromeShim
	    // DebugHelper: DebugHelper
	
	};

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(133), __esModule: true };

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(136), __esModule: true };

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(137), __esModule: true };

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(138), __esModule: true };

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(140), __esModule: true };

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(141), __esModule: true };

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(143), __esModule: true };

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(144), __esModule: true };

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _isIterable2 = __webpack_require__(123);
	
	var _isIterable3 = _interopRequireDefault(_isIterable2);
	
	var _getIterator2 = __webpack_require__(33);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;
	
	    try {
	      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);
	
	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }
	
	    return _arr;
	  }
	
	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if ((0, _isIterable3.default)(Object(arr))) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(42);
	__webpack_require__(41);
	module.exports = __webpack_require__(169);

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(42);
	__webpack_require__(41);
	module.exports = __webpack_require__(170);

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(4)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(81);
	__webpack_require__(41);
	__webpack_require__(42);
	__webpack_require__(172);
	__webpack_require__(181);
	module.exports = __webpack_require__(4).Map;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(173);
	var $Object = __webpack_require__(4).Object;
	module.exports = function create(P, D){
	  return $Object.create(P, D);
	};

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(174);
	var $Object = __webpack_require__(4).Object;
	module.exports = function defineProperty(it, key, desc){
	  return $Object.defineProperty(it, key, desc);
	};

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(175);
	var $Object = __webpack_require__(4).Object;
	module.exports = function getOwnPropertyDescriptor(it, key){
	  return $Object.getOwnPropertyDescriptor(it, key);
	};

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(176);
	module.exports = __webpack_require__(4).Object.getPrototypeOf;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(177);
	module.exports = __webpack_require__(4).Object.is;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(178);
	module.exports = __webpack_require__(4).Object.setPrototypeOf;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(81);
	__webpack_require__(41);
	__webpack_require__(42);
	__webpack_require__(179);
	module.exports = __webpack_require__(4).Promise;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(180);
	__webpack_require__(81);
	__webpack_require__(182);
	__webpack_require__(183);
	module.exports = __webpack_require__(4).Symbol;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(41);
	__webpack_require__(42);
	module.exports = __webpack_require__(80).f('iterator');

/***/ }),
/* 145 */
/***/ (function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(52);
	
	module.exports = function(iter, ITERATOR){
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(26)
	  , toLength  = __webpack_require__(76)
	  , toIndex   = __webpack_require__(168);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(29)
	  , IObject  = __webpack_require__(101)
	  , toObject = __webpack_require__(77)
	  , toLength = __webpack_require__(76)
	  , asc      = __webpack_require__(150);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(25)
	  , isArray  = __webpack_require__(102)
	  , SPECIES  = __webpack_require__(8)('species');
	
	module.exports = function(original){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(149);
	
	module.exports = function(original, length){
	  return new (speciesConstructor(original))(length);
	};

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var dP          = __webpack_require__(17).f
	  , create      = __webpack_require__(54)
	  , redefineAll = __webpack_require__(72)
	  , ctx         = __webpack_require__(29)
	  , anInstance  = __webpack_require__(65)
	  , defined     = __webpack_require__(51)
	  , forOf       = __webpack_require__(52)
	  , $iterDefine = __webpack_require__(68)
	  , step        = __webpack_require__(103)
	  , setSpecies  = __webpack_require__(110)
	  , DESCRIPTORS = __webpack_require__(15)
	  , fastKey     = __webpack_require__(69).fastKey
	  , SIZE        = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)dP(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(50)
	  , from    = __webpack_require__(146);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var global         = __webpack_require__(10)
	  , $export        = __webpack_require__(16)
	  , meta           = __webpack_require__(69)
	  , fails          = __webpack_require__(34)
	  , hide           = __webpack_require__(24)
	  , redefineAll    = __webpack_require__(72)
	  , forOf          = __webpack_require__(52)
	  , anInstance     = __webpack_require__(65)
	  , isObject       = __webpack_require__(25)
	  , setToStringTag = __webpack_require__(40)
	  , dP             = __webpack_require__(17).f
	  , each           = __webpack_require__(148)(0)
	  , DESCRIPTORS    = __webpack_require__(15);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    C = wrapper(function(target, iterable){
	      anInstance(target, C, NAME, '_c');
	      target._c = new Base;
	      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
	    });
	    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','),function(KEY){
	      var IS_ADDER = KEY == 'add' || KEY == 'set';
	      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
	        anInstance(this, C, KEY);
	        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
	        var result = this._c[KEY](a === 0 ? 0 : a, b);
	        return IS_ADDER ? this : result;
	      });
	    });
	    if('size' in proto)dP(C.prototype, 'size', {
	      get: function(){
	        return this._c.size;
	      }
	    });
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F, O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(55)
	  , gOPS    = __webpack_require__(105)
	  , pIE     = __webpack_require__(71);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ }),
/* 155 */
/***/ (function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(35)
	  , ITERATOR   = __webpack_require__(8)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(20);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(54)
	  , descriptor     = __webpack_require__(56)
	  , setToStringTag = __webpack_require__(40)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(24)(IteratorPrototype, __webpack_require__(8)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(8)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(55)
	  , toIObject = __webpack_require__(26);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(10)
	  , macrotask = __webpack_require__(111).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(39)(process) == 'process';
	
	module.exports = function(){
	  var head, last, notify;
	
	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };
	
	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(17)
	  , anObject = __webpack_require__(20)
	  , getKeys  = __webpack_require__(55);
	
	module.exports = __webpack_require__(15) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(26)
	  , gOPN      = __webpack_require__(104).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ }),
/* 164 */
/***/ (function(module, exports) {

	// 7.2.9 SameValue(x, y)
	module.exports = Object.is || function is(x, y){
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(25)
	  , anObject = __webpack_require__(20);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(29)(Function.call, __webpack_require__(70).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(20)
	  , aFunction = __webpack_require__(64)
	  , SPECIES   = __webpack_require__(8)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(75)
	  , defined   = __webpack_require__(51);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(75)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(20)
	  , get      = __webpack_require__(112);
	module.exports = __webpack_require__(4).getIterator = function(it){
	  var iterFn = get(it);
	  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
	  return anObject(iterFn.call(it));
	};

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(50)
	  , ITERATOR  = __webpack_require__(8)('iterator')
	  , Iterators = __webpack_require__(35);
	module.exports = __webpack_require__(4).isIterable = function(it){
	  var O = Object(it);
	  return O[ITERATOR] !== undefined
	    || '@@iterator' in O
	    || Iterators.hasOwnProperty(classof(O));
	};

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(145)
	  , step             = __webpack_require__(103)
	  , Iterators        = __webpack_require__(35)
	  , toIObject        = __webpack_require__(26);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(68)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(151);
	
	// 23.1 Map Objects
	module.exports = __webpack_require__(153)('Map', function(get){
	  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(16)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(54)});

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(16);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(15), 'Object', {defineProperty: __webpack_require__(17).f});

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject                 = __webpack_require__(26)
	  , $getOwnPropertyDescriptor = __webpack_require__(70).f;
	
	__webpack_require__(108)('getOwnPropertyDescriptor', function(){
	  return function getOwnPropertyDescriptor(it, key){
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(77)
	  , $getPrototypeOf = __webpack_require__(106);
	
	__webpack_require__(108)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.10 Object.is(value1, value2)
	var $export = __webpack_require__(16);
	$export($export.S, 'Object', {is: __webpack_require__(164)});

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(16);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(165).set});

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(53)
	  , global             = __webpack_require__(10)
	  , ctx                = __webpack_require__(29)
	  , classof            = __webpack_require__(50)
	  , $export            = __webpack_require__(16)
	  , isObject           = __webpack_require__(25)
	  , aFunction          = __webpack_require__(64)
	  , anInstance         = __webpack_require__(65)
	  , forOf              = __webpack_require__(52)
	  , speciesConstructor = __webpack_require__(166)
	  , task               = __webpack_require__(111).set
	  , microtask          = __webpack_require__(161)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;
	
	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(8)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(72)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(40)($Promise, PROMISE);
	__webpack_require__(110)(PROMISE);
	Wrapper = __webpack_require__(4)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(159)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(10)
	  , has            = __webpack_require__(30)
	  , DESCRIPTORS    = __webpack_require__(15)
	  , $export        = __webpack_require__(16)
	  , redefine       = __webpack_require__(109)
	  , META           = __webpack_require__(69).KEY
	  , $fails         = __webpack_require__(34)
	  , shared         = __webpack_require__(74)
	  , setToStringTag = __webpack_require__(40)
	  , uid            = __webpack_require__(57)
	  , wks            = __webpack_require__(8)
	  , wksExt         = __webpack_require__(80)
	  , wksDefine      = __webpack_require__(79)
	  , keyOf          = __webpack_require__(160)
	  , enumKeys       = __webpack_require__(154)
	  , isArray        = __webpack_require__(102)
	  , anObject       = __webpack_require__(20)
	  , toIObject      = __webpack_require__(26)
	  , toPrimitive    = __webpack_require__(78)
	  , createDesc     = __webpack_require__(56)
	  , _create        = __webpack_require__(54)
	  , gOPNExt        = __webpack_require__(163)
	  , $GOPD          = __webpack_require__(70)
	  , $DP            = __webpack_require__(17)
	  , $keys          = __webpack_require__(55)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(104).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(71).f  = $propertyIsEnumerable;
	  __webpack_require__(105).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(53)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(24)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(16);
	
	$export($export.P + $export.R, 'Map', {toJSON: __webpack_require__(152)('Map')});

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(79)('asyncIterator');

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(79)('observable');

/***/ }),
/* 184 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be
	// kept identical to the way it is obtained in runtime.js
	var g =
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this;
	
	// Use `getOwnPropertyNames` because not all browsers support calling
	// `hasOwnProperty` on the global `self` object in a worker. See #183.
	var hadRuntime = g.regeneratorRuntime &&
	  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
	
	// Save the old regeneratorRuntime in case it needs to be restored later.
	var oldRuntime = hadRuntime && g.regeneratorRuntime;
	
	// Force reevalutation of runtime.js.
	g.regeneratorRuntime = undefined;
	
	module.exports = __webpack_require__(186);
	
	if (hadRuntime) {
	  // Restore the original runtime.
	  g.regeneratorRuntime = oldRuntime;
	} else {
	  // Remove the global property added by runtime.js.
	  try {
	    delete g.regeneratorRuntime;
	  } catch(e) {
	    g.regeneratorRuntime = undefined;
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  IteratorPrototype[iteratorSymbol] = function () {
	    return this;
	  };
	
	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }
	
	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] =
	    GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  runtime.awrap = function(arg) {
	    return { __await: arg };
	  };
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return Promise.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	  runtime.AsyncIterator = AsyncIterator;
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      context.method = method;
	      context.arg = arg;
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }
	
	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;
	
	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }
	
	          context.dispatchException(context.arg);
	
	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          if (record.arg === ContinueSentinel) {
	            continue;
	          }
	
	          return {
	            value: record.arg,
	            done: context.done
	          };
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;
	
	      if (context.method === "throw") {
	        if (delegate.iterator.return) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined;
	          maybeInvokeDelegate(delegate, context);
	
	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }
	
	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }
	
	      return ContinueSentinel;
	    }
	
	    var record = tryCatch(method, delegate.iterator, context.arg);
	
	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }
	
	    var info = record.arg;
	
	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }
	
	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;
	
	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;
	
	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined;
	      }
	
	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }
	
	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.method = "next";
	      this.arg = undefined;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	
	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined;
	        }
	
	        return !! caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }
	
	      return this.complete(record);
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	
	      return ContinueSentinel;
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined;
	      }
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(184)))

/***/ })
/******/ ])
});
;
//# sourceMappingURL=lego.components.blesdk.js.map